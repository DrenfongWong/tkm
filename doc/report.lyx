#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{tabu,longtable}
\usepackage{booktabs}
\usepackage{ifthen}

\definecolor{newyellow}{rgb}{1,1,0.8}
\definecolor{colKeys}{rgb}{0,0,1}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{1,0,0}
\definecolor{colString}{rgb}{0,0.5,0}

\newenvironment{typedefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}r>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Size & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{vartypedefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}r>{\tt}r>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Data & \sf\bf Size & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{constantdefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}l>{\it}X}
\caption{#1} \\
\toprule\sf\bf Name & \sf\bf Hexvalue & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{contextstates}[1]
{\begin{longtabu} to \textwidth{>{\tt}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{contexttransitions}[1]
{\tabulinesep=4pt
\begin{longtabu} to \textwidth{>{\tt}lp{2.5cm}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Source  & \sf\bf Target & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{exchangeparameters}[1]
{\begin{longtabu} to \textwidth{>{\tt}l>{\tt}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Type & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{messages}{\bigskip
\begin{tabu} to \textwidth{l>{\tt}c>{\tt}ccc>{\it}X}}
{\end{tabu}\bigskip}
\newcommand{\msg}[4]{\ifthenelse{\equal{#1}{}}{}{#1\quad }
& \texttt{#2}
& \ifthenelse{\equal{#3}{}}{}{$\rightarrow$}
& \texttt{#3}
& \ifthenelse{\equal{#3}{}}{}{\ :\quad}
& \it{#4}\\}
\newcommand{\hex}[1]{\textrm{0x#1}}
\newcommand{\subscript}[1]{\ensuremath{_{\textrm{#1}}}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "IKE Separation"
\pdf_author "Reto Buerki, Adrian-Ken Rüegsegger"
\pdf_subject "Extraction of security critical components into a Trusted Computing Base (TCB)"
\pdf_keywords "Separation, TCB, IPsec, IKE, IKEv2, Security, Ada"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\listings_params "backgroundcolor={\color{newyellow}},basicstyle={\ttfamily\small},breakautoindent=true,breaklines=true,captionpos=b,commentstyle={\color{colComments}},extendedchars=true,frame=single,identifierstyle={\color{colIdentifier}},keywordstyle={\color{colKeys}},language=Ada,numbers=left,numberstyle={\tiny},showspaces=false,showstringspaces=false,stringstyle={\color{colString}},tabsize=4"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
IKEv2 Separation:
\begin_inset Newline newline
\end_inset

Extraction of security critical components into a Trusted Computing Base
 (TCB)
\end_layout

\begin_layout Author
Reto Bürki, Adrian-Ken Rüegsegger
\end_layout

\begin_layout Standard
\align center
University of Applied Sciences Rapperswil (HSR), Switzerland
\end_layout

\begin_layout Abstract
The IPsec protocol relies on the correct operation of the IKE key exchange
 to meet its security goals.
 The implementation of the IKE protocol is a non-trivial task and results
 in a large and complex code base.
 This makes it hard to gain a high degree of confidence in the correct operation
 of the code.
\end_layout

\begin_layout Abstract
The security and robustness of the IKE implementation strongSwan has been
 augmented, by identifying and separating security critical from non-critical
 components and extracting them into a minimal TCB.
 The TCB has been implemented using the Ada programming language.
\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
In a system with high requirements on security, functions relevant to guarantee
 these requirements must be isolated from the rest of the system and consolidate
d in a Trusted Computing Base (TCB)
\begin_inset Index idx
status open

\begin_layout Plain Layout
TCB
\end_layout

\end_inset

.
 To be trusted, this code must be as minimal as possible to allow formal
 verification of code correctness.
 Lampson et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Lampson:1991:ADS:121133.121160"

\end_inset

 define the TCB of a computer system as:
\end_layout

\begin_layout Quote
A small amount of software and hardware that security depends on and that
 we distinguish from a much larger amount that can misbehave without affecting
 security.
\end_layout

\begin_layout Standard
It is an easier task to design a system from scratch with separation properties
 in mind than dividing an existing project or protocol later.
 This is not always possible, and more importantly, sometimes not intended.
 Functionality in an existing system identified as uncritical should be
 left as is as much as possible.
\end_layout

\begin_layout Standard
In order to isolate functionality in a TCB, critical sections of existing
 systems must be identified and they must be separated into a critical (trusted)
 and non-critical (untrusted) part.
 Communication mechanisms between the sections needs to be established,
 which must be robust and well defined.
 If an attacker is able to compromise the untrusted-part of the system,
 the security and integrity functions guaranteed by the TCB must still hold.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Trusted-Computing-Base"

\end_inset

 depicts a simple schematic of an example TCB.
 Components colored in red specify trusted components inside the TCB.
 The TCB normally consists of multiple such components which implement different
, separated functionality.
 One or more untrusted components colored in black exchange data with the
 TCB over an interface.
 This coloring scheme is used throughout this document to label untrusted
 and untrusted components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trusted-untrusted.svg
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Trusted Computing Base
\begin_inset CommandInset label
LatexCommand label
name "fig:Trusted-Computing-Base"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
This section gives an introduction into the terminology and systems used
 in this project and explains the basic key concepts.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ipsec-IKEv2"

\end_inset

 briefly outlines IPsec and the IKEv2 protocol, section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:strongSwan"

\end_inset

 introduces an implementation of this protocol in the form of the strongSwan
\begin_inset Index idx
status open

\begin_layout Plain Layout
strongSwan
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.strongswan.org/
\end_layout

\end_inset


\end_layout

\end_inset

 project.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ada"

\end_inset

 summarizes the most important aspects of the Ada programming language,
 which is used to implement the Trusted Key Manager (TKM) specified by this
 paper.
 The term TKM is explained in the following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Trusted-Key-Manager"

\end_inset

.
\end_layout

\begin_layout Subsection
IPsec and IKEv2
\begin_inset CommandInset label
LatexCommand label
name "sub:ipsec-IKEv2"

\end_inset


\end_layout

\begin_layout Standard
Internet Protocol Security (IPsec
\begin_inset Index idx
status open

\begin_layout Plain Layout
IPsec
\end_layout

\end_inset

) provides, as the name implies, security services to the Internet Protocol
 (IP
\begin_inset Index idx
status open

\begin_layout Plain Layout
IP
\end_layout

\end_inset

).
 This is done by encrypting and authenticating IP packets of communication
 sessions.
 The protection is transparent to the communicating applications because
 it is performed in the IP layer.
 To protect packets, cryptographic transforms are applied to them which
 in turn require cryptographic keys.
 The bundle of algorithms and data that provide the parameters necessary
 to operate these cryptographic transforms are called a security association
 (SA
\begin_inset Index idx
status open

\begin_layout Plain Layout
SA
\end_layout

\end_inset

).
 For more information on the IPsec protocol suites, the reader is directed
 to the corresponding 
\emph on

\begin_inset Quotes eld
\end_inset

Security Architecture for the Internet Protocol
\begin_inset Quotes erd
\end_inset

 
\emph default
RFC 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4301"

\end_inset

.
\end_layout

\begin_layout Standard
Parameters and keys needed to establish a security association are usually
 provided to the IPsec protocol suite by means of the Internet Key Exchange
 (IKE
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE
\end_layout

\end_inset

) protocol.
 The IKE protocol is responsible for the key establishment phase and the
 negotiation of the cryptographic algorithms between communicating endpoints.
 There are two versions of the IKE protocol: IKEv1
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv1
\end_layout

\end_inset

 and IKEv2 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc2409,rfc5996"

\end_inset

.
 IKEv2
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv2
\end_layout

\end_inset

 was designed to add new features and correct some problems found in the
 previous version.
 This project exclusively targets the newer IKEv2 protocol, IKEv1 is not
 considered.
\end_layout

\begin_layout Standard
To negotiate cryptographic keys, SA parameters and to perform mutual authenticat
ion, message pairs are exchanged between the participating peers.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKEv2-protocol-analysis"

\end_inset

 explains the message exchanges of the IKEv2 protocol in detail.
 The service implementing the IKE protocol is normally provided by an user
 space application.
 The following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:strongSwan"

\end_inset

 introduces the strongSwan project, which provides an implementation for
 both IKEv1 and IKEv2.
\end_layout

\begin_layout Subsection
strongSwan
\begin_inset Index idx
status open

\begin_layout Plain Layout
strongSwan
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:strongSwan"

\end_inset


\end_layout

\begin_layout Standard
The strongSwan project is an open-source IPsec-based VPN solution for Unix-like
 operating systems.
 It provides the charon
\begin_inset Index idx
status open

\begin_layout Plain Layout
charon
\end_layout

\end_inset

 daemon, which is a feature-rich implementation of the Internet Key Exchange
 protocol version 2 (IKEv2
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv2
\end_layout

\end_inset

) as specified in 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
 The software is implemented using the C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

 programming language with an object oriented (OO) approach.
 This allows to emulate modern programming paradigms while still using a
 standard C compiler and tool set
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://wiki.strongswan.org/projects/strongswan/wiki/ObjectOrientedC
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
By using a flexible plugin architecture, the strongSwan project can be easily
 extended with new features.
 The task of adding new features can be reduced to writing a new plugin.
 This architecture has proven to be very helpful in the course of this project,
 as very few changes were required in the upstream core strongSwan code
 to implement the Trusted Key Manager (TKM
\begin_inset Index idx
status open

\begin_layout Plain Layout
TKM
\end_layout

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Trusted-Key-Manager"

\end_inset

) architecture.
\end_layout

\begin_layout Subsection
Ada
\begin_inset CommandInset label
LatexCommand label
name "sub:Ada"

\end_inset


\end_layout

\begin_layout Standard
Ada
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada
\end_layout

\end_inset

 is a structured, strongly typed programming language.
 The language has initially been designed by Jean Ichbiah from Honeywell
 Bull in the 1970s.
 Ada has a very similar structure to Pascal
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pascal
\end_layout

\end_inset

 and is often used for systems with a special demand for security and integrity.
\end_layout

\begin_layout Standard
The development of Ada was initiated by the US Department of Defense (DoD
\begin_inset Index idx
status open

\begin_layout Plain Layout
DoD
\end_layout

\end_inset

) in order to consolidate and supersede the hundreds of programming languages
 used in their countless projects.
 The new language should comply with all identified DoD requirements (dubbed
 
\begin_inset Quotes eld
\end_inset

Steelman Language Requirements
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Steelman78"

\end_inset

), which focused strongly on security and safety.
 
\end_layout

\begin_layout Standard
Ada was the first standardized high-level programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "Ada83"

\end_inset

.
 The current version is Ada 2012
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada 2012
\end_layout

\end_inset

 which supports all modern programming pa\SpecialChar \-
ra\SpecialChar \-
digms.
 It has just recently been released
\begin_inset Foot
status open

\begin_layout Plain Layout
The announcement was made on December 18, 2012: http://www.ada-europe.org/press/20
121218-Ada2012.pdf
\end_layout

\end_inset

 as an ISO standard 
\begin_inset CommandInset citation
LatexCommand cite
key "Ada2012"

\end_inset

.
 Ada 2012 adds the possibility to use contract-based programming methods
 (
\begin_inset Quotes eld
\end_inset

Design by contract
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Meyer:1992:ADC:618974.619797"

\end_inset

).
\end_layout

\begin_layout Standard
Ada compilers, before used in practice, have to pass a standardized test
 suite which guarantees the compliance of the compiler with the Ada standard.
 Since Ada provides many features which aid in the development of safety
 and security critical applications, it is nowadays mostly used in areas
 where such aspects are important.
 The primary industries making use of Ada are namely avionics, railway systems,
 banking, military and space technology.
\end_layout

\begin_layout Standard
The language is named after Lady Ada Lovelace
\begin_inset Foot
status open

\begin_layout Plain Layout
Ada Lovelace - http://en.wikipedia.org/wiki/Ada_Lovelace
\end_layout

\end_inset

, the daughter of Lord Byron, who is considered to be the first computer
 programmer.
\end_layout

\begin_layout Standard
GNAT, a free-software compiler for the Ada programming language, is available
 as part of the GNU Compiler Collection.
\end_layout

\begin_layout Subsection
Trusted Key Manager
\begin_inset CommandInset label
LatexCommand label
name "sub:Trusted-Key-Manager"

\end_inset


\end_layout

\begin_layout Standard
The Trusted Key Manager
\begin_inset Index idx
status open

\begin_layout Plain Layout
Trusted Key Manager
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
TKM
\end_layout

\end_inset

 is a minimal TCB developed during this project which implements the identified
 security-critical functions of the IKEv2 protocol using the Ada programming
 language.
 The TKM is explained in detail in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TKM"

\end_inset

.
\end_layout

\begin_layout Standard
The TKM uses the tkm-rpc
\begin_inset Index idx
status open

\begin_layout Plain Layout
tkm-rpc
\end_layout

\end_inset

 library to communicate with the modified strongSwan charon daemon in the
 untrusted part.
 This library is also written in Ada and explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

.
\end_layout

\begin_layout Section
Related work
\begin_inset CommandInset label
LatexCommand label
name "sub:Related-work"

\end_inset


\end_layout

\begin_layout Standard
The concept of decomposing larger systems into smaller, trusted parts dates
 back to John Rushby in 1981 
\begin_inset CommandInset citation
LatexCommand cite
key "Rushby:1981:DVS:1067627.806586"

\end_inset

.
 The most prominent implementations of the concept exist in the form of
 microkernels
\begin_inset Index idx
status open

\begin_layout Plain Layout
Microkernel
\end_layout

\end_inset

 (µ-kernels), which provide the foundation to separate functionality into
 smaller, separated parts by providing compartments for subjects running
 in userspace.
 Examples of such systems are Fiasco
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://os.inf.tu-dresden.de/fiasco/
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Fiasco
\end_layout

\end_inset

, L4Ka::Pistachio
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.l4ka.org/65.php
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
L4Ka::Pistachio
\end_layout

\end_inset

 and Coyotos
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.coyotos.org/
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Coyotos
\end_layout

\end_inset

.
 Type-1 (bare-metal) hypervisors
\begin_inset Index idx
status open

\begin_layout Plain Layout
Hypervisor
\end_layout

\end_inset

 like Xen are intentionally excluded from the list because Xen requires
 a complete Linux kernel (dom0) with direct access to hardware to operate.
 The fact that the dom0 kernel must be accounted as part of the trusted
 system makes it unsuitable for in-depth review and therefore unusable as
 part of a TCB.
\end_layout

\begin_layout Standard
Even though the concept proposed by Rushby offers many advantages related
 to security and integrity, it has not been widely realized.
 Common operating systems like Windows
\begin_inset Index idx
status open

\begin_layout Plain Layout
Windows
\end_layout

\end_inset

, Linux
\begin_inset Index idx
status open

\begin_layout Plain Layout
Linux
\end_layout

\end_inset

 and *BSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
BSD
\end_layout

\end_inset

 variants use a monolithic
\begin_inset Index idx
status open

\begin_layout Plain Layout
monolithic
\end_layout

\end_inset

 kernel, which itself must be trusted as a whole, even though the compromise
 of a device driver can corrupt the complete system.
\end_layout

\begin_layout Standard
One reason seems to be the tremendous effort needed to adapt existing software
 to a separation concept.
 In order to move critical parts into a TCB, the existing code must be studied
 and sensitive parts re-implemented using the corresponding APIs and methods
 of the underlying separation platform.
 Of course, the complete system could be rewritten for the dedicated secure
 environment, but often this is not possible and especially not desired
 for code deemed as untrusted.
 The dedicated goal is to only re-implement sensitive parts while leaving
 the untrusted part mostly untouched.
\end_layout

\begin_layout Standard
A different reason for the disregard of Rushby's ideas by most software
 vendors is the focus on extending the functionality of existing products
 by adding new features.
 This phenomenon is known as 
\emph on
feature creep
\emph default
.
\end_layout

\begin_layout Standard
Research has been done in the formal analysis of the IKEv1
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv1
\end_layout

\end_inset

 and IKEv2
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv2
\end_layout

\end_inset

 protocols 
\begin_inset CommandInset citation
LatexCommand cite
key "Cremers:2011:KEI:2041225.2041249,DBLP:conf/sp/Meadows99"

\end_inset

, pointing out weaknesses in both standards.
 The separation of the sensitive part from the bulk of the IKE protocol
 seems to be a valuable effort to minimize the working surface of attacks.
 Nevertheless, the IKEv2 separation protocol described in this paper must
 still undergo the same rigorous verification as the original protocols
 to formally show the delivered security improvements compared to its monolithic
 ancestor.
\end_layout

\begin_layout Section
Threat model
\begin_inset CommandInset label
LatexCommand label
name "sub:Threat-model"

\end_inset


\end_layout

\begin_layout Standard
An example system separated in a trusted and untrusted component is shown
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Trusted-Computing-Base"

\end_inset

 on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "fig:Trusted-Computing-Base"

\end_inset

.
 This section describes the threat model used during the development of
 this project.
\end_layout

\begin_layout Standard
It is assumed that the strongSwan charon IKEv2 daemon, which is considered
 an untrusted software component in the envisioned architecture, is under
 total control of the attacker
\begin_inset Index idx
status open

\begin_layout Plain Layout
Attacker
\end_layout

\end_inset

.
 This means the attacker has complete access to all data available to the
 IKEv2 daemon and is able to execute arbitrary code with the privileges
 of charon
\begin_inset Index idx
status open

\begin_layout Plain Layout
charon
\end_layout

\end_inset

.
 As a result of this assumption, charon is not allowed to have access to
 any sensitive data.
 Also, intermediate computation results which are needed to create sensitive
 values must be protected from access by untrusted components.
 The following list summarizes the capabilities of an attacker:
\end_layout

\begin_layout Enumerate
The attacker is able to analyze all network traffic of the system.
 
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:thread-model-2"

\end_inset

The attacker is able to compromise the untrusted IKE daemon and read all
 its memory.
\end_layout

\begin_layout Enumerate
The attacker can execute arbitrary code in the untrusted component with
 the privileges of the IKE daemon.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:thread-model-4"

\end_inset

As a result of point 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:thread-model-2"

\end_inset

, the attacker is in possession of all data known to the IKE daemon.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:thread-model-5"

\end_inset

The attacker can send arbitrary commands to the TCB (deduced from point
 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:thread-model-4"

\end_inset

).
\end_layout

\begin_layout Section
TCB security properties
\begin_inset CommandInset label
LatexCommand label
name "sec:TCB-security-properties"

\end_inset


\end_layout

\begin_layout Standard
Even if an attacker manages to take complete control of the untrusted part
 of the system as described by the threat model in the previous section
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

, the TCB must still guarantee the following properties:
\end_layout

\begin_layout Enumerate
The attacker has no access to the IPsec SA keying material.
\end_layout

\begin_layout Enumerate
The attacker has no means to draw conclusions about the IPsec SA keying
 material from sensitive intermediate values.
\end_layout

\begin_layout Enumerate
The attacker is therefore unable to decrypt recorded ESP
\begin_inset Index idx
status open

\begin_layout Plain Layout
ESP
\end_layout

\end_inset

 traffic of a communication session.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:tcb-props-4"

\end_inset

The attacker is not able to forge authentication exchanges with unauthorized
 peers.
 
\end_layout

\begin_layout Enumerate
As a conclusion from point
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:tcb-props-4"

\end_inset

, the attacker is not able to derive child keying material for an unauthorized
 connection.
\end_layout

\begin_layout Section
Assumptions
\begin_inset CommandInset label
LatexCommand label
name "sec:Assumptions"

\end_inset


\end_layout

\begin_layout Itemize
The TCB security properties stated in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TCB-security-properties"

\end_inset

 can only be guaranteed if the separation of the components itself withstands
 an attack, i.e.
 an attacker is unable to subvert the TCB in any way.
 In this project it is assumed that the separation mechanism in use is designed
 as such that this requirement holds.
 Possible solutions to this problem are elaborated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Platform-integration"

\end_inset

.
\end_layout

\begin_layout Itemize
The untrusted IKE daemon and the trusted component can only exchange messages
 via the well defined interface and are otherwise completely isolated from
 each other.
 In a real system this is very difficult to achieve since there are many
 possibilities for side channels, which have been demonstrated to work,
 see for example 
\begin_inset CommandInset citation
LatexCommand cite
key "Aciicmez:2007:PSB:1229285.1266999,cryptoeprint:2010:594,Zhang:2012:CSC:2382196.2382230"

\end_inset

.
\end_layout

\begin_layout Itemize
Denial-of-service attacks (DoS
\begin_inset Index idx
status open

\begin_layout Plain Layout
DoS
\end_layout

\end_inset

) are not considered security critical because an attacker taking over the
 untrusted part and making all communication with the TCB impossible is
 still unable to access sensitive material.
\end_layout

\begin_layout Chapter
Analysis of strongSwan
\begin_inset Argument
status open

\begin_layout Plain Layout
Analysis
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This chapter describes the current operation and the inner workings of the
 strongSwan charon IKEv2 daemon.
 A deep understanding of these mechanisms is a prerequisite for the extraction
 of sensitive functionality from the daemon into a minimal trusted part
 to achieve the requirements formalized in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

 later.
\end_layout

\begin_layout Standard
The following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKEv2-protocol-analysis"

\end_inset

 will therefore provide an introduction into the IKEv2 message exchanges
 in general to give the reader a basic understanding of the protocol.
 The main aim of the section is to identify critical payloads contained
 in the message exchanges.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Code-analysis"

\end_inset

 will then analyze the code flow inside the strongSwan charon daemon implementin
g the actual IKEv2 exchanges and payload handling.
\end_layout

\begin_layout Section
IKEv2 protocol analysis
\begin_inset CommandInset label
LatexCommand label
name "sub:IKEv2-protocol-analysis"

\end_inset


\end_layout

\begin_layout Standard
The following section provides a detailed analysis of the IKEv2 message
 exchanges (as specified by 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

), focusing on the security relevance of the transmitted data.
 All communication using IKE consists of a request / response pair.
 
\end_layout

\begin_layout Standard
In the following descriptions, the message payloads are indicated by names
 as listed in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:IKEv2-payloads"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Payload
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AUTH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Authentication
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CERT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Certificate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CERTREQ
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Certificate Request
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Configuration
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EAP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Extensible Authentication
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IKE header (not a payload)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IDi 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identification - Initiator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IDr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identification - Responder
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
KE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Exchange
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ni, Nr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nonce
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notify
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Security Association
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted and Authenticated
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TSi
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Traffic Selector - Initiator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TSr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Traffic Selector - Responder
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vendor ID
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKEv2 payloads
\begin_inset CommandInset label
LatexCommand label
name "tab:IKEv2-payloads"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every IKE message contains a message 
\emph on
ID
\emph default
 as part of its fixed header (
\emph on
HDR
\emph default
).
 This message 
\emph on
ID
\emph default
 is used to match up requests and responses, and to identify retransmissions
 of messages 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
 The fixed header does not contain security-relevant information and is
 therefore omitted from the discussion.
 
\end_layout

\begin_layout Standard
A value declared as 'critical' or 'sensitive
\begin_inset Index idx
status open

\begin_layout Plain Layout
sensitive values
\end_layout

\end_inset

' in the following sections must not be accessible by the untrusted part,
 i.e.
 it must not be present in memory or storage accessible from within the
 untrusted part.
 Other payloads (such as 
\emph on
AUTH
\emph default
) are calculated from critical values inside the TCB but then handed to
 the untrusted part for further processing and transmission.
\end_layout

\begin_layout Subsection
Notation
\end_layout

\begin_layout Standard
The exchanges are presented as a communication between peers 
\emph on
A
\emph default
 and 
\emph on
B
\emph default
.
 The arrows represent the direction from the source to the destination of
 the message.
 The transmitted values are listed on the right-hand side.
 Optional parts of the exchange are enclosed in square brackets.
 The notation SK { ...
 } indicates that the payloads listed inside the curly brackets are encrypted
 and integrity protected.
\end_layout

\begin_layout Subsection
IKE_SA_INIT
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-IKE_SA_INIT"

\end_inset


\end_layout

\begin_layout Standard
The first pair of messages (IKE_SA_INIT
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE_SA_INIT
\end_layout

\end_inset

) negotiate cryptographic algorithms, exchange nonces, and do a Diffie-Hellman
\begin_inset Index idx
status open

\begin_layout Plain Layout
Diffie-Hellman
\end_layout

\end_inset

 exchange 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{1}{A}{B}{HDR, SAi1, KEi, Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{2}{B}{A}{HDR, SAr1, KEr, Nr, [CERTREQ]}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SAi1
\emph default
 payload states the cryptographic algorithms the initiator supports for
 an IKE SA.
 This payload is not considered critical because the TKM will only support
 a subset of cryptographic algorithms which are strong enough and believed
 to be secure.
 A deviation from allowed proposals would only result in a non-functional
 configuration since the TKM enforces the allowed algorithms of a specific
 connection.
\end_layout

\begin_layout Standard
Child keys are derived from the shared secret
\begin_inset Index idx
status open

\begin_layout Plain Layout
shared secret
\end_layout

\end_inset

 value resulting from the Diffie-Hellman exchange after the IKE_SA_INIT
 messages.
 Therefore the TKM must implement the DH protocol in the TCB and compute
 the public 
\emph on
KE
\emph default
 payload on behalf of the untrusted part.
 The peers exchange the 
\emph on
KE
\emph default
 payloads in the initial IKE_SA_INIT messages as shown above.
\end_layout

\begin_layout Standard
The nonces
\begin_inset Index idx
status open

\begin_layout Plain Layout
Nonce
\end_layout

\end_inset

 
\emph on
Ni
\emph default
 and
\emph on
 Nr
\emph default
 are used as input to cryptographic functions and provide freshness to the
 key derivation technique used to obtain keys for the child SA.
 Therefore the nonce 
\emph on
Ni
\emph default
 used in the initial exchange must be randomly chosen, must be at least
 128 bits in size, and must be at least half the key size of the negotiated
 pseudorandom function (PRF).
 These constraints must be enforced by the TKM.
 Values created by the responder can not be controlled by the TKM so these
 values are taken as is.
 This is obviously true for all IKE message exchanges.
\end_layout

\begin_layout Standard
The responder may also send a list of its trust anchors in the CERTREQ payload.
 This has no relevance for the TCB because it maintains a separate list
 of trusted root CAs.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
KEi, Ni
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical IKE_SA_INIT payloads
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
IKE_AUTH
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-IKE_AUTH"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE_AUTH
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After the completion of the IKE_SA_INIT exchange, each party is able to
 compute SKEYSEED
\begin_inset Index idx
status open

\begin_layout Plain Layout
SKEYSEED
\end_layout

\end_inset

, from which all keys are derived for that SA.
 The messages that follow are encrypted and integrity protected in their
 entirety, with the exception of the message headers.
 The keys used for the encryption and integrity protection are derived from
 SKEYSEED and are known as SK_e (encryption) and SK_a (authentication, a.k.a.
 integrity protection).
 Separate SK_e and SK_a keys are computed for each direction.
 The payloads marked with SK { ...
 } are protected using the direction's SK_e and SK_a (
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 1.2).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{3}{A}{B}{HDR, SK 
\backslash
{IDi, [CERT,] [CERTREQ,] [IDr,] AUTH, SAi2, TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{4}{B}{A}{HDR, SK 
\backslash
{IDr, [CERT,] AUTH, SAr2, TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As stated in the previous section, the DH protocol must be implemented inside
 the TCB.
 As a result, the SK_e and SK_a keys must be provided to the untrusted part.
 These keys are not considered critical because an attacker taking over
 the untrusted part is already able to extract all information protected
 by these keys (see the threat model section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

).
\end_layout

\begin_layout Standard
The initiator asserts its identity with the 
\emph on
IDi
\emph default
 payload.
 This value is not sensitive itself but the TKM must enforce correct identities
 during the authentication step to assure that only trusted peers are allowed.
\end_layout

\begin_layout Standard
The authentication payload 
\emph on
AUTH
\emph default
 contains the signature allowing the peers to verify each other's authenticity.
 The value inside this payload must be created by the TKM since it is signed
 by a private key only known to the TCB.
 The signature is handed to the untrusted part because the TKM assures that
 the PRF used to generate it (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-generation"

\end_inset

) is strong enough.
\end_layout

\begin_layout Standard
Analogous to the IKE_SA_INIT exchange, the 
\emph on
SAi2
\emph default
/
\emph on
SAr2
\emph default
 payloads are not considered critical and can be configured directly in
 the untrusted part.
 The same is true for the 
\emph on
TS
\emph default
 payloads.
 The TKM enforces the correct algorithms and peer addresses before deriving
 child keys.
\end_layout

\begin_layout Standard
The initiator might also send its user certificate in a 
\emph on
CERT
\emph default
 payload and a list of its trust anchors in 
\emph on
CERTREQ
\emph default
 payload(s).
 If any 
\emph on
CERT
\emph default
 payloads are included, the first certificate provided must contain the
 public key used to verify the AUTH field 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
 These payload are uncritical since invalid certificates would result in
 an authentication failure.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK, AUTH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Enforced by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID, CERT, CERTREQ, SAi, TS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical IKE_AUTH payloads
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CREATE_CHILD_SA
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-CREATE_CHILD_SA"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
CREATE_CHILD_SA
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SK
\emph default
 used to protect the CREATE_CHILD_SA exchange is the same as described in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_AUTH"

\end_inset

.
 The 
\emph on
SK
\emph default
 is created by the TKM but handed to the untrusted part to protect the IKE
 exchanges from outside attackers.
 Attackers which have taken over the untrusted part are already able to
 extract all information protected by these keys.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{5}{A}{B}{HDR, SK 
\backslash
{SA, Ni, [KEi], TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{6}{B}{A}{HDR, SK 
\backslash
{SA, Nr, [KEr], TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SA
\emph default
 payloads used to negotiate the algorithms of the child SA are again not
 considered critical and can be configured directly in the untrusted part.
 The
\emph on
 TS
\emph default
 payloads specify the IPsec SA endpoints and are also uncritical given that
 the TCB maintains and enforces its own policy before installing a new child
 SA.
\end_layout

\begin_layout Standard
Depending on the perfect forward secrecy (PFS)
\begin_inset Index idx
status open

\begin_layout Plain Layout
PFS
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
PFS ensures that a session key derived from a long-term key will not be
 compromised if the long-term key is disclosed in the future.
\end_layout

\end_inset

 configuration of the connection, the CREATE_CHILD_SA request may optionally
 contain a 
\emph on
KE
\emph default
 payload for an additional Diffie-Hellman exchange to enable stronger guarantees
 of forward secrecy for the child SA.
 The keying material for the child SA is a function of the SK_d key created
 along the SK_e and SK_a keys during the establishment of the IKE SA, the
 nonces exchanged during the CREATE_CHILD_SA exchange, and this public Diffie-He
llman value, if present (
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 1.3).
\end_layout

\begin_layout Standard
Payloads created by the responder can not be controlled but the algorithms
 selected from 
\emph on
SA
\emph default
 and the traffic selectors selected from 
\emph on
TS
\emph default
 must be checked by the TKM.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK, Ni, [KEi]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Enforced by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAi, TS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical CREATE_CHILD_SA payloads
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Code analysis
\begin_inset CommandInset label
LatexCommand label
name "sub:Code-analysis"

\end_inset


\end_layout

\begin_layout Standard
This section illustrates the charon source code, which processes the IKEv2
 message exchanges and the security relevant data as described by the previous
 section.
 Graphs are used to illustrate the code flow of a specific functionality
 inside the strongSwan architecture.
\end_layout

\begin_layout Subsection
IKE_SA_INIT
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-IKE_SA_INIT"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

 shows the code involved in the IKE SA establishment.
 The exchange involves an initiator and a responder which are displayed
 in separate blocks in the graph.
 During IKE_SA_INIT, two messages are exchanged which are indicated between
 the initiator and responder code blocks.
 Round labels, e.g.
 the label 
\emph on
(CD
\emph default
), are references to subgraphs which illustrate a continuative process in
 detail.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-sa-init.svg
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
IKE SA establishment
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-establishment"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
IKE exchanges are implemented as task entities in charon and are situated
 in the 
\family typewriter
libcharon/sa/ikev2/tasks
\family default
 directory.
 The IKE SA establishment process is implemented in the 
\family typewriter
ike_init.c
\family default
 file in this directory.
 Each task represents a finite-state machine (FSM)
\begin_inset Index idx
status open

\begin_layout Plain Layout
FSM
\end_layout

\end_inset

 which changes state depending on internal or external events like sent
 or received messages.
 The 
\family typewriter
NEED_MORE
\family default
 state displayed in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

 indicates that the state machine responsible to establish an IKE SA is
 expecting more data to proceed.
 This state is used to separate the sending path from the receiving path
 inside the 
\family typewriter
build_i/process_i
\family default
 and 
\family typewriter
process_r/build_r
\family default
 blocks.
\end_layout

\begin_layout Standard
The tasks access required functionality by requesting plugins from different
 factories.
 Examples of such plugins are RNGs
\begin_inset Foot
status open

\begin_layout Plain Layout
Random number generator
\end_layout

\end_inset

 or plugins which perform a DH exchange.
\end_layout

\begin_layout Standard
The initiator creates the payloads of the initial message in the 
\family typewriter
build_i
\family default
 code block during which the initial steps of the Diffie-Hellman protocol
 are performed.
 The task calls the 
\family typewriter
create_dh
\family default
 function of the 
\family typewriter
keymat
\family default
 object (
\emph on
CD
\emph default
) which internally requests a new DH plugin instance from the crypto factory
 and returns this instance to the calling task.
 A 
\family typewriter
keymat
\family default
 object stores the complete IKE SA key material and is used to derive IKE
 and child SA keys.
 A 
\family typewriter
keymat
\family default
 object is always associated with an IKE SA inside the IKE SA manager.
\end_layout

\begin_layout Standard
After constructing all payloads, the initiator sends the IKE_SA_INIT message
 to the peer and waits for a response (error handling if the peer is not
 answering is omitted from this discussion).
 The responder processes the request in the 
\family typewriter
process_r
\family default
 code block and performs the DH protocol on his side.
 Since it already received the DH public value from the initiator, it is
 able to complete the DH exchange without waiting for further data.
 It then uses the SKEYSEED from the DH exchange to derive the IKE SA keying
 material (
\emph on
DK
\emph default
) and creates an IKE_SA_INIT response containing its DH public value to
 allow the initiator to complete the initial exchange on his side.
\end_layout

\begin_layout Standard
The initiator then also derives IKE SA keying material used to protect the
 following IKE_AUTH or CHILD_CREATE_SA exchanges (
\emph on
DK
\emph default
).
 This completes phase 1.
\end_layout

\begin_layout Subsection
IKE_AUTH
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-IKE_AUTH"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA authentication
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-authentication"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-authentication"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-Certificate-trustchain"

\end_inset

 show the code involved during the authentication of an IKE SA.
 As can be deduced from the number of graphs needed to illustrate the process,
 this exchange is more complex than the IKE_SA_INIT exchange explained in
 the previous section.
 
\end_layout

\begin_layout Standard
The initiator begins the exchange by building its own AUTH payload used
 to prove its identity to the responder.
 This is done by creating a so called 'authenticator' plugin (see the
\emph on
 CB
\emph default
 label).
 After that, the authenticator's 
\family typewriter
build
\family default
 function illustrated by the
\emph on
 BA
\emph default
-subgraph shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

 is called.
 To construct the signed authentication octets the authenticator plugin
 requests a private key (
\emph on
GP
\emph default
) matching a specific certificate configured for this connection.
 The returned private key is used to sign the AUTH octets requested from
 the keymat object (
\emph on
A8
\emph default
) of the associated IKE SA.
 The private key is implemented as a plugin.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth-ba-pa.svg
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE public key authenticators
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-public-key-auth"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The initiator then sends a message containing the constructed payloads to
 the responder and waits for a response message.
\end_layout

\begin_layout Standard
The responder creates a 'verifier' plugin to check the AUTH payload extracted
 from the initiator's message.
 The creation of a verifier plugin is depicted in the 
\emph on
CV
\emph default
 graph.
 The responder processes the authentication octets of the initiator by calling
 the verifier's
\family typewriter
 process
\family default
 function (
\emph on
PA
\emph default
).
 The authenticator requests the AUTH octets from the IKE SA keymat (
\emph on
A8
\emph default
) and retrieves the associated public key needed to verify the signature
 from the credential manager.
 To use the public key, its chain of trust must be verified first.
 
\end_layout

\begin_layout Standard
The trust chain verification process is shown in (
\emph on
PU
\emph default
) of figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-Certificate-trustchain"

\end_inset

.
 The credential manager verifies the signature chain of all involved certificate
s starting from the peer's public key until it reaches a trusted CA certificate.
 The details of how such signature chains are verified is explained in the
 implementation section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth-pu.svg
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
IKE Certificate trust chain verification
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-Certificate-trustchain"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create the response message, the responder performs the same steps as
 the initiator to create its AUTH payload (
\emph on
CB
\emph default
, 
\emph on
BA
\emph default
).
 The initiator verifies the AUTH payload of the responder using the same
 steps as described for the responder (
\emph on
CV
\emph default
, 
\emph on
PA
\emph default
).
\end_layout

\begin_layout Standard
After the IKE SA is established, both peers normally install the first child
 SA.
 This step is explained in detail in the next section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-CHILD_CREATE_SA"

\end_inset

.
\end_layout

\begin_layout Subsection
CHILD_CREATE_SA
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-CHILD_CREATE_SA"

\end_inset


\end_layout

\begin_layout Standard
The CHILD_CREATE_SA exchange is implemented as a task in the 
\family typewriter
child_create.c
\family default
 file.
 The initiator starts by collecting the traffic selectors and proposals
 from the configuration (not visible in the graph) and allocates a SPI by
 calling the 
\family typewriter
allocate_spi
\family default
 function.
 This function dispatches into the registered kernel plugin to acquire a
 free SPI from the OS kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel
\end_layout

\end_inset

.
 If the connection has PFS enabled, the initiator starts a new DH exchange
 and builds all required payloads.
 After sending the message, the task changes its state to NEED_MORE and
 waits for an answer.
\end_layout

\begin_layout Standard
The responder processes the received CHILD_CREATE_SA message and extracts
 the contained payloads.
 It conducts the DH exchange and then directly installs the derived child
 SA keying material in the kernel.
 The complete process of deriving keys for the new child SA is depicted
 in 
\emph on
(SI
\emph default
).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/child-create-sa.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Child SA establishment
\begin_inset CommandInset label
LatexCommand label
name "fig:Child-SA-establishment"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
First the child SA data structure associated with the task is set into the
 CHILD_INSTALLING state.
 The 
\family typewriter
derive_child_keys
\family default
 function of the keymat is called to derive keying material for the child
 SA (
\emph on
DC
\emph default
).
 The kernel plugin's
\family typewriter
 add_policy
\family default
 (
\emph on
IP
\emph default
) and
\family typewriter
 add_sa
\family default
 (
\emph on
IS
\emph default
) functions are used to install the new policy and state into the kernel's
 SPD and SAD databases.
 If no errors occurred, the state of the child SA is set to CHILD_INSTALLED
 and it is attached to the associated IKE SA object.
\end_layout

\begin_layout Standard
The responder then builds the payloads of the response message and sends
 the message back to the initiator.
 The initiator processes the message and calls the
\family typewriter
 select_and_install
\family default
 function to derive child keying material after extracting the payloads.
 It then installs the new policy and state in the kernel.
\end_layout

\begin_layout Subsection
Source of randomness
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Source-of-randomness"

\end_inset


\end_layout

\begin_layout Standard
Randomness is provided by requesting a random number generator plugin instance
 from the crypto factory of libstrongswan.
 This process is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Nonce-generation"

\end_inset

, by using the nonce creation process as an example.
 Depending on the requested quality (
\family typewriter
RNG_WEAK
\family default
 or
\family typewriter
 RNG_STRONG
\family default
), a suitable RNG plugin providing the needed quality is created and returned
 to the caller by the crypto factory.
 The
\family typewriter
 get_bytes
\family default
 or
\family typewriter
 allocate_bytes
\family default
 functions can be used to retrieve random chunks from the RNG plugin.
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/nonce-generation.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nonce generation
\begin_inset CommandInset label
LatexCommand label
name "fig:Nonce-generation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Payload encryption
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Payload-encryption"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-payload-enc"

\end_inset

 schematically shows the code involved in the encryption of payloads in
 the IKE message exchanges.
 If a new connection is initiated by calling the initiate function of the
 IKE SA, all tasks (see previous sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-IKE_SA_INIT"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-CHILD_CREATE_SA"

\end_inset

) required to establish an IKE SA and the associated child SA are created
 and run by the task manager.
 The tasks then call back the IKE SA 
\family typewriter
generate_message
\family default
 function to create the appropriate message sent to the peer in their exchange.
\end_layout

\begin_layout Standard
The 
\family typewriter
generate_message
\family default
 function calls the 
\family typewriter
generate
\family default
 function of the message which in turn checks if the message is required
 to be encrypted.
 If encryption is enabled, an encrypted payload is created by accessing
 the key material of the IKE SA's keymat object.
 The actual encryption is done by a crypter plugin which in turn uses a
 RNG plugin outlined in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-Source-of-randomness"

\end_inset

 to retrieve random bytes needed for the IV
\begin_inset Foot
status open

\begin_layout Plain Layout
Initialization vector
\end_layout

\end_inset

.
 The yellow 
\begin_inset Quotes eld
\end_inset

aead
\begin_inset Quotes erd
\end_inset

 blocks in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-payload-enc"

\end_inset

 depict cryptographic algorithms using the Authenticated Encryption with
 Associated Data (AEAD) mechanism to guarantee confidentiality and integrity
 of the IKE message payloads (see RFC 5116 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5116"

\end_inset

 for details on AEAD).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/payload-encryption.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA payload encryption
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-payload-enc"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Payload decryption
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Payload-decryption"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-payload-dec"

\end_inset

 shows the process of payload decryption which reverses the process of payload
 encryption explained in the previous chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-Payload-encryption"

\end_inset

.
 An incoming message is processed by calling the task managers 
\family typewriter
process_message
\family default
 function.
 This function parses the message by calling the message 
\family typewriter
parse_body
\family default
 function with the keymat object from the IKE SA as function argument.
\end_layout

\begin_layout Standard
The 
\family typewriter
parse_body
\family default
 function calls 
\family typewriter
decrypt_payloads,
\family default
 which determines if the payloads are encrypted or not.
 If they are, it decrypts them by using an encryption payload object which
 uses the keymat's keying material to decrypt and verify the payloads.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/payload-decryption.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA payload decryption
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-payload-dec"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Design
\begin_inset CommandInset label
LatexCommand label
name "chap:Design"

\end_inset


\end_layout

\begin_layout Standard
The main concept is to separate the security relevant functionality from
 all other IKEv2 services and split the IKEv2 key management daemon into
 two components: a trusted and an untrusted part.
 The trusted part performs the critical operations, stores all relevant
 keying material and exposes the necessary services to the untrusted component
 via a well defined and minimal interface.
 The split of the components must guarantee the fullfilment of the security
 requirements defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Section
Split of IKE
\end_layout

\begin_layout Standard
The charon software design is based on a plugin architecture.
 Almost every functional part of the daemon is implemented as a plugin.
 This provides the flexibility to extend or exchange specific parts of the
 system by providing a suitable plugin implementation.
 As outlined in the code analysis section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Code-analysis"

\end_inset

, most security critical operations and values are already encapsulated
 in plugins.
 The changes needed to allow complete separation of the critical parts from
 the charon daemon are limited.
 Therefore, the architecture depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Split-of-IKE"

\end_inset

 is proposed.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/design-overview.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Split of IKE into trusted and untrusted parts
\begin_inset CommandInset label
LatexCommand label
name "fig:Split-of-IKE"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By implementing custom plugins which act as proxy between the trusted and
 untrusted parts of the component, it is possible to move the key material
 and related operations into the TCB.
 This ensures that the untrusted part has no direct access to security relevant
 data.
 The critical parts extracted from charon are implemented by the Trusted
 Key Manager which is part of the TCB.
 
\end_layout

\begin_layout Subsection
Contexts and identifiers
\begin_inset CommandInset label
LatexCommand label
name "sub:Contexts-and-identifiers"

\end_inset


\end_layout

\begin_layout Standard
By using a well-defined interface, the internal functionality of the TCB’s
 key manager is completely hidden from the charon plugins.
 The plugins reference the data (and their associated state) needed for
 processing via context identifiers (IDs).
 They have no direct access to the objects referenced by the identifiers
 but can instruct the key manager to perform certain, allowed operations
 with the specified context(s).
 Only uncritical results of operations are returned to the caller plugin
 (e.g.
 the public value of a DH exchange).
 This architecture allows the trusted part to be minimal while the bulk
 of the charon code can be used as is, in the untrusted part to handle the
 vast majority of IKEv2 processing.
\end_layout

\begin_layout Standard
To simplify the implementation of the TCB, the management of context IDs
 is done in the untrusted part since it is not security-critical.
 The trusted part only supports a limited number of contexts.
 These limits can be inquired from the TCB by the untrusted components by
 using a dedicated exchange.
 Usage of context IDs outside the supported numeric range is refused by
 the TCB.
\end_layout

\begin_layout Section
Requirements
\begin_inset CommandInset label
LatexCommand label
name "sec:Requirements"

\end_inset


\end_layout

\begin_layout Standard
This section outlines the identified requirements of the separated system
 in detail.
 These requirements specify the properties the TCB must enforce even in
 the event of a complete compromise of the untrusted part of the system.
 The properties are derived from the threat model described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

 and the more abstract description of TCB security properties in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TCB-security-properties"

\end_inset

.
\end_layout

\begin_layout Subsection
TCB robustness
\begin_inset CommandInset label
LatexCommand label
name "sub:req-TCB-robustness"

\end_inset


\end_layout

\begin_layout Standard
The systems comprising the TCB must be robust and reliable.
 The TCB must be as simple as possible and at the same time small in size.
\end_layout

\begin_layout Subsection
Separation
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Separation"

\end_inset


\end_layout

\begin_layout Standard
The IKEv2 component must be separated into a trusted and untrusted part
 in such a way that the size and complexity of the TCB are minimal.
\end_layout

\begin_layout Subsection
Communication
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Communication"

\end_inset


\end_layout

\begin_layout Standard
The communication protocol between the trusted and untrusted parts must
 be simple, robust and well-defined to allow a verifiable implementation.
 
\end_layout

\begin_layout Subsection
Separation of key material
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Separation-of-key"

\end_inset


\end_layout

\begin_layout Standard
The untrusted part of the IKEv2 component must not have access to generated
 key material that is used for authentication of peers, encryption and integrity
 protection of user data (i.e.
 child SA keys).
 This also includes critical intermediate values, which may result from
 the key agreement, generation and derivation process.
 
\end_layout

\begin_layout Standard
Excluded from the critical material are keys used to protect the IKE SA.
 As defined by the threat model in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

, an attacker might be able to compromise the untrusted IKE daemon and read
 all its memory (point 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:thread-model-2"

\end_inset

).
 Defeating IKE message decryption by protecting the IKE SA keys is unnecessary
 since the attacker is already in possession of all data these keys are
 intended to protect.
\end_layout

\begin_layout Standard
This implies that the procedure used to create the IKE SA keys must be cryptogra
phically secure and exhibit the properties of a one-way function to prevent
 the deduction of the underlying shared secret from the keying material.
\end_layout

\begin_layout Subsection
Cryptographic operations
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Cryptographic-operations"

\end_inset


\end_layout

\begin_layout Standard
All relevant cryptographic operations must be performed by the trusted computing
 base (TCB) to assure the correctness of the resulting values.
 Since cryptographic operations require keying material, this is also a
 consequence of the requirement specified in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation-of-key"

\end_inset

.
\end_layout

\begin_layout Standard
Data and intermediate values used for cryptographic operations must follow
 a strict life-cycle and it must be guaranteed, that such values are not
 used more than once.
 Additionally generation of pathological cryptographic keys (e.g.
 0) must be detected and their usage prevented.
\end_layout

\begin_layout Subsection
Authentication
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Authentication"

\end_inset


\end_layout

\begin_layout Standard
The IKEv2 component must only allow IPsec SAs to be established for peers
 that have successfully been authenticated.
 The authentication must be performed by the TCB to assure the correctness
 of the process and foil man-in-the-middle (MitM)
\begin_inset Index idx
status open

\begin_layout Plain Layout
MitM
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
MitM is a form of active eavesdropping where an attacker maintains independent
 connections between the victims (e.g.
 peer and TKM) and relaying their messages while making them believe they
 talk directly to each other.
\end_layout

\end_inset

 attacks.
 The authentication state in the TCB must always be unambiguously associated
 with the corresponding SA.
\end_layout

\begin_layout Subsection
Integrity
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Integrity"

\end_inset


\end_layout

\begin_layout Standard
The security of the IKEv2 component must solely depend on the correct operation
 of the trusted part.
 The security operation of the system must not be violated by a misbehaving
 untrusted part.
\end_layout

\begin_layout Subsection
Availability
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Availability"

\end_inset


\end_layout

\begin_layout Standard
The resulting system must be freely available to guarantee broader review
 and allow it to be extended by other interested parties.
 The TKM-specific changes and plugins should be integrated into the upstream
 strongSwan project.
 Also, integration tests must be provided for the TKM use-case.
\end_layout

\begin_layout Chapter
TKM interface
\end_layout

\begin_layout Standard
This chapter specifies the interface between the trusted and the untrusted
 parts of the system.
 In a first step an overview of the communication between IKE and TKM is
 given by describing how the main operations of IKE are achieved through
 the usage of the services provided by the interface.
 After the abstract illustration of the protocol, the data types and constants
 are specified.
 These are the building blocks of the message exchanges which are described
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exchanges"

\end_inset

.
\end_layout

\begin_layout Section
Protocol overview
\end_layout

\begin_layout Standard
This section gives an overview of the main IKE
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE
\end_layout

\end_inset

 operations: creation and rekeying of IKE and Child SAs.
 The description presents the success case and specifies which parameters
 are passed back and forth between IKE and the TKM
\begin_inset Index idx
status open

\begin_layout Plain Layout
TKM
\end_layout

\end_inset

 using the exchanges specified in the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-Exchanges"

\end_inset

.
\end_layout

\begin_layout Standard
In the illustrated negotiation of SAs with the peer, IKE is assuming the
 role of the initiator of the exchanges.
 The responder case varies only slightly and is thus not presented here.
 Where necessary the exchanges provide a parameter called 
\shape italic

\begin_inset Quotes eld
\end_inset

initiator
\begin_inset Quotes erd
\end_inset


\shape default
 which is used to specify whether IKE is the initiator or responder of an
 IKEv2 message exchange with the remote peer.
\end_layout

\begin_layout Standard
Note that child SA and ESP
\begin_inset Index idx
status open

\begin_layout Plain Layout
ESP
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Encapsulating Security Payload is part of the IPsec protocol suite and provides
 authenticity, integrity and confidentiality of data packets.
\end_layout

\end_inset

 SA are used interchangeably.
\end_layout

\begin_layout Subsection
Notation
\end_layout

\begin_layout Standard
The protocol is presented as an exchange of messages between the untrusted
 component IKE and the trusted key manager TKM.
 The name of the operation is displayed on the left while the communicating
 entities are separated by an arrow which is directed from the source to
 the destination.
 Transmitted data is specified on the right-hand side.
\end_layout

\begin_layout Standard
For some exchanges only a status code of the performed operation is returned
 to IKE.
 In such cases the response is simply omitted for the sake of brevity.
\end_layout

\begin_layout Standard
Since exchanges operate on contexts that contain data and maintain associated
 state, these must be referenced when performing operations.
 This is done using context IDs.
 For example the transmitted parameter 
\emph on
nc_id
\emph default
 identifies the nonce context to operate on.
 The rationale and further explanations of context IDs are given in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Contexts-and-identifiers"

\end_inset

.
\end_layout

\begin_layout Subsection
Creation of an IKE SA
\begin_inset CommandInset label
LatexCommand label
name "sub:Creation-of-an-ike-sa"

\end_inset


\end_layout

\begin_layout Standard
In a first step the client gets a nonce and a Diffie-Hellman public value
 from the TKM using the 
\family typewriter
nc_create
\family default
 and 
\family typewriter
dh_create
\family default
 operations:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates an IKE SA exchange with the remote peer, which
 is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

.
 Upon receipt of the peer's response the Diffie-Hellman shared secret can
 be calculated.
 Thus IKE issues the 
\family typewriter
dh_generate_key
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM performs the calculation and stores the DH key for future consumption.
 No data other than the status code of the operation is passed back to IKE.
\end_layout

\begin_layout Standard
Using the previously created nonce and Diffie-Hellman value plus the nonce
 (
\shape italic
Nr
\shape default
) received from the remote peer, a new IKE SA is created:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_create}{IKE}{TKM}{isa
\backslash
_id, ae
\backslash
_id, ia
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, init, spi
\backslash
subscript{local}, spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{sk
\backslash
_ai, sk
\backslash
_ar, sk
\backslash
_ei, sk
\backslash
_er}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The returned encryption and integrity protection keys can now be used by
 the IKE daemon to send encrypted and integrity protected IKEv2 messages
 to the remote peer.
 For a consideration of why these keys can be handed out by TKM to the untrusted
 side, please refer to section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation-of-key"

\end_inset

.
\end_layout

\begin_layout Standard
To authenticate itself to the remote peer the IKE daemon requests signed
 local authentication data from TKM using the 
\family typewriter
isa_sign
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_sign}{IKE}{TKM}{isa
\backslash
_id, lc
\backslash
_id, init
\backslash
_message}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{AUTH
\backslash
subscript{local}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In possesion of the necessary data and keys, the IKE_AUTH protocol step,
 described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_AUTH"

\end_inset

, is performed with the remote peer.
\end_layout

\begin_layout Standard
Upon reception of the peer's response the IKE daemon starts to validate
 the certificate chain of the remote peer certificate 
\shape italic
CERT
\shape default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_set
\backslash
_user
\backslash
_certificate}{IKE}{TKM}{cc
\backslash
_id, ri
\backslash
_id, autha
\backslash
_id, CERT}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each certificate in the chain is added by issuing the 
\family typewriter
cc_add_certificate
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_add
\backslash
_certificate}{IKE}{TKM}{cc
\backslash
_id, autha
\backslash
_id, CERT}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the root of the certificate chain is reached it must be asserted that
 the CA is trusted.
 This is done using the 
\family typewriter
cc_check_ca
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_check
\backslash
_ca}{IKE}{TKM}{cc
\backslash
_id, ca
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After successful verification of the remote certificate, IKE can authenticate
 the peer:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_auth}{IKE}{TKM}{isa
\backslash
_id, cc
\backslash
_id, init
\backslash
_message, AUTH
\backslash
subscript{remote}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a final step the first child SA can be created issuing the 
\family typewriter
esa_create_first
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_create
\backslash
_first}{IKE}{TKM}{esa
\backslash
_id, isa
\backslash
_id, sp
\backslash
_id, ea
\backslash
_id, esp
\backslash
_spi
\backslash
subscript{local}, esp
\backslash
_spi
\backslash
subscript{remote}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this exchange processed successfully by the TKM, IKE has established
 an IKE and one ESP SA which can be used to encrypt application data according
 to the associated security policy identified by 
\shape italic
sp_id
\shape default
.
\end_layout

\begin_layout Subsection
Creation of a Child SA
\begin_inset CommandInset label
LatexCommand label
name "sub:Child-SA-creation"

\end_inset


\end_layout

\begin_layout Standard
Creating a child SA is quite similar to creating an IKE SA.
 All steps related to peer authentication can be omitted since the remote
 identity has already been authenticated.
\end_layout

\begin_layout Standard
To create a new child SA with perfect forward secrecy (PFS), a fresh nonce
 and Diffie-Hellman value must be created:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates a CREATE_CHILD_SA exchange with the remote
 peer (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-CREATE_CHILD_SA"

\end_inset

).
 Upon receipt of the peer's response the Diffie-Hellman shared secret is
 calculated by issuing the 
\family typewriter
dh_generate_key
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM performs the calculation and stores the DH key for future consumption.
 Only the status code of the operation is passed back to IKE.
\end_layout

\begin_layout Standard
Finally the child SA can be created using the 
\family typewriter
esa_create
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_create}{IKE}{TKM}{esa
\backslash
_id, isa
\backslash
_id, sp
\backslash
_id, ea
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, initiator, esp
\backslash
_spi
\backslash
subscript{local}, esp
\backslash
_spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this final step the IKE daemon has successfully established a new
 child SA.
\end_layout

\begin_layout Subsection
Rekeying of an IKE SA
\end_layout

\begin_layout Standard
An IKE SA is rekeyed by replacing it with a new IKE SA.
 For this purpose a fresh nonce and a DH public value is needed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates a CREATE_CHILD_SA exchange to rekey the existing
 IKE SA with the peer.
 Upon receipt of the peers response the Diffie-Hellman shared secret can
 be calculated:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rekeying of the IKE SA, identified by 
\shape italic
parent_isa_id
\shape default
, is performed using the 
\family typewriter
isa_create_child
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_create
\backslash
_child}{IKE}{TKM}{isa
\backslash
_id, parent
\backslash
_isa
\backslash
_id, ia
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, initiator, spi
\backslash
subscript{local}, spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{sk
\backslash
_ai, sk
\backslash
_ar, sk
\backslash
_ei, sk
\backslash
_er}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM returns the new encryption and integrity keys of the new IKE SA, which
 from this point on is used to exchange IKEv2 messages with the remote peer.
\end_layout

\begin_layout Standard
To effectively complete the rekeying operation, the superseded IKE SA must
 be reset:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_reset}{IKE}{TKM}{isa
\backslash
_id
\backslash
subscript{old}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\shape italic
isa_id
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subscript{old}
\end_layout

\end_inset


\shape default
 is the same as the 
\shape italic
parent_isa_id
\shape default
 used in the 
\family typewriter
isa_create_child
\family default
 operation.
\end_layout

\begin_layout Subsection
Rekeying of a child SA
\end_layout

\begin_layout Standard
A child SA is rekeyed by replacing it with a new child SA.
 In order to achieve this, the steps described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Child-SA-creation"

\end_inset

 must be performed.
 After the new child SA has been established it must be selected to make
 it the active SA for ESP encryption:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_select}{IKE}{TKM}{esa
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only thing left to do is to reset the old, rekeyed child SA:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_reset}{IKE}{TKM}{esa
\backslash
_id
\backslash
subscript{old}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Data types and constants
\end_layout

\begin_layout Standard
This section presents the data types and constants that are used in the
 specification of the TKM interface.
 They are referenced in the description of the interface exchanges, which
 follows in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exchanges"

\end_inset

.
\end_layout

\begin_layout Subsection
Integer types
\begin_inset CommandInset label
LatexCommand label
name "sub:Integer-types"

\end_inset


\end_layout

\begin_layout Standard
These types are numeric integers.
 Their 
\family typewriter
size
\family default
 is specified in bytes, which is also the amount of memory an object of
 such a type consumes.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-integer.tex"

\end_inset


\end_layout

\begin_layout Subsection
Variable octet types
\end_layout

\begin_layout Standard
These types are octet sequences of variable size.
 
\family typewriter
Data
\family default
 is the maximum number of data bytes that can be stored in the octet sequence,
 while 
\family typewriter
size
\family default
 is the number of bytes an object of this type occupies in memory.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-varoctets.tex"

\end_inset


\end_layout

\begin_layout Subsection
Constants
\begin_inset CommandInset label
LatexCommand label
name "sub:Constants"

\end_inset


\end_layout

\begin_layout Standard
The TKM interface specifies various numeric constants, which can be referenced
 by the IKE daemon or the TKM.
 All constants are typed, which restricts their range of valid values.
 All constants are given in hexadecimal form.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-constants.tex"

\end_inset


\end_layout

\begin_layout Section
Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sec:Exchanges"

\end_inset


\end_layout

\begin_layout Standard
This section describes all exchanges of the different TKM interfaces.
 The interface is comprised of two service-specific parts: IKE and EES (ESP
 Event Service).
\end_layout

\begin_layout Standard
Communication is seen as an exchange of request and response message pairs
 between a client and a server.
 In the concrete implementation, which is presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:charon-tkm"

\end_inset

, the untrusted charon daemon takes the role of the client while TKM is
 the server of the IKE interface.
 Contrary charon acts as a server of the EES interface, described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

, while the xfrm-proxy (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:xfrm-proxy"

\end_inset

) implements the client side.
\end_layout

\begin_layout Standard
Exchanges are identified by numeric values (
\family typewriter
operation_type
\family default
 defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Integer-types"

\end_inset

) which are unique on a per-interface basis.
\end_layout

\begin_layout Standard
Requests contain an identifier (
\family typewriter
request_id
\family default
)
\shape italic
 
\shape default
which is chosen by the client of an exchange.
 The server must set the 
\family typewriter
request_id
\family default
 of the corresponding response to be identical.
 This enables the client to match responses to their requests and handle
 multiple pending exchanges with possible 
\shape italic
out-of-order
\shape default
 arrival of responses.
\end_layout

\begin_layout Standard
The basic layout of a request and response object is show in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-and-response"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/request-response-structure.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Request and response structure
\begin_inset CommandInset label
LatexCommand label
name "fig:Request-and-response"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
IKE Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sub:IKE-Exchanges"

\end_inset


\end_layout

\begin_layout Standard
All the following exchanges are used by IKE to communicate with the TKM
 and perform operations related to IKE or ESP SA establishment.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-nc_create.tex"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsub:Exchanges-nc-create"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-nc_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_generate_key.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_set_user_certificate.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_add_certificate.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_check_ca.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-ae_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_create.tex"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsub:Exchanges-isa-sign"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_sign.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_auth.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_create_child.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create_first.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create_no_pfs.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_select.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_version.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_limits.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_reset.tex"

\end_inset


\end_layout

\begin_layout Subsection
ESP SA Event Service (EES) Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sub:ESP-SA-Event"

\end_inset


\end_layout

\begin_layout Standard
The exchanges specified in this section are used by the xfrm-proxy to communicat
e with IKE.
 EES is used to send notifications about ESP SA events such as acquire or
 expire.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-EES-esa_acquire.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-EES-esa_expire.tex"

\end_inset


\end_layout

\begin_layout Section
State machines
\begin_inset CommandInset label
LatexCommand label
name "sec:State-machines"

\end_inset


\end_layout

\begin_layout Standard
Contexts are used to describe stateful entities within the TKM.
 They are finite state machines (FSM
\begin_inset Index idx
status open

\begin_layout Plain Layout
FSM
\end_layout

\end_inset

) which have a set of states and transitions between those states.
 The FSM is in a specific state at any given time and can only change its
 state by performing a transition.
 A transition prescribes the source state the FSM has to be in, the actions
 to execute and the new target state once the transition has completed.
\end_layout

\begin_layout Standard
The state machine transitions to a known failure state if an error occurs.
 To recover from such an error the FSM has to be reinitialized by explicitly
 performing a reset operation.
\end_layout

\begin_layout Standard
The state of the overall TKM system can be interpreted as the sum of the
 states of all FSMs and their associated data at any given time.
\end_layout

\begin_layout Subsection
Notation
\end_layout

\begin_layout Standard
All states of an FSMs are listed by name and giving a short description
 of the state.
 The initial state of the state machine is marked with a *.
\end_layout

\begin_layout Standard
Transitions are given by their name, source and target states and a description
 explaining the actions performed during when transitioning.
 If a transition can be performed from multiple states, all of them are
 listed in the source field.
 A * symbol as source means that the transition can be executed from any
 state.
\end_layout

\begin_layout Standard
Additionally each state machine is depicted by a diagram.
 Transitions are drawn as directed arrows from the source to the target
 state with a label identifying the name of the transition.
\end_layout

\begin_layout Standard

\shape italic
Reset
\shape default
 and 
\shape italic
error
\shape default
 transitions are treated differently in order to create less cluttered graphs.
 These two transitions can be triggered from any state so their labels are
 omitted and their arrows have different styles.
 Reset transitions are shown using blue lines and error transitions are
 marked with red dashed lines.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-nc.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-nc.svg
	scale 58

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nonce context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-dh.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-dh.svg
	scale 58

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diffie-Hellman context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-cc.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-cc.svg
	scale 58

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Certificate chain context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-ae.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-ae.svg
	scale 58

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Authenticated endpoint context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-isa.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-isa.svg
	scale 58

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-esa.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-esa.svg
	scale 58

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ESP SA context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard
This chapter describes the implementation of the design outlined in chapter
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Design"

\end_inset

.
 The first section briefly presents how the interface is described in XML,
 how that specification is transformed into various formats and what parts
 of the system are generated based on that specification.
 The next section then describes the remote procedure call (RPC
\begin_inset Index idx
status open

\begin_layout Plain Layout
RPC
\end_layout

\end_inset

) library which is used by various components for communication.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:charon-tkm"

\end_inset

 gives an in-depth characterization of the changes to the strongSwan project,
 the newly implemented plugins and how the integration of Ada code into
 the existing project is realized.
 Following that the trusted key manager TKM implementation is presented.
\end_layout

\begin_layout Standard
The new component xfrm-proxy which provides ESP SA events to charon-tkm
 is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:xfrm-proxy"

\end_inset

.
 Additional libraries that are used by either TKM or xfrm-proxy are illustrated
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Additional-components"

\end_inset

.
 Finally limitations of the current implementation with regards to the design
 are listed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

 and the implementation is examined if and to what degree it meets the requireme
nts laid out in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Section
XML specification
\begin_inset CommandInset label
LatexCommand label
name "sec:XML-Specification"

\end_inset


\end_layout

\begin_layout Standard
The interface specification, which is the basis of the communication of
 system components, is done in XML.
 Extensible stylesheet language transformations (XSLT
\begin_inset Index idx
status open

\begin_layout Plain Layout
XSLT
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
XSLT is a language standardized by the W3C (World Wide Web Consortium) for
 transforming XML documents
\end_layout

\end_inset

) are used to generate many different representations of the XML document.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/xsl-transformations.svg
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
XSL Transformation of XML specification
\begin_inset CommandInset label
LatexCommand label
name "fig:XSL-Transformation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Automatically generating code and documentation from a single XML source
 assures that the created documents are always in sync and there is no mismatch
 between the implementation and the specification.
 The cost of interface change and extension is lowered considerably since
 the generation process is automated and no manual steps are necessary.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:XSL-Transformation"

\end_inset

 shows the process of applying the XSL transformations to the specification
 and the various generated outputs.
\end_layout

\begin_layout Standard
An interesting example of such a transformation is the generation of the
 Ada context state machine code.
 Leveraging the newly added contract feature of Ada 2012, the transitions
 of a context state machine are translated into pre- and postconditions.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-spec"

\end_inset

 shows the specification of the 
\family typewriter
nc_create
\family default
 transition as an example.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float=h,language=XML"
inline false
status open

\begin_layout Plain Layout

<transition name="create">
\end_layout

\begin_layout Plain Layout

	<descr>Create new nonce.</descr>
\end_layout

\begin_layout Plain Layout

	<source_states>
\end_layout

\begin_layout Plain Layout

		<state name="clean"/>
\end_layout

\begin_layout Plain Layout

	</source_states>
\end_layout

\begin_layout Plain Layout

	<target>
\end_layout

\begin_layout Plain Layout

		<state name="created"/>
\end_layout

\begin_layout Plain Layout

		<field name="nonce"> nonce </field>
\end_layout

\begin_layout Plain Layout

	</target>
\end_layout

\begin_layout Plain Layout

</transition> 
\begin_inset Caption

\begin_layout Plain Layout
Specification of nonce create transition
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-spec"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The generated Ada code is shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-ada"

\end_inset

.
 The preconditions state that the nonce context with the given ID must be
 in the 
\begin_inset Quotes eld
\end_inset

clean
\begin_inset Quotes erd
\end_inset

 state.
 This corresponds to the source state element of the XML specification.
 Transitioning to the target state 
\begin_inset Quotes eld
\end_inset

created
\begin_inset Quotes erd
\end_inset

 is assured by the postcondition.
 If a violation of a pre- or postcondition occurs a 
\emph on
System.Assertions.Assert_Failure
\emph default
 exception is raised by the Ada runtime.
 This assures that only transitions conforming to the specification are
 possible.
 Confidence that the code implements the specification can be raised further
 by applying the GNATprove
\begin_inset Index idx
status open

\begin_layout Plain Layout
GNATprove
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
GNATprove is a formal verification tool for Ada 2012 contracts.
 It can prove that subprograms honor their preconditions and postconditions.
\end_layout

\end_inset

 tool 
\begin_inset CommandInset citation
LatexCommand cite
key "gnatprove"

\end_inset

 to the source.
 The XSL code generation process provides support to run GNATprove automatically
, after the sources have been created.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float=h,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure create (Id : Types.nc_id_type;
\end_layout

\begin_layout Plain Layout

				  nonce : Types.nonce_type)
\end_layout

\begin_layout Plain Layout

with
\end_layout

\begin_layout Plain Layout

  Pre  => Is_Valid (Id) and then
\end_layout

\begin_layout Plain Layout

		 (Has_State (Id, clean)),
\end_layout

\begin_layout Plain Layout

  Post => Has_State (Id, created) and
\end_layout

\begin_layout Plain Layout

		  Has_nonce (Id, nonce);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Generated Ada nonce create procedure
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-ada"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another example of generated output are the state machine diagrams show
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-machines"

\end_inset

.
\end_layout

\begin_layout Standard
The following list enumerates the main XSLT output that is generated from
 the specification:
\end_layout

\begin_layout Itemize

\emph on
Types
\emph default
: Ada and C type definitions
\end_layout

\begin_layout Itemize

\emph on
Constants
\emph default
: Ada and C constant definitions
\end_layout

\begin_layout Itemize

\emph on
RPC
\emph default
: Ada RPC library with exported C functions, includes request/response marshalin
g and server-side exchange ID to service procedure dispatching
\end_layout

\begin_layout Itemize

\emph on
Contexts
\emph default
: Ada context state machines including Ada 2012 contracts
\end_layout

\begin_layout Itemize

\emph on
Documentation
\emph default
: Types, constants and exchange description as well as state machine diagrams
\end_layout

\begin_layout Section
RPC library: tkm-rpc
\begin_inset CommandInset label
LatexCommand label
name "sub:tkm-rpc-library"

\end_inset


\end_layout

\begin_layout Standard
Since the main objective of this project is to separate security-critical
 functionality from untrusted software components and extract it into a
 TCB, the need for a communication mechanism between the disjointed parts
 arises.
 The communication layer is abstracted into a self-contained library called
 tkm-rpc.
 It allows the untrusted and trusted side to exchange well-formed messages,
 so called request and responses, as defined by the interface specification.
\end_layout

\begin_layout Standard
At the core of an exchange are the request and response data types.
 Clients send a request object to a server and the server responds by sending
 back a corresponding response object.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Basic-operation"

\end_inset

 describes the general operation of the tkm-rpc library.
\end_layout

\begin_layout Standard
To make use of the library clients simply include the necessary project
 or header files, which contain the type, constant definitions and procedure
 or function specifications.
 How the library is intended to be used by clients is described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Client-side-usage"

\end_inset

.
\end_layout

\begin_layout Standard
Server-side components are expected to provide an implementation of interface-sp
ecific procedures.
 How the server processing is done is illustrated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Server-side-processing"

\end_inset

.
\end_layout

\begin_layout Standard
When appropriate, the concrete implementation is illustrated using the 
\family typewriter
nc_create
\family default
 exchange, which is specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsub:Exchanges-nc-create"

\end_inset

.
\end_layout

\begin_layout Subsection
Basic operation
\begin_inset CommandInset label
LatexCommand label
name "sub:Basic-operation"

\end_inset


\end_layout

\begin_layout Standard
The tkm-rpc library provides an RPC
\begin_inset Index idx
status open

\begin_layout Plain Layout
RPC
\end_layout

\end_inset

 (remote procedure call) interface that uses a data transmission channel
 to pass client requests to a server and responses back to the client.
 The basic layout of request and response data types are shown in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-and-response"

\end_inset

.
 The operation type of a request or response specifies what exchange it
 is part of.
 Requests are matched to their corresponding responses using the request_id
 field.
 However, this is currently not implemented (see also the limitation section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

).
 Support for multiple simultaneous exchanges and asynchronous request processing
 can be implemented using the request_id matching.
 Currently a call to the tkm-rpc library blocks the client until the server's
 response is received.
\end_layout

\begin_layout Standard
Most of the library code is automatically generated based on the XML specificati
on.
 Only the transport-specific parts of sending and receiving requests and
 responses using a particular communication method is implemented manually.
 The exchange of data is performed using Unix domain sockets.
 The necessary networking functionality is provided by the Anet library,
 which is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anet"

\end_inset

.
\end_layout

\begin_layout Standard
The round trip of an exchange is illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-IPC-operation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ipc-overview.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Basic IPC operation
\begin_inset CommandInset label
LatexCommand label
name "fig:Basic-IPC-operation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A client calls a function or procedure that is specified by the TKM interface.
 That call is translated into a request object with the operation set to
 the corresponding exchange id.
 Any parameters are marshaled into data fields of the request object.
 The request is then transmitted to the server via a Unix domain socket
\begin_inset Foot
status open

\begin_layout Plain Layout
Unix domain sockets are a standard IPC mechanism and are part of the POSIX
 socket API
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "IEEE:POSIX"

\end_inset

.
\end_layout

\begin_layout Standard
On the server side of the socket, the request object is unmarshaled.
 The operation is dispatched according to the exchange ID and the parameters
 of the exchange are extracted from the request object.
 The call is then forwarded to the server passing it the necessary arguments
 sent by the client.
 At this point the server performs all necessary actions to service the
 requested operation.
 After the server has finished handling the request, it returns result data.
 A response data object is created with the same exchange and request IDs
 as the request object.
 The response parameters are then marshaled into the corresponding response
 data fields and the response object is sent back to the client via the
 Unix socket.
\end_layout

\begin_layout Standard
Back on the client side the response is unmarshaled and any return parameters
 are extracted from the response object.
 These values are then passed back to the client thus completing the exchange.
\end_layout

\begin_layout Standard
A complete list of all IKE exchanges is given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-Exchanges"

\end_inset

.
\end_layout

\begin_layout Subsection
Request and Response types
\end_layout

\begin_layout Standard
Each exchange has a specific request and response type.
 These are generated from the XML specification and their basic structure
 is depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-and-response"

\end_inset

.
 Every request has a header which contains the exchange and the request
 identifier.
 Responses contain the same header information plus an additional status
 code.
 The result code signals success or error conditions to the caller using
 the constant values specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Constants"

\end_inset

.
\end_layout

\begin_layout Standard
Exchange specific data is stored in additional record fields after the header.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-request-specific-data"

\end_inset

 shows the generated data type of the 
\family typewriter
nc_create
\family default
 exchange, consisting of the header and request-specific data.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

type Data_Type is record
\end_layout

\begin_layout Plain Layout

   Nc_Id        : Types.Nc_Id_Type;
\end_layout

\begin_layout Plain Layout

   Nonce_Length : Types.Nonce_Length_Type;
\end_layout

\begin_layout Plain Layout

end record;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for Data_Type use record
\end_layout

\begin_layout Plain Layout

   Nc_Id        at 0 range 0 ..
 (8 * 8) - 1;
\end_layout

\begin_layout Plain Layout

   Nonce_Length at 8 range 0 ..
 (8 * 8) - 1;
\end_layout

\begin_layout Plain Layout

end record;
\end_layout

\begin_layout Plain Layout

for Data_Type'Size use Data_Size * 8;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type Request_Type is record
\end_layout

\begin_layout Plain Layout

   Header  : Request.Header_Type;
\end_layout

\begin_layout Plain Layout

   Data    : Data_Type;
\end_layout

\begin_layout Plain Layout

   Padding : Padding_Type;
\end_layout

\begin_layout Plain Layout

end record;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
nc_create request-specific data type
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-request-specific-data"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As is apparent, the requests parameters as specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsub:Exchanges-nc-create"

\end_inset

 have a corresponding record field in the exchange-specific data type.
 The exact memory layout of the record is specified using an Ada record
 representation clause.
 All requests like all response types are of the same size.
 Requests that are smaller than the required length are padded with zeros.
 Responses are constructed following the same idiom.
\end_layout

\begin_layout Subsection
Client-side usage
\begin_inset CommandInset label
LatexCommand label
name "sub:Client-side-usage"

\end_inset


\end_layout

\begin_layout Standard
The purpose of an RPC library is to hide the complicated exchange and transport
 details from the user.
 It must be very easy to use and remote calls should look like local procedure
 or function calls to the client.
 As previously mentioned the majority of the RPC client library is automatically
 generated from the XML specification.
 An exception is the transport layer.
 The next section explains the motivation and the operation of the transport
 layer abstraction.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Request-handling"

\end_inset

 illustrates how clients use the RPC library and how the internal processing
 works.
\end_layout

\begin_layout Subsubsection
Transport mechanism abstraction
\begin_inset CommandInset label
LatexCommand label
name "sub:Transport-mechanism-abstraction"

\end_inset


\end_layout

\begin_layout Standard
The transport layer constitutes the lowest level of the RPC library.
 To ease the usage of different communication mechanisms, all necessary
 functionality is encapsulated in the 
\family typewriter
Tkmrpc.Transport.Client
\family default
 package.
 The current implementation employs stream-oriented Unix sockets using the
 functionality provided by Anet (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anet"

\end_inset

).
 To run the TKM daemon on a different physical machine, switching to a TCP
 socket implementation and connecting to an IP address and port is all that
 is necessary from the client's point of view.
\end_layout

\begin_layout Standard
The interface, which is automatically generated, is rather simple and only
 three procedures must be implemented, see listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Client-Tkmrpc-transport"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

with Tkmrpc.Request;
\end_layout

\begin_layout Plain Layout

with Tkmrpc.Response;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

package Tkmrpc.Transport.Client is
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   procedure Connect (Address : String);
\end_layout

\begin_layout Plain Layout

   --  Connect to the RPC server given by socket address.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   procedure Send (Data : Request.Data_Type);
\end_layout

\begin_layout Plain Layout

   --  Send request data to RPC server.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   procedure Receive (Data : out Response.Data_Type);
\end_layout

\begin_layout Plain Layout

   --  Receive response data from RPC server.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end Tkmrpc.Transport.Client;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Client Tkmrpc transport abstraction
\begin_inset CommandInset label
LatexCommand label
name "lis:Client-Tkmrpc-transport"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before a client can do remote procedure calls using tkm-rpc it must connect
 to the remote server component specifying the filename of the Unix socket,
 where the server is listening for exchanges.
 The 
\family typewriter
Send
\family default
 procedure is used to transmit request objects to the connected RPC server
 while the 
\family typewriter
Receive
\family default
 procedure returns a response object received from the server.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Request-handling"

\end_inset

 explains how the two procedures are used to implement request and response
 handling.
\end_layout

\begin_layout Subsubsection
Request handling
\begin_inset CommandInset label
LatexCommand label
name "sub:Request-handling"

\end_inset


\end_layout

\begin_layout Standard
Based on the XML exchange description Ada procedure definitions are generated.
 Since the exchanges are specified on a per-interface basis (e.g.
 IKE or EES), procedures belonging together are put in the same package,
 e.g.
 
\family typewriter
Tkmrpc.Clients.Ike
\family default
.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Nc_Create-procedure-declaration"

\end_inset

 shows the generated procedure declaration for the 
\family typewriter
nc_create
\family default
 exchange.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure Nc_Create
\end_layout

\begin_layout Plain Layout

  (Result       : out Results.Result_Type;
\end_layout

\begin_layout Plain Layout

   Nc_Id        : Types.Nc_Id_Type;
\end_layout

\begin_layout Plain Layout

   Nonce_Length : Types.Nonce_Length_Type;
\end_layout

\begin_layout Plain Layout

   Nonce        : out Types.Nonce_Type);
\end_layout

\begin_layout Plain Layout

  pragma Export (C, Nc_Create, "ike_nc_create");
\end_layout

\begin_layout Plain Layout

  pragma Export_Valued_Procedure
\end_layout

\begin_layout Plain Layout

    (Nc_Create,
\end_layout

\begin_layout Plain Layout

     Mechanism => (Nc_Id => Value, Nonce_Length => Value));
\end_layout

\begin_layout Plain Layout

--  Create a nonce.
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Nc_Create procedure declaration (client-side)
\begin_inset CommandInset label
LatexCommand label
name "lis:Nc_Create-procedure-declaration"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The export pragmas make the procedures callable from the C programming language.
 To enable the use of the library in C, a header file containing corresponding
 C function declarations for each exchange is also generated.
 Since the C language has no notion of packages and has one global namespace,
 all procedures are prefixed with the name of the interface they belong
 to.
 Thus the exchange to create a nonce is called 
\family typewriter
Nc_Create
\family default
 in Ada and 
\family typewriter
ike_nc_create
\family default
 in C.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:ike_nc_create-function-declarati"

\end_inset

 shows the C function declaration equivalent to the Ada procedure presented
 in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Nc_Create-procedure-declaration"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Create a nonce.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

extern result_type ike_nc_create(const nc_id_type nc_id,
\end_layout

\begin_layout Plain Layout

                const nonce_length_type nonce_length,
\end_layout

\begin_layout Plain Layout

                nonce_type *nonce);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ike_nc_create function declaration
\begin_inset CommandInset label
LatexCommand label
name "lis:ike_nc_create-function-declarati"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a client calls the Nc_Create procedure a request object is created,
 filling in the passed parameters.
 Next the object is transmitted using the Send procedure described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transport-mechanism-abstraction"

\end_inset

.
 Afterwards the Receive procedure is used to get a response from the server.
 The result parameters are extracted from the response data type and returned
 to the client depending on the function signature.
\end_layout

\begin_layout Subsection
Server-side processing
\begin_inset CommandInset label
LatexCommand label
name "sub:Server-side-processing"

\end_inset


\end_layout

\begin_layout Standard
RPC servers are passive components which respond to requests sent by clients.
 The main focus of server-side processing is automatic mapping of requests
 to concrete exchanges as specified by the interface.
 A server implementation should not be burdened with the details of exchange
 and request ID handling but concentrate on the implementation of the functional
ity prescribed by the exchange.
\end_layout

\begin_layout Standard
Much like the client part of the RPC library, most of the code is automatically
 generated.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Operation-dispatching"

\end_inset

 describes how incoming requests are dispatched to their corresponding exchange
 handlers.
 After that a description of error handling is given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Error-handling"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Operation dispatching
\begin_inset CommandInset label
LatexCommand label
name "sub:Operation-dispatching"

\end_inset


\end_layout

\begin_layout Standard
All operations exposed to the client via the tkm-rpc library must be implemented
 by a RPC server.
 To ensure this, an Ada package containing procedure declarations is generated
 for each interface described in the XML specification.
 As can be seen by comparing listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Nc_Create-procedure-declaration-server"

\end_inset

 to listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Nc_Create-procedure-declaration"

\end_inset

, the client and server side procedure declarations are almost identical.
 The procedure is not exported since all processing is done in Ada and the
 procedure is not meant to be called from C code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure Nc_Create
\end_layout

\begin_layout Plain Layout

  (Result       : out Results.Result_Type;
\end_layout

\begin_layout Plain Layout

   Nc_Id        : Types.Nc_Id_Type;
\end_layout

\begin_layout Plain Layout

   Nonce_Length : Types.Nonce_Length_Type;
\end_layout

\begin_layout Plain Layout

   Nonce        : out Types.Nonce_Type);
\end_layout

\begin_layout Plain Layout

--  Create a nonce.
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Nc_Create procedure declaration (server-side)
\begin_inset CommandInset label
LatexCommand label
name "lis:Nc_Create-procedure-declaration-server"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A server implementing the 
\shape italic
ike
\shape default
 interface must provide a package body implementing the
\family typewriter
 Tkmrpc.Servers.Ike
\family default
 package.
\end_layout

\begin_layout Standard
A dispatcher which takes a request data object as input and calls the correspond
ing procedure according to the exchange identifier is generated also.
 This takes the burden of mapping an exchange ID to the correct operation
 handler from the server implementation.
 It also avoids possible errors such as typos, which can be hard to detect.
 Additionally the generated code guarantees that all specified exchanges
 are handled and unknown exchanges are answered by returning an Invalid_Operatio
n status code via a response data object.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Ike-request-dispatcher"

\end_inset

 shows the procedure declaration of the
\emph on
 ike
\emph default
 dispatcher, which is located in the (generated)
\family typewriter
 Tkmrpc.Dispatchers.Ike
\family default
 package.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure Dispatch
\end_layout

\begin_layout Plain Layout

  (Req : Request.Data_Type;
\end_layout

\begin_layout Plain Layout

   Res : out Response.Data_Type);
\end_layout

\begin_layout Plain Layout

--  Dispatch IKE request to concrete operation handler.
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Ike request dispatcher
\begin_inset CommandInset label
LatexCommand label
name "lis:Ike-request-dispatcher"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since data received from the client via the Unix socket is just a sequence
 of octets, a method to translate the binary data into request types and
 passing them to the presented dispatcher is needed.
 The different parts are brought together by the 
\family typewriter
Tkmrpc.Process_Stream
\family default
 generic.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Process-stream-generic"

\end_inset

 shows the declaration of the generic procedure.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

generic
\end_layout

\begin_layout Plain Layout

   with procedure Dispatch
\end_layout

\begin_layout Plain Layout

     (Req :     Request.Data_Type;
\end_layout

\begin_layout Plain Layout

      Res : out Response.Data_Type);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   with procedure Exception_Handler
\end_layout

\begin_layout Plain Layout

     (Ex : Ada.Exceptions.Exception_Occurrence) is null;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure Tkmrpc.Process_Stream
\end_layout

\begin_layout Plain Layout

  (Recv_Data :     Ada.Streams.Stream_Element_Array;
\end_layout

\begin_layout Plain Layout

   Send_Data : out Ada.Streams.Stream_Element_Array;
\end_layout

\begin_layout Plain Layout

   Send_Last : out Ada.Streams.Stream_Element_Offset);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Process stream generic
\begin_inset CommandInset label
LatexCommand label
name "lis:Process-stream-generic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To instantiate the generic, a Dispatch procedure matching the given signature
 must be provided.
 Optionally an exception handler can also be specified.
 The generic
\family typewriter
 Process_Stream
\family default
 procedure automatically converts stream data to Tkmrpc request/response
 objects and passes them on to the given dispatch procedure.
 The exception handler is called when the specified dispatching procedure
 raises an exception.
 How exceptions are handled is subject of the following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Error-handling"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Error handling
\begin_inset CommandInset label
LatexCommand label
name "sub:Error-handling"

\end_inset


\end_layout

\begin_layout Standard
The intended way for indicating errors during processing of client requests
 is by raising exceptions.
 Such an exception propagates all the way up to the 
\family typewriter
Process_Stream
\family default
 generic's exception block.
 There the result code of the response is set to failure to indicate an
 error to the client.
\end_layout

\begin_layout Standard
This mechanism works well in combination with the automatically generated
 context state machines because violation of pre- and postconditions raise
 an 
\emph on
System.Assertions.Assert_Failure
\emph default
 exception (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-ada"

\end_inset

).
 These are then properly processed by the 
\family typewriter
Process_Stream
\family default
 generic to relieve the server implementation of the burden of dealing with
 all possible error cases.
\end_layout

\begin_layout Standard
The current implementation returns Invalid_Operation if an error occurs
 and does not translate exceptions to their corresponding error codes, see
 also section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
\end_layout

\begin_layout Standard
How potential exceptions are handled on the client side is outlined in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Exception-handler-(EH)"

\end_inset

.
\end_layout

\begin_layout Section
charon-tkm
\begin_inset CommandInset label
LatexCommand label
name "sec:charon-tkm"

\end_inset


\end_layout

\begin_layout Standard
The untrusted IKEv2 component used in conjunction with the trusted key manager
 infrastructure is implemented as a separate charon 
\begin_inset Quotes eld
\end_inset

instance
\begin_inset Quotes erd
\end_inset

 located in its own directory below the strongSwan top-level source directory
 (
\family typewriter
src/charon-tkm
\family default
).
 This has the advantage that the TKM code is contained and does not mix
 with other strongSwan files.
 The charon-tkm binary startup code works like the already existing charon-nm
 instance, a special charon daemon variant to be used with the GNOME NetworkMana
ger project
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://projects.gnome.org/NetworkManager/
\end_layout

\end_inset


\end_layout

\end_inset

.
 The only difference is the registration of custom TKM plugins as the final
 step of the startup phase.
 The charon-tkm daemon does not rely on the dynamic plugin loading mechanism
 for its core plugins, they are statically registered before entering the
 main processing loop.
\end_layout

\begin_layout Standard
Since the charon-tkm code uses the tkm-rpc library written in Ada, the daemon
 has to be built using an Ada-aware toolchain.
 This integration of Ada code into the strongSwan codebase is explained
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Ada-integration"

\end_inset

.
 Apart from the tkm-rpc library explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

, the ESP SA event service and a special exception handler component are
 directly written in Ada inside the charon-tkm project itself.
 These subsystems are outlined in sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Exception-handler-(EH)"

\end_inset

.
\end_layout

\begin_layout Subsection
Ada integration
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-Ada-integration"

\end_inset


\end_layout

\begin_layout Standard
As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

, the tkm-rpc library is written in Ada and uses the export feature of the
 language (
\family typewriter
pragma
\family default
 Export) to make procedures available to the charon-tkm C code.
 To call Ada code from C requires an initialized Ada runtime.
 To that end the special
\family typewriter
 adainit
\family default
 and 
\family typewriter
adafinal
\family default
 procedures must be called before and after Ada code is used.
 Setup and teardown of the Ada runtime is transparently handled by the tkm-rpc
 library (in the
\family typewriter
 tkmlib_init
\family default
 and
\family typewriter
 tkmlib_final
\family default
 functions), but the charon-tkm code must still be compiled with an Ada-aware
 tool chain to correctly compile, bind and link the daemon binary.
\end_layout

\begin_layout Standard
strongSwan uses the GNU build system, also known as the Autotools
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/GNU_build_system
\end_layout

\end_inset


\end_layout

\end_inset

, to configure, compile and install the project.
 Ada projects using the GNAT Ada compiler usually use gnatmake or gprbuild
\begin_inset Foot
status open

\begin_layout Plain Layout
GNAT's Project Manager
\end_layout

\end_inset

 to build projects.
 It is common practice in Ada projects to mix these two concepts by calling
 the respective GNAT project manager from inside a Makefile for example.
 Therefore the charon-tkm project provides a Makefile.am file which describes
 how to build the charon-tkm daemon binary with gprbuild.
 The project uses the more advanced gprbuild manager because it provides
 superior support for mixed language projects (C and Ada in this case).
\end_layout

\begin_layout Subsection
Initialization
\end_layout

\begin_layout Standard
The entry point of the untrusted component is the 
\family typewriter
main
\family default
 function located in the file 
\family typewriter
charon-tkm.c
\family default
.
 Before entering the main loop, the charon-tkm daemon calls the 
\family typewriter
tkm_init
\family default
 function which initializes the tkm-rpc library explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

 and starts the exception handler (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Exception-handler-(EH)"

\end_inset

) used to catch Ada exceptions on the client side.
\end_layout

\begin_layout Standard
It then calls the 
\family typewriter
ike_init
\family default
 function to connect to the IKE interface of the TKM.
 After that the ESP SA event service is started which accepts ESA acquire
 and expire events from clients (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

).
 If no error occurred (which would result in the termination of the daemon),
 the initialization code instructs the TKM inside the TCB to reset itself
 by calling the
\family typewriter
 ike_tkm_reset
\family default
 remote procedure call.
\end_layout

\begin_layout Standard
Since the TKM supports a static number of contexts (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Contexts-and-identifiers"

\end_inset

), the upper limit of context IDs is requested from the TKM.
 This limit configuration is then passed on to the TKM ID manager which
 is initialized in the final step along with the TKM chunk map.
 The daemon enters the main loop and waits for external events.
\end_layout

\begin_layout Subsection
ID manager
\begin_inset CommandInset label
LatexCommand label
name "sub:ID-manager"

\end_inset


\end_layout

\begin_layout Standard
The TKM ID manager implemented in files 
\family typewriter
tkm/tkm_id_manager.[h|c]
\family default
 handles the management of the different context ID kinds.
 Its interface is very simple.
 The 
\family typewriter
acquire_id
\family default
 function can be used to acquire (reserve) a new ID for a given context
 (e.g.
 
\family typewriter
TKM_CTX_DH
\family default
 for a new DH context ID).
 The 
\family typewriter
release_id
\family default
 function releases an already reserved ID.
 If no ID can be acquired, the
\family typewriter
 acquire_id
\family default
 function indicates this error by returning zero.
 The first valid ID of a given context always starts at number one.
\end_layout

\begin_layout Subsection
Data passing
\end_layout

\begin_layout Standard
The TKM code uses two main techniques to pass on information from one plugin
 to another for cases where the strongSwan interface is not prepared to
 handle the use case.
 These two techniques allowed to implement the required TKM functionality
 without being too invasive to the upstream strongSwan codebase.
 This is especially true for situations which are only relevant for the
 TKM project, with no benefit for the project as a whole.
\end_layout

\begin_layout Standard
One of these mechanisms use the chunk map explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Chunk-map"

\end_inset

, the other is explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Chunk map
\begin_inset CommandInset label
LatexCommand label
name "sub:Chunk-map"

\end_inset


\end_layout

\begin_layout Standard
The chunk map can be used to store mappings of context IDs to chunks
\begin_inset Foot
status open

\begin_layout Plain Layout
Chunks are strongSwans notion of binary data containing e.g.
 nonces or cryptographic keys
\end_layout

\end_inset

.
 This is required to preserve context ID information over plugin borders.
 If for example the nonce plugin allocates a fresh nonce in a new context,
 this relation has to be stored because the strongSwan interfaces have no
 notion of context IDs since such IDs are only used inside the TKM code.
 Therefore, the nonce plugin stores the chunk to context ID relation in
 the chunk map.
 Another plugin which receives the nonce chunk, which is by definition random
 and unique, is able to retrieve the associated context ID by consulting
 the chunk map.
\end_layout

\begin_layout Subsubsection
Piggybacking
\begin_inset CommandInset label
LatexCommand label
name "sub:Piggybacking"

\end_inset


\end_layout

\begin_layout Standard
Another method of passing TKM specific information over plugin borders uses
 a piggybacking technique to store informational structs inside chunk objects.
 strongSwan often treats such chunks as opaque values while passing them
 between plugins.
 This allows to store TKM-specific information in these chunks for plugins
 which use it to initiate an action with the TKM.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:isa_info_t-struct"

\end_inset

 shows the 
\family typewriter
isa_info_t
\family default
 informational structure used to transfer ISA information from the keymat
 of a parent SA to the keymat of the new IKE SA during a rekeying operation.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

struct isa_info_t {
\end_layout

\begin_layout Plain Layout

	/** 	 
\end_layout

\begin_layout Plain Layout

     * Parent isa context id.
 	 
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

     isa_id_type parent_isa_id;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

	 * Authenticated endpoint context id.
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

     ae_id_type ae_id;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
isa_info_t struct
\begin_inset CommandInset label
LatexCommand label
name "lis:isa_info_t-struct"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In this case the sk_d data chunk returned by the
\family typewriter
 get_skd
\family default
 function is used to transport the
\family typewriter
 isa_into_t
\family default
 informational structure.
 This is possible since the sk_d chunk is treated as an opaque value and
 handed to the 
\family typewriter
derive_ike_keys
\family default
 procedure of the new keymat as-is without  any processing.
 The information is stored in the sk_d chunk as shown by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Piggybacking"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

isa_info_t *isa_info;
\end_layout

\begin_layout Plain Layout

INIT(isa_info,
\end_layout

\begin_layout Plain Layout

     .parent_isa_id = this->isa_ctx_id,
\end_layout

\begin_layout Plain Layout

     .ae_id = this->ae_ctx_id,
\end_layout

\begin_layout Plain Layout

);  
\end_layout

\begin_layout Plain Layout

*skd = chunk_create((u_char *)isa_info, sizeof(isa_info_t)); 
\begin_inset Caption

\begin_layout Plain Layout
Piggybacking
\begin_inset CommandInset label
LatexCommand label
name "lis:Piggybacking"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This method is simple and does not require a global data structure accessible
 to the involved plugins thus avoiding the problem of synchronization.
\end_layout

\begin_layout Subsection
Nonce generation plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Nonce-generation"

\end_inset


\end_layout

\begin_layout Standard
Nonce generation plugins are a new feature of strongSwan introduced during
 this project.
 A nonce generation plugin is responsible to create new nonces needed in
 the IKE_SA_INIT and CHILD_CREATE_SA exchanges (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-CREATE_CHILD_SA"

\end_inset

).
 In case of the TKM, the nonce generation plugin requests a new nonce from
 the TKM by calling the 
\family typewriter
ike_nc_create
\family default
 RPC and then registers the nonce in the chunk map to store the nonce to
 context ID mapping.
 This mapping is used by other plugins which need to pass on a nonce context
 to the TKM for key derivation purposes.
\end_layout

\begin_layout Subsection
Diffie-Hellman plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Diffie-Hellman"

\end_inset


\end_layout

\begin_layout Standard
The TKM Diffie-Hellman plugin instructs the TKM to perform the DH protocol
 on its behalf.
 On creation, the plugin calls the 
\family typewriter
ike_dh_create
\family default
 RPC with a new context ID acquired from the ID manager.
 This initiates the initial steps of the Diffie-Hellman protocol in the
 TKM.
 The plugin completes the DH exchange by calling the 
\family typewriter
ike_dh_generate_key
\family default
 function as soon it receives the public value when its 
\family typewriter
set_other_public_value
\family default
 function is called, as illustrated by figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Child-SA-establishment"

\end_inset

 on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "fig:IKE-SA-establishment"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand pageref
reference "fig:Child-SA-establishment"

\end_inset

 respectively.
 No secret values leave the TCB at any time but the DH context stored in
 the TKM can be referenced later for key derivation by using the correct
 DH context ID.
\end_layout

\begin_layout Subsection
Keymat plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Keymat"

\end_inset


\end_layout

\begin_layout Standard
The charon-tkm code uses the new keymat registration facility developed
 during this project to register a special TKM keymat variant, which acts
 as proxy for the remote keying material stored in the TKM.
 A keymat instance is constructed together with its corresponding IKE SA
 and stays active for the lifetime of this SA.
\end_layout

\begin_layout Standard
Upon construction, the TKM keymat plugin acquires an ISA context ID (
\family typewriter
TKM_CTX_ISA
\family default
) from the ID manager.
 It then behaves like the standard IKEv2 keymat, except that it does not
 store or receive any critical data.
 Calls to 
\family typewriter
derive_ike_keys
\family default
 and 
\family typewriter
derive_child_keys
\family default
 are dispatched into the TCB by using context IDs.
 The keys used to protect the IKE SA are returned to the keymat after the
 
\family typewriter
ike_isa_create
\family default
 or 
\family typewriter
ike_isa_create_child
\family default
 remote procedure call returns because they are not classified as critical
 (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation-of-key"

\end_inset

).
\end_layout

\begin_layout Standard
The keymat plugin uses the piggybacking mechanism described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

 to forward information to plugins or to extract required information from
 other sources.
 For example the 
\family typewriter
derive_child_keys
\family default
 function does nothing more than use the encryption key chunks to store
 information needed by the kernel IPsec plugin explained in the next section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:pluginKernel-IPsec"

\end_inset

.
 The actual child key derivation is postponed until the registered kernel
 plugin's 
\family typewriter
add_sa
\family default
 function is called by the task which takes care of child creation, see
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Child-SA-establishment"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Child-SA-establishment"

\end_inset

, labels (
\emph on
SI
\emph default
) and (
\emph on
IS
\emph default
).
\end_layout

\begin_layout Subsection
Kernel IPsec plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:pluginKernel-IPsec"

\end_inset


\end_layout

\begin_layout Standard
After keying material for a new child SA has been derived in the TKM, the
 child SA state must be established using a kernel IPsec plugin.
 In case of the TKM, where no child keying material leaves the TCB and child
 SA policy handling is completely done by the TKM, the kernel plugin can
 be kept very simple.
 It only provides a custom 
\family typewriter
add_sa
\family default
 function used to instruct the TKM to derive child keys and install a new
 ESA (ESP SA) state inside the TCB's encrypter component.
 This is of course only possible if all preconditions for this operation
 are met.
\end_layout

\begin_layout Subsection
Private key plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Private-key"

\end_inset


\end_layout

\begin_layout Standard
The TKM private key plugin instructs the TKM to create and return the authentica
tion octet signature for a given ISA context.
 Since the code flow of the signature creation process involves two different
 plugins, namely the keymat and the private key plugin, information must
 be passed between these plugins.
 The AUTH octet chunk returned by the keymat's 
\family typewriter
get_auth_octets
\family default
 function is piggybacked in this case.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

 for an explanation of the piggybacking mechanism.
 The TKM keymat stores the associated ISA context ID and the initial message
 in the chunk and returns it to the caller, which is a pubkey authenticator
 in this case (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

).
 The public key authenticator then calls the sign operation of the private
 key plugin.
 The private key code extracts the stored data and calls the
\family typewriter
 ike_isa_sign
\family default
 operation to create the AUTH octet signature.
 The signature is then returned to the caller.
\end_layout

\begin_layout Standard
In its current implementation, the TKM private key plugin is hardcoded to
 a specific keypair (
\emph on
alice@strongswan.org
\emph default
 used in the strongSwan integration test suite).
 The reason for this limitation lies in the way the code is searching for
 a matching private key to authenticate a connection.
 It uses the key fingerprint (which is encoded from the key's modulus and
 public exponent values) of a public key contained in the user certificate
 configured for a connection to find the corresponding private key.
 Since no real private key exists in the TKM-case, because the private key
 never leaves the TCB, the private key plugin must imitate a key fingerprint
 to be found.
\end_layout

\begin_layout Subsection
Public key plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Public-key"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

 shows how the AUTH octet signature received from a peer is verified.
 Since the verification is done in the TKM, a dummy public key plugin must
 be provided which fakes the verification process in the untrusted part.
\end_layout

\begin_layout Standard
To make sure charon always uses the TKM public key plugin implementation
 for public key processing, it is registered first during daemon startup.
\end_layout

\begin_layout Subsection
Bus listener plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Bus-listener"

\end_inset


\end_layout

\begin_layout Standard
The strongSwan architecture provides an internal bus which can be used to
 subscribe for specific events.
 To inform charon about the IKE SA authorization result from the TKM, a
 mechanism called authorization hooks is used.
 The TKM bus listener plugin registers itself as listener for IKE messages
 and the corresponding IKE authorization events to make sure it is consulted
 in the final authorization round for an IKE SA.
\end_layout

\begin_layout Standard
The message hook in the TKM listener is needed to extract the authorization
 payload from the peer's incoming IKE_AUTH message.
 The extracted authorization payload is stored in the keymat in the IKE
 SA corresponding to the exchange in progress.
 This is done by calling the custom TKM keymat function 
\family typewriter
set_auth_payload
\family default
.
 Later this payload is used in the authorize hook of the bus listener hook
 to instruct the TKM to perform the authentication process in the TCB.
\end_layout

\begin_layout Standard
The authorize hook, called by charon as last step in authorization rounds,
 retrieves the keymat by using the associated IKE SA object received as
 function argument.
 It then allocates a new certificate chain context ID and calls the internal
 
\family typewriter
build_cert_chain
\family default
 function to construct the certificate trust chain of the received peer
 certificate.
 The peer's user certificate stored in the authentication configuration
 of the associated IKE SA is set as user certificate for this CC context
 in the TKM by calling the 
\family typewriter
ike_cc_set_user_certificate
\family default
 function.
 This is the certificate for which trust must be established.
 For all intermediate certificates, the 
\family typewriter
build_cert_chain
\family default
 function calls the TKM 
\family typewriter
ike_cc_add_certificate
\family default
 RPC.
 The TKM verifies the trust chain as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

.
 At the end the CA certificate of the chain in question is passed on to
 the TKM.
 This certificate must be bit-wise identical to the one the TKM trusts
\begin_inset Foot
status open

\begin_layout Plain Layout
In its current implementation, the TKM only trusts one CA
\end_layout

\end_inset

.
 If the trust chain could not be verified, the authorize hook returns failure
 and the authentication of the IKE SA does not succeed.
\end_layout

\begin_layout Standard
The the trust chain verification is successful, the authorize hook retrieves
 the authentication payload stored by the message hook from the keymat and
 passes it to the TKM by using the 
\family typewriter
ike_isa_auth
\family default
 RPC.
 The TKM uses the given certificate context which contains the now trusted
 peer public key to verify the signature.
\end_layout

\begin_layout Subsection
ESP SA event service (EES)
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-EES-Service"

\end_inset


\end_layout

\begin_layout Standard
The ESP SA event service exports the EES interface specified in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ESP-SA-Event"

\end_inset

.
 The service is written in Ada as a subsystem of the charon-tkm daemon and
 is located in the 
\family typewriter
ees
\family default
 subdirectory.
 It uses the tkm-rpc library outlined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

 to implement its RPC interface.
\end_layout

\begin_layout Standard
The EES component accepts ESA acquire and expire events from clients and
 dispatches them to the charon C code by using callbacks.
 The callbacks use the strongSwan hydra kernel interface to initiate an
 acquire or expire event the same way it is used if events are received
 from the Linux kernel directly.
 The ESP SA service is used by the xfrm-proxy component outlined in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:xfrm-proxy"

\end_inset

 to relay messages from the kernel's XFRM subsystem to charon.
 This is needed since charon, in this separation scenario, is no longer
 allowed to talk to the kernels IPsec SAD database directly since it contains
 sensitive child SA keys.
\end_layout

\begin_layout Subsection
Exception handler (EH)
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-Exception-handler-(EH)"

\end_inset


\end_layout

\begin_layout Standard
The charon TKM code located in the 
\family typewriter
ehandler
\family default
 subdirectory provides a special exception handler which implements the
 functionality to log exception messages from within Ada code into the daemon's
 log file.
 This mechanism is implemented using the
\emph on
 Exceptions_Actions
\emph default
 framework of the GNAT Ada runtime.
 An Ada procedure with the correct signature can be registered as handler
 for any exception occurring in the runtime
\begin_inset Foot
status open

\begin_layout Plain Layout
As a side note, this also includes internal exceptions which are normally
 not seen by user code.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The registered exception handler calls the imported C function 
\family typewriter
Charon_Terminate
\family default
 which logs the exception message into the daemon's log file and instructs
 it to terminate.
 
\end_layout

\begin_layout Section
TKM
\begin_inset CommandInset label
LatexCommand label
name "sec:TKM"

\end_inset


\end_layout

\begin_layout Standard
The TKM component implements a minimal trusted key manager as depicted in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Split-of-IKE"

\end_inset

 on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "fig:Split-of-IKE"

\end_inset

.
 It provides the critical functionality extracted from the strongSwan code
 base.
 The TKM is written in the Ada programming language and uses the tkm-rpc
 library described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

 to provide the IKE interface (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-Exchanges"

\end_inset

) via remote procedure calls.
 
\end_layout

\begin_layout Standard
The dispatching of incoming calls is done by providing a custom IKE server
 implementation (
\family typewriter
Tkmrpc.Servers.Ike
\family default
) as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Operation-dispatching"

\end_inset

.
 From there, calls are forwarded to the appropriate subsystems explained
 in the following sections.
\end_layout

\begin_layout Subsection
Client communication
\end_layout

\begin_layout Standard
Exchanges between charon-tkm and the TKM daemon are transfered using a Unix
 domain socket.
 The TKM implementation instantiates the 
\family typewriter
Process_Stream
\family default
 generic described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Process-stream-generic"

\end_inset

 with the automatically generated IKE dispatcher and a logging procedure
 as exception handler.
 The procedure is used in conjunction with an Anet stream receiver to perform
 the request and response processing.
\end_layout

\begin_layout Subsection
Nonce generation
\end_layout

\begin_layout Standard
Nonces are used to guarantee freshness in the cryptographic operations when
 deriving key material.
 Hence nonce values must be random and must not be predictable.
 The nonce handling is implemented in the 
\family typewriter
Tkm.Servers.Ike.Nonce
\family default
 package.
\end_layout

\begin_layout Standard
Currently, 
\family typewriter
/dev/urandom
\family default
 is used as random source inside the TKM.
 The quality of randomness provided by this source is considered strong
 enough for the current initial iteration.
 The design is such that the implementation could be easily replaced by
 a stronger random source at a later time.
\end_layout

\begin_layout Standard
The TKM guarantees that nonces are consumed once and can not be reused,
 as specified by requirement 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Cryptographic-operations"

\end_inset

.
 This is assured by using auto-generated nonce FSM as explained in the state-mac
hines section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-machines"

\end_inset

.
 Each created nonce is an instantiation of a nonce FSM.
 If the client requests to create a new context with an already taken nonce
 ID, an assertion exception is raised and an error status is returned to
 the requester.
\end_layout

\begin_layout Subsection
Diffie-Hellman
\end_layout

\begin_layout Standard
Keying material used to protect a child SA is derived from the shared secret
 computed by a Diffie-Hellman exchange.
 This keying material is considered the most sensitive and must therefore
 reside in the TCB only.
 From this requirement follows that the TKM must implement the Diffie-Hellman
 protocol to perform the exchange on behalf of clients like the untrusted
 charon-tkm daemon.
\end_layout

\begin_layout Standard
Currently the TKM provides a Diffie-Hellman implementation for the 3072-bit
 and 4096-bit MODP Diffie-Hellman groups specified in RFC 3526 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3526"

\end_inset

.
 The GNU Multiple Precision Arithmetic Library
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://gmplib.org/
\end_layout

\end_inset


\end_layout

\end_inset

 is used in the implementation since an Ada binding exists
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://mtn-host.prjek.net/projects/libgmpada/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
An active DH exchange is stored in the DH FSM introduced in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-machines"

\end_inset

.
 The FSM's pre- and postconditions assure that only valid states and transitions
 are allowed during an exchange.
 If the protocol specified by the DH FSM is violated, an assertion exception
 is raised and the requester is informed about the violation.
 DH contexts can only be consumed if they are in 'generated' state as shown
 by the corresponding state machine diagram in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-machines"

\end_inset

.
\end_layout

\begin_layout Subsection
Key derivation
\end_layout

\begin_layout Standard
The TKM implements the procedures needed to derive IKE and child keys as
 described by the following subsections.
 
\end_layout

\begin_layout Subsubsection
IKE SA keys
\begin_inset CommandInset label
LatexCommand label
name "sub:IKE-SA-keys"

\end_inset


\end_layout

\begin_layout Standard
The IKE SA (ISA
\begin_inset Index idx
status open

\begin_layout Plain Layout
ISA
\end_layout

\end_inset

) key derivation functionality in the TKM implements the mechanism described
 in RFC 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.14.
 To derive keys for an IKE SA, the derivation function first retrieves the
 associated DH and nonce contexts which must be in the correct state, otherwise
 an exception is raised.
 It then instantiates a pseudo-random function (PRF
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PRF
\end_layout

\end_inset

) needed to generate the SKEYSEED
\begin_inset Index idx
status open

\begin_layout Plain Layout
SKEYSEED
\end_layout

\end_inset

 value as shown by formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:skeyseed"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
SKEYSEED=prf(Ni|Nr,shared\, secret)\label{eq:skeyseed}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The TKM provides a PRF which uses a hash-based message authentication code
 (HMAC
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
HMAC
\end_layout

\end_inset

) as base.
 The HMAC functionality is implemented as a flexible Ada generic which can
 be instantiated using different hash functions.
 The TKM currently does not implement its own hash functions but instead
 re-uses the ones provided by the GNAT Ada compiler.
 The HMAC generic is instantiated as shown by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-hmac-sha512"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

package Tkm.Crypto.Hmac_Sha512 is new Tkm.Crypto.Hmac
\end_layout

\begin_layout Plain Layout

  (Hash_Block_Size => 128,
\end_layout

\begin_layout Plain Layout

   Hash_Length     => 64,
\end_layout

\begin_layout Plain Layout

   Hash_Ctx_Type   => GNAT.SHA512.Context,
\end_layout

\begin_layout Plain Layout

   Initial_Ctx     => GNAT.SHA512.Initial_Context,
\end_layout

\begin_layout Plain Layout

   Update          => GNAT.SHA512.Update,
\end_layout

\begin_layout Plain Layout

   Digest          => GNAT.SHA512.Digest); 
\begin_inset Caption

\begin_layout Plain Layout
TKM HMAC SHA-512
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-hmac-sha512"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To derive the IKE SA keys, the 
\begin_inset Formula $prf+$
\end_inset

 function as specified in RFC 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.13 is required.
 This functionality is again provided by an Ada generic, which can be instantiat
ed using different PRF contexts matching the required signature.
 The 
\begin_inset Formula $prf+$
\end_inset

 function outputs a pseudo-random stream used for IKE SA encryption and
 integrity keys.
 The keys are returned to the untrusted caller as they are not considered
 critical itself.
 This is true under the assumption that the PRF function used to generate
 the keys is strong enough to make it impossible to reverse the process
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The TKM currently uses PRF-HMAC-SHA512 as PRF for the 
\begin_inset Formula $prf+$
\end_inset

 function
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
An authentication context is created alongside the ISA context after the
 IKE SA keying material has been successfully derived.
 This AE context must first be authenticated properly until child SA keys
 can be derived (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Child SA keys
\end_layout

\begin_layout Standard
The process of deriving keying material for a child SA is described in RFC
 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.17.
 The TKM only allows the derivation of child keys if the associated authenticati
on context (AE) is in the 'authenticated' state:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float=h,language=Ada"
inline false
status open

\begin_layout Plain Layout

pragma Precondition (Tkmrpc.Contexts.ae.Has_State
\end_layout

\begin_layout Plain Layout

   (Id    => Tkmrpc.Contexts.isa.get_ae_id (Id => Isa_Id),
\end_layout

\begin_layout Plain Layout

    State => Tkmrpc.Contexts.ae.authenticated)); 
\begin_inset Caption

\begin_layout Plain Layout
Create_Esa precondition
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-create-esa-precondition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The actual keying material for the child SA is derived using the 
\begin_inset Formula $prf+$
\end_inset

 function described in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-SA-keys"

\end_inset

.
 Currently the TKM only supports PRF_HMAC_SHA512 as base for the 
\begin_inset Formula $prf+$
\end_inset

, so the untrusted charon-tkm counterpart and the remote peer involved in
 the connection must be configured accordingly.
 The keys derived are pushed into the kernel's SA database (SAD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) using functionality provided by the xfrm-ada project described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

.
\end_layout

\begin_layout Standard
The TKM supports different configurations for ESA creation only differing
 in the way related nonce and DH contexts are consumed.
 The first child SA of a connection does not depend on nonce or DH contexts
 at all, because it is derived in conjunction with its IKE SA.
 Then there is the configuration where no PFS
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PFS
\end_layout

\end_inset

 is desired, so no new DH context must be created beforehand.
\end_layout

\begin_layout Subsection
Private key
\end_layout

\begin_layout Standard
The TKM only supports authentication schemes based on asymmetric cryptography.
 To create a signature using such a scheme, a private key is needed.
 The key to use can be specified on the command line using the 
\family typewriter
-k
\family default
 option.
 The TKM expects the key to be a RSA PCKS#1 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

 private key in DER 
\begin_inset CommandInset citation
LatexCommand cite
key "x690-2011-c1"

\end_inset

 encoding and is loaded into the 
\family typewriter
Tkm.Private_Key
\family default
 package where it can be retrieved using a getter function.
 The functionality to load and parse the private key is provided by the
 x509-ada project described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:x509-Ada"

\end_inset

.
\end_layout

\begin_layout Subsection
CA certificate
\end_layout

\begin_layout Standard
To establish assurance in a user certificate provided by a remote peer,
 the trust chain of this certificate must be verified (see the following
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

).
 Hence the TKM needs a trust anchor which is embodied in a certificate authority
 (CA
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CA
\end_layout

\end_inset

).
 Currently the TKM only trusts one CA certificate which can be specified
 on the command line using the 
\family typewriter
-c
\family default
 option.
 The CA certificate in X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 format is loaded into the 
\family typewriter
Tkm.Ca_Cert
\family default
 package using the x509-ada (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:x509-Ada"

\end_inset

) project.
 The 
\family typewriter
Load
\family default
 procedure of the package checks the validity of the CA certificate and
 raises an exception if it is not valid.
\end_layout

\begin_layout Subsection
Authentication
\end_layout

\begin_layout Standard
As dictated by the requirement described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Authentication"

\end_inset

, the authentication process must be performed by the TKM to assure correctness.
 The following sections outline the implemented mechanisms in detail.
\end_layout

\begin_layout Subsubsection
Signature generation
\begin_inset CommandInset label
LatexCommand label
name "sub:Signature-generation"

\end_inset


\end_layout

\begin_layout Standard
The TKM implements the RSASSA-PKCS1-v1_5 signature scheme with appendix
 as specified by RFC 3447 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

, section 8.2.
 The functionality is provided as an Ada generic, allowing the instantiation
 with different hashing algorithms.
 Pre-instantiated instances are provided for SHA-1 and SHA-256 algorithms.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-signature-generation"

\end_inset

 shows how to create a signature using the PKCS#1 private key given on the
 command line.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float=h,language=Ada"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   use X509.Keys;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   package RSA renames Crypto.Rsa_Pkcs1_Sha1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Signer  : RSA.Signer_Type;
\end_layout

\begin_layout Plain Layout

   Privkey : constant RSA_Private_Key_Type 
\end_layout

\begin_layout Plain Layout

      := Private_Key.Get;
\end_layout

\begin_layout Plain Layout

   Chunk   : Tkmrpc.Types.Byte_Sequence (1 ..
 5)
\end_layout

\begin_layout Plain Layout

      := (others => 10);
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   RSA.Init 
\end_layout

\begin_layout Plain Layout

    (Ctx   => Signer,
\end_layout

\begin_layout Plain Layout

     N     => Get_Modulus (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     E     => Get_Pub_Exponent (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     D     => Get_Priv_Exponent (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     P     => Get_Prime_P (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Q     => Get_Prime_Q (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Exp1  => Get_Exponent1 (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Exp2  => Get_Exponent2 (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Coeff => Get_Coefficient (Key => Privkey));
\end_layout

\begin_layout Plain Layout

   declare
\end_layout

\begin_layout Plain Layout

      Sig : constant Tkmrpc.Types.Byte_Sequence
\end_layout

\begin_layout Plain Layout

         := RSA.Generate (Ctx  => Signer,
\end_layout

\begin_layout Plain Layout

                          Data => Octets);
\end_layout

\begin_layout Plain Layout

   begin
\end_layout

\begin_layout Plain Layout

      --  Do something with the signature
\end_layout

\begin_layout Plain Layout

   end;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Signature generation
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-signature-generation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
On line 4 a RSA signer is instantiated.
 Line 5 retrieves the private key stored in the 
\family typewriter
Tkm.Private_Key
\family default
 package and uses the parameters of this key to initialize the RSA signer
 on line 10.
 Finally, on line 21 the signature over the given data chunk is created
 using the 
\family typewriter
Generate
\family default
 procedure of the RSA package.
\end_layout

\begin_layout Standard
The same code is used to create a signature over the local authentication
 octets during the IKE_AUTH exchange (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-IKE_AUTH"

\end_inset

).
 The charon IKEv2 daemon currently only supports AUTH octet signatures based
 on the SHA-1 hash algorithm, this must be improved in a future iteration
 so that other hash algorithms are possible.
\end_layout

\begin_layout Subsubsection
Signature verification
\begin_inset CommandInset label
LatexCommand label
name "sub:Signature-verification"

\end_inset


\end_layout

\begin_layout Standard
Similar to the signature generation outlined in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-generation"

\end_inset

, the TKM provides an Ada generic to verify RSASSA-PKCS1-v1_5 signatures
 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

.
 To perform a verification, a 
\family typewriter
RSA.Verifier_Type
\family default
 must be initialized using a public key extracted from a trusted certificate.
 The process of trust chain verification is explained in detail in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

.
\end_layout

\begin_layout Standard
During the IKE_AUTH exchange, the identity of a remote peer must be asserted.
 This is done by verifying the signature of the authentication octets.
 If the signature validates, the authentication context (AE) of the IKE
 SA in question is set into the 'authenticated' state, meaning that it is
 now possible to establish child SAs (ESA) under this IKE SA (ISA).
\end_layout

\begin_layout Subsubsection
Certificate chain validation
\begin_inset CommandInset label
LatexCommand label
name "sub:Certificate-chain-validation"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-validation-overview"

\end_inset

 provides an overview of the steps performed to establish trust in the user
 certificate provided by a peer during the IKE_AUTH exchange.
 The chosen example involves three certificates: the user certificate 
\emph on
A
\emph default
, the intermediate CA certificate 
\emph on
B
\emph default
 and the trusted 
\emph on
CA
\emph default
.
 The goal of the process is to link the user's X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 certificate 
\emph on
A
\emph default
 to the 
\emph on
CA
\emph default
 trusted by the TKM.
 This is done by verifying the chain of certificate signatures, starting
 at the bottom with the peer certificate 
\emph on
A
\emph default
 and moving upwards to the root of trust, the 
\emph on
CA
\emph default
 certificate.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-overview.svg
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trust chain validation overview
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-validation-overview"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to to this, the user certificate depicted as certificate 
\emph on
A
\emph default
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-validation-overview"

\end_inset

 must be validated using the intermediate CA certificate 
\emph on
B,
\emph default
 and the intermediate certificate 
\emph on
B
\emph default
 must be validated using the trusted 
\emph on
CA
\emph default
 certificate.
 Validation in the context of a certificate trust chain means to perform
 the following steps:
\end_layout

\begin_layout Enumerate
Checking the validity period of the certificate: The current time (
\family typewriter
Now
\family default
) must be within this period as illustrated by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-certificate-validity-check"

\end_inset

.
\end_layout

\begin_layout Enumerate
Verify the signature stored in the certificate by using the public key of
 the subsequent certificate (the issuer certificate).
\end_layout

\begin_layout Enumerate
Perform additional checks as suggested by 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280,GIJABS12,rfc2818"

\end_inset

.
 These checks are not yet implemented in the current state of the project.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float=h,language=Ada"
inline false
status open

\begin_layout Plain Layout

function Is_Valid (V : Validity_Type) return Boolean
\end_layout

\begin_layout Plain Layout

is
\end_layout

\begin_layout Plain Layout

   use Ada.Calendar;
\end_layout

\begin_layout Plain Layout

   Now : constant Time := Clock;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   return V.Not_Before <= Now and then Now <= V.Not_After;
\end_layout

\begin_layout Plain Layout

end Is_Valid;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Certificate validity check
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-certificate-validity-check"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To initiate the trust chain validation process in the TKM, a new CC context
 must be instantiated by calling the 
\family typewriter
Cc_Set_User_Certificate
\family default
 remote procedure call as illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-set-user"

\end_inset

.
 This call stores the user certificate in the CC for which trust must be
 established.
 Before storing the user certificate in the context, the validity is checked.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-set-user.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trust chain set user certificate
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-set-user"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Intermediate CAs and the final CA are added to the CC context by calling
 the 
\family typewriter
Cc_Add_Certificate
\family default
 remote procedure call as shown by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-add-certs"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-add-cert.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trust chain add certificates
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-add-certs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The TKM checks the validity of the intermediate CA (certificate 
\emph on
B
\emph default
 in this example) and performs a signature verification of the signature
 stored in the user certificate 
\emph on
A
\emph default
 using the public key of 
\emph on
B
\emph default
.
 The signature is checked using a RSA verifier as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

.
 If the signature verifies, the intermediate certificate 
\emph on
B
\emph default
 is stored in the context along with the user certificate 
\emph on
A
\emph default
.
\end_layout

\begin_layout Standard
The
\family typewriter
 Cc_Add_Certificate
\family default
 procedure must be called multiple times for all intermediate CAs in the
 trust chain and also for the final root CA.
 The ordering of certificates delivered to the TKM is performed by the charon-tk
m bus listener plugin described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Bus-listener"

\end_inset

.
 If the ordering is incorrect, the verification of the chain fails and the
 IKE SA can not be authenticated.
\end_layout

\begin_layout Standard
The next step is to link the intermediate certificate 
\emph on
B
\emph default
 with the certificate 
\emph on
CA
\emph default
, which is also handed to the trusted part by charon-tkm using 
\family typewriter
Cc_Add_Certificate
\family default
.
 The signature contained in certificate 
\emph on
B
\emph default
 must be validated using the public key stored in the received 
\emph on
CA
\emph default
 certificate.
 If the verification is successful, the last step is to check that the top-level
 certificate matches the trusted root 
\emph on
CA
\emph default
, this is done by calling the 
\family typewriter
Cc_Check_Ca
\family default
 RPC as shown by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-check-ca"

\end_inset

.
 The last certificate added by the 
\family typewriter
Cc_Add_Certificate
\family default
 must be bit-wise identical to the CA trusted by the TKM.
 If this check succeeds, the CC context is set into the 'checked' state
 and the context can be used to verify signatures as explained in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-check-ca.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trust chain check CA
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-check-ca"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Kernel SPD/SAD management
\end_layout

\begin_layout Standard
Since the Linux kernel stores sensitive keying material in its security-associat
ion database, the untrusted part is not allowed to access these databases.
 This must be assured by security mechanisms which are outside of the scope
 of this document.
 But as a result, the TKM must manage the kernel's security-policy (SPD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SPD
\end_layout

\end_inset

) and security-association (SAD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) databases itself.
\end_layout

\begin_layout Standard
The xfrm-ada project (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

), which has been developed during this TKM project, is used to install
 security policies on TKM startup and also to manage SA states.
\end_layout

\begin_layout Section
xfrm-proxy
\begin_inset CommandInset label
LatexCommand label
name "sec:xfrm-proxy"

\end_inset


\end_layout

\begin_layout Standard
The xfrm-proxy component uses the xfrm-ada library (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

) to communicate with charon's EES service (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

).
 See figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:XFRM-proxy-architecture"

\end_inset

 for an overview of the proxy architecture.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/xfrm-proxy-arch.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
XFRM proxy architecture
\begin_inset CommandInset label
LatexCommand label
name "fig:XFRM-proxy-architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As stated before, the kernel stores critical IPsec policies and SA states,
 therefore the charon daemon is no longer allowed to communicate with the
 kernel XFRM subsystem.
 
\end_layout

\begin_layout Standard
To make rekeying work in such a scenario, kernel XFRM acquire and expire
 messages must be delivered to charon by other means.
 The xfrm-proxy component subscribes to the kernel's XFRM subsystem acquire
 and expire multicast groups to receive events and delivers them to charon
 using the EES service.
 Charon then starts create or rekeying jobs for the IPsec policy or SA in
 question as usual.
\end_layout

\begin_layout Section
Additional components
\begin_inset CommandInset label
LatexCommand label
name "sec:Additional-components"

\end_inset


\end_layout

\begin_layout Standard
Certain functionality which was needed for the implementation of the TKM
 has been realized in self-contained software projects or as extension to
 existing libraries.
\end_layout

\begin_layout Subsection
Anet
\begin_inset CommandInset label
LatexCommand label
name "sub:Anet"

\end_inset


\end_layout

\begin_layout Standard
Anet is a networking library for the Ada programming language.
 It is used by the trusted key manager and xfrm-proxy to open or connect
 to Unix sockets and communicate with charon-tkm.
\end_layout

\begin_layout Standard
Anet has been released as open-source software under the GMGPL
\begin_inset Foot
status open

\begin_layout Plain Layout
GNAT Modified General Public License
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
GMGPL
\end_layout

\end_inset

 license and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=anet.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
xfrm-ada
\begin_inset CommandInset label
LatexCommand label
name "sub:xfrm-ada"

\end_inset


\end_layout

\begin_layout Standard
This project is an Ada binding to Linux's XFRM
\begin_inset Index idx
status open

\begin_layout Plain Layout
XFRM
\end_layout

\end_inset

 kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.kernel.org/
\end_layout

\end_inset


\end_layout

\end_inset

 interface.
 It provides the functionality required to add and delete XFRM policies
 and states.
\end_layout

\begin_layout Standard
The XFRM framework is used to manage the IPsec
\begin_inset Index idx
status open

\begin_layout Plain Layout
IPsec
\end_layout

\end_inset

 protocol suite in the Linux kernel.
 The XFRM states operate on the Security Association Database (SAD
\begin_inset Index idx
status open

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) and the XFRM policies operate on the Security Policy Database (SPD
\begin_inset Index idx
status open

\begin_layout Plain Layout
SPD
\end_layout

\end_inset

).
 Among other features, it provides ESP
\begin_inset Index idx
status open

\begin_layout Plain Layout
ESP
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4303"

\end_inset

 payload encryption with the key material provided by an userspace application.
\end_layout

\begin_layout Standard
The TKM uses the XFRM interface via the xfrm-ada library to manage the SPD
 and SAD and provide keys for ESP encryption to the kernel.
\end_layout

\begin_layout Standard
xfrm-ada has been released as open-source software under the GMGPL license
 and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=xfrm-ada.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
x509-Ada
\begin_inset CommandInset label
LatexCommand label
name "sub:x509-Ada"

\end_inset


\end_layout

\begin_layout Standard
This project is an Ada PKIX X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 library.
 It provides functionality to process ASN.1/DER-encoded 
\begin_inset CommandInset citation
LatexCommand cite
key "x680-2011-c1,x690-2011-c1"

\end_inset

 certificates and private keys.
\end_layout

\begin_layout Standard
x509-Ada has been released as open-source software under the GMGPL license
 and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=x509-ada.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Limitations
\begin_inset CommandInset label
LatexCommand label
name "sec:Limitations"

\end_inset


\end_layout

\begin_layout Standard
This section describes the limitations of the current realization of the
 design outlined in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Design"

\end_inset

.
 The main reason for these limitations is the lack of time to fully implement
 the envisioned functionality and are not due to inadequate or deficient
 design.
\end_layout

\begin_layout Subsection
Cryptographic algorithms
\end_layout

\begin_layout Standard
Currently only a selected set of algorithms are implemented.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Implemented-cryptographic-algori"

\end_inset

 lists the implemented cryptographic transforms:
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="right" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Usage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Algorithm name
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
IANA ID
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Authentication method
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RSA-PKCS1-SHA1
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Certificate chain verification
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
RSA-PKCS1-SHA256
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encryption Algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AES-256-CBC
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pseudo-random Function
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HMAC-SHA512
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integrity Algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HMAC-SHA512
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
14
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Diffie-Hellman
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3072-bit MODP Group
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Diffie-Hellman
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4096-bit MODP Group
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Implemented cryptographic algorithms
\begin_inset CommandInset label
LatexCommand label
name "tab:Implemented-cryptographic-algori"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There is no inherent limitation of usable cryptographic transforms, it is
 simply a question of implementing the desired methods.
 Algorithm agility is ensured by the design through the use of numeric algorithm
 identifiers and avoidance of hardcoded cryptographic mechanisms.
\end_layout

\begin_layout Subsection
Identity handling
\end_layout

\begin_layout Standard
The local and peer identities are currently limited to specific, hardcoded
 identities.
 The peer subject name must be 
\begin_inset Quotes eld
\end_inset

bob@strongswan.org
\begin_inset Quotes erd
\end_inset

 and the local subject name must be 
\begin_inset Quotes eld
\end_inset

alice@strongswan.org
\begin_inset Quotes erd
\end_inset

.
 This is caused by the static configurability of the TKM daemon and the
 current private key handling of charon.
 In order to allow the use of arbitrary identities the configuration mechanism
 of TKM and charon-tkm needs to be fully implemented and a TKM credential
 set must be implemented.
\end_layout

\begin_layout Subsection
Certificates and keys
\end_layout

\begin_layout Standard
Currently only a single CA certificate is supported for certificate chain
 validation.
 Similarly only one private key is supported for authenticating the local
 identity to the peer.
 Akin to the constraints with regards to identity handling, the cause for
 this is also the incomplete implementation of the configuration interface.
\end_layout

\begin_layout Standard
Additionally the currently implemented validity checks of certificates are
 only rudimentary.
 
\end_layout

\begin_layout Subsection
Certificate chain context reuse
\end_layout

\begin_layout Standard
A certificate chain that has been verified, is potentially usable until
 the end of its validity period.
 Currently this fact is disregarded and verified certificate chain contexts
 are not reused and must be constructed anew when authenticating a peer.
\end_layout

\begin_layout Subsection
Source of randomness
\end_layout

\begin_layout Standard
The nonce generation in the TKM is implemented by reading a sequence of
 bytes from Linux's random device node 
\family typewriter
/dev/urandom
\family default
.
 The source of the random data is currently not configurable.
 This may not be regarded as a limitation per-se but because the issue of
 random number generation is paramount to any system constructing cryptographic
 keys the authors feel compelled to explicitly mention it.
\end_layout

\begin_layout Subsection
Exception mapping
\end_layout

\begin_layout Standard
If a processing error on the server-side occurs the status code of the reply
 message is always set to Invalid_Operation.
 To provide the client with more specific information about the error exceptions
 should be inspected and mapped to their corresponding failure code.
\end_layout

\begin_layout Section
Conformance to requirements
\begin_inset Argument
status open

\begin_layout Plain Layout
Conformance
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This section describes how the implementation meets the design requirements
 defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Itemize
The requirement 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-TCB-robustness"

\end_inset

 demands that code running in the TCB must be as minimal and robust as possible.
 This has been addressed by applying the following measures:
\end_layout

\begin_deeper
\begin_layout Itemize
Use of the Ada programming language and avoidance of problematic language
 constructs (like type extensions, dynamic memory allocation etc.).
\end_layout

\begin_layout Itemize
Use of agile development methods, i.e.
 test-driven development (TDD), pair programming and code reviews.
\end_layout

\begin_layout Itemize
Automatic generation of interface code from XML specification, avoiding
 implementation errors by verifying the generated code.
\end_layout

\begin_layout Itemize
Use of Ada 2012 contracts to confine generated context state machine code.
\end_layout

\end_deeper
\begin_layout Itemize
The separation and communication requirements 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Communication"

\end_inset

 demand that the untrusted and trusted parts of the system are separated
 and communication is only possible over a well-defined, minimal interface.
 These requirements are guaranteed by automatically creating the interface
 code from an XML-specification as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:XML-Specification"

\end_inset

 and by using a simple library providing RPC services by exporting the generated
 interface over Unix domain sockets (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

).
\end_layout

\begin_layout Itemize
Requirements 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation-of-key"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Cryptographic-operations"

\end_inset

 require that the untrusted part must not have access to critical keying
 material and that the cryptographic operations using this material must
 be implemented in the TCB to guarantee proper operation.
 These requirements are fulfilled in the design by implementing plugins
 which act as proxy objects between the untrusted charon-tkm daemon and
 the TKM.
 These plugins operate with references to the real, sensitive data and are
 kept very simple.
 No sensitive data leaves the TCB.
 This directly demands that critical cryptographic operations used to either
 create sensitive material or operating on sensitive material must be implemente
d in the TCB as well.
 The following TKM-specific strongSwan plugins are responsible to achieve
 the desired degree of separation:
\end_layout

\begin_deeper
\begin_layout Itemize
Nonce generation plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Nonce-generation"

\end_inset

)
\end_layout

\begin_layout Itemize
DH plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Diffie-Hellman"

\end_inset

)
\end_layout

\begin_layout Itemize
Keymat plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Keymat"

\end_inset

)
\end_layout

\begin_layout Itemize
Kernel IPsec plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:pluginKernel-IPsec"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Requirement 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Authentication"

\end_inset

 requires that the TCB must enforce proper authentication.
 The system supports strong authentication methods based on public-key cryptogra
phy only.
 The secret private key required to create valid signatures and the trusted
 CA certificate used to verify the peer's authentication data must reside
 in the TCB.
 To make this separation possible, the following TKM-specific strongSwan
 plugins are implemented:
\end_layout

\begin_deeper
\begin_layout Itemize
Private key plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Private-key"

\end_inset

)
\end_layout

\begin_layout Itemize
Public key plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Public-key"

\end_inset

)
\end_layout

\begin_layout Itemize
Bus listener plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Bus-listener"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Requirement 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Integrity"

\end_inset

 demands that a misbehaving untrusted part is not able to violate the security
 properties guaranteed by the TCB.
 As a formal analysis of the proposed IKEv2 separation protocol has not
 been performed, this property is only assumed but not formally proven,
 see also section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
This chapter provides a summary of the contributions and an outlook on possible
 future work.
\end_layout

\begin_layout Section
Contributions
\end_layout

\begin_layout Standard
This section discusses the main results of this work which are the analysis
 and splitting of the IKE protocol and demonstrating the viability of the
 concept through the prototypical implementation of the envisioned system.
\end_layout

\begin_layout Subsection
IKE protocol split
\end_layout

\begin_layout Standard
After formulating desired security properties and identifying the critical
 components of the IKE protocol a concept to split the key management system
 into an untrusted and trusted part has been proposed.
 Care was taken to only extract the functionality that is absolutely necessary
 from the untrusted IKE processing.
 Thus, the presented interface between IKE and TKM facilitates the implementatio
n of a small and robust trusted component.
 This interface has been specified in an XML document which is used as a
 basis for the implementation.
\end_layout

\begin_layout Standard
The splitting of the protocol guarantees that even if the untrusted side
 is completely subverted by an attacker the TCB upholds the proposed security
 goals.
\end_layout

\begin_layout Subsection
Prototype implementation
\end_layout

\begin_layout Standard
The IKEv2 separation design proposed in this paper has been implemented
 and demonstrated to be a viable solution to attain a higher level of security.
 The untrusted parts of the IKE daemon are implemented on top of the existing
 strongSwan IKE implementation while the trusted components have been implemente
d from scratch using the Ada programming language.
\end_layout

\begin_layout Standard
Leveraging the XML specification of the interface and using it to automatically
 generate code for the IKE and TKM, errors in the transformation process
 from the specification to the code are avoided.
 This mechanism enables changes to the interface at a low cost with a significan
tly smaller potential for errors compared to a manual translation of the
 specification into code.
 Since the implementation spans multiple programming languages (Ada and
 C) this takes even more burden off the implementor.
\end_layout

\begin_layout Standard
Generating Ada 2012 contracts from the specification of the code used in
 the TCB, the conformance of these parts of the TKM implementation are checked
 against the specification at runtime.
 Additionally these checks can also be formally verified by the GNATprove
 tool (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:XML-Specification"

\end_inset

).
\end_layout

\begin_layout Section
Future work
\end_layout

\begin_layout Standard
This section outlines planned and possible future steps to improve upon
 the foundation of the current TKM implementation.
 In the first part of this section concrete work items are discussed which
 are planned to be implemented soon.
 These steps directly address the limitations presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
\end_layout

\begin_layout Standard
The latter part discusses broader issues which aim to address the correct
 enforcement of assumptions formulated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Assumptions"

\end_inset

.
\end_layout

\begin_layout Subsection
Credential set
\end_layout

\begin_layout Standard
The private key handling of charon-tkm must be extended with a TKM specific
 credential set to allow the usage of private keys with different subject
 than alice@strongswan.org.
 The set should provide an own implementation of a private key enumeration
 function (
\family typewriter
create_private_enumerator
\family default
 of 
\family typewriter
credential_set_t
\family default
).
 This way a configured private key could be fetched and installed in the
 credential manager on demand.
\end_layout

\begin_layout Subsection
Exception mapping
\end_layout

\begin_layout Standard
As described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Error-handling"

\end_inset

, exceptions which are raised during processing of a client request are
 handled by the Process_Stream generic.
 Exceptions should be mapped to their corresponding failure code (see 
\family typewriter
result_type
\family default
 constants specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Constants"

\end_inset

) and the status code of the response set accordingly.
 This gives the client more information about what kind of processing error
 occurred.
\end_layout

\begin_layout Subsection
Additional checks for generated key material
\end_layout

\begin_layout Standard
The sanity checks for generated Diffie-Hellman values and cryptographic
 keys should be augmented to avoid the usage of problematic key material
 undermining the employed encryption or integrity protection mechanisms.
\end_layout

\begin_layout Subsection
Validation of certificates
\end_layout

\begin_layout Standard
Additional checks outlined in 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280,GIJABS12,rfc2818"

\end_inset

 must be implemented to more accurately verify the validity of certificates
 and certificate chains.
\end_layout

\begin_layout Subsection
Configuration subsystem
\end_layout

\begin_layout Standard
Most deficiencies enumerated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

 can be rectified by making the current implementation more dynamically
 configurable.
 This would allow the usage of TKM in many more scenarios which would considerab
ly broaden the applicability of the presented solution.
 It is expected that this will be implemented in the near future.
\end_layout

\begin_layout Subsection
Automated tests
\end_layout

\begin_layout Standard
Even though the whole TKM system has been developed following the test-driven
 development
\begin_inset Index idx
status open

\begin_layout Plain Layout
TDD
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
TDD is a software development process which employs on short development
 cycles with a focus on writing good unit tests.
\end_layout

\end_inset

 methodology, no automated integration test suit has been built.
 This was partly because the system is built-up by many different components
 and partly because of some deficiencies in the current testing framework
 of strongSwan, which impeded the addition of automated test cases.
\end_layout

\begin_layout Standard
In the meantime the infrastructure for the automated test of strongSwan
 has been improved.
 Once these changes are finalized, TKM-specific test cases will be added
 to allow the automated and reproducible testing of the whole TKM system.
 This ensures that changes to parts of the system are detectable and clearly
 indicated by failing tests.
\end_layout

\begin_layout Subsection
Cryptanalytic review
\end_layout

\begin_layout Standard
A formal and rigorous cryptographic analysis of the 
\begin_inset Quotes eld
\end_inset

Splitting
\begin_inset Quotes erd
\end_inset

 and the communication between IKE and TKM is highly desirable.
 It is assumed that an adversary cannot somehow obtain or deduce key material
 or other sensitive information (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

) either using the data freely available to IKE or performing exchanges
 as specified by the interface to extract additional information from the
 TKM.
 Furthermore Man-in-the-Middle attacks must also be prevented.
\end_layout

\begin_layout Standard
In this context, a critical operation is the 
\family typewriter
isa_sign
\family default
 exchange specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsub:Exchanges-isa-sign"

\end_inset

, since it is used to sign data (authentication octets) with a private key
 to assert the local identity to the peer.
 Parts of the input data for the signature are private to the TKM while
 other elements are fixed but known to the untrusted side.
 Yet another portion of the input can be chosen arbitrarily by an adversary
 assuming the role of IKE.
\end_layout

\begin_layout Standard
By repeatedly performing the aforementioned 
\family typewriter
isa_sign
\family default
 exchange a malicious entity can abuse the TKM as a random oracle and mount
 an 
\shape italic
adaptive chosen-plaintext attack
\shape default
.
 Employing a signature algorithm which is resistant against such attacks
 should ensure the desired security properties but since a successful attack
 would nullify the security properties of the TKM system this issue must
 be analyzed with great care.
\end_layout

\begin_layout Subsection
Platform integration
\begin_inset CommandInset label
LatexCommand label
name "sub:Platform-integration"

\end_inset


\end_layout

\begin_layout Standard
The basic premise for the extraction of security critical functionality
 into a TCB is, as stated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:TCB-security-properties"

\end_inset

, that the untrusted charon-tkm daemon can only interact with the trusted
 TKM using the exchanges specified in the interface description (see section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-Exchanges"

\end_inset

).
 For high assurance systems, the process isolation mechanism of a standard
 Linux system is not adequate and does not provide the necessary level of
 separation, as was already mentioned in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Assumptions"

\end_inset

.
 Additionally, in an ordinary operating system the amount of code that has
 to be counted to the trusted computing base is in the range of hundred
 thousand or possibly even millions of lines of code.
 This stands in stark contrast to the demand that the TCB should be 
\shape italic
minimal
\shape default
.
\end_layout

\begin_layout Standard
Integrating the implemented system into an environment that offers superior
 isolation mechanisms and a smaller TCB size is thus a requirement to actually
 attain a higher level of security.
 Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Possible-target-IKE/TKM"

\end_inset

 lists potential technologies or mechanisms which could be used to complement
 the separated IKE system.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Complexity
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Reference
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Physical separation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
none
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linux Containers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://lxc.sourceforge.net/
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SELinux
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://selinuxproject.org/
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Separation Kernel
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
+++
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand cite
key "Rushby:1981:DVS:1067627.806586"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Possible target IKE/TKM platforms
\begin_inset CommandInset label
LatexCommand label
name "tab:Possible-target-IKE/TKM"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Putting charon-tkm and the TKM daemon on physically distinct hosts is appealing
 because it is apparent, that charon-tkm and TKM can only exchange information
 via the intended communication channels.
 Additionally, such a system is expected to be fairly straight forward to
 implement thanks to the transport layer abstraction in the tkm-rpc library
 described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transport-mechanism-abstraction"

\end_inset

.
 The need for additional hardware is a major drawback.
\end_layout

\begin_layout Standard
The same level of separation could be achieved by porting the charon-tkm
 and TKM daemon components to a separation kernel (SK).
 Unfortunately there are no freely available SKs ath te time of this writing.
 Some commercial products exist but they are only available to paying customers.
\end_layout

\begin_layout Standard
Linux containers and SELinux are another possible solution to secure the
 trusted from the untrusted part.
 The degree of isolation they offer might be enough for certain usage scenarios.
 Using these mechanisms would however not address the issue of having a
 large TCB.
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "ike-separation"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
