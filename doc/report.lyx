#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{tabu,longtable}
\usepackage{booktabs}
\usepackage{ifthen}

\definecolor{newyellow}{rgb}{1,1,0.8}
\definecolor{colKeys}{rgb}{0,0,1}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{1,0,0}
\definecolor{colString}{rgb}{0,0.5,0}

\newenvironment{typedefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}r>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Size & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{vartypedefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}r>{\tt}r>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Data & \sf\bf Size & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{constantdefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}l>{\it}X}
\caption{#1} \\
\toprule\sf\bf Name & \sf\bf Hexvalue & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{contextstates}[1]
{\begin{longtabu} to \textwidth{>{\tt}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{contexttransitions}[1]
{\tabulinesep=4pt
\begin{longtabu} to \textwidth{>{\tt}lp{2.5cm}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Source  & \sf\bf Target & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{exchangeparameters}[1]
{\begin{longtabu} to \textwidth{>{\tt}l>{\tt}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Type & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{messages}{\bigskip
\begin{tabu} to \textwidth{l>{\tt}c>{\tt}ccc>{\it}X}}
{\end{tabu}\bigskip}
\newcommand{\msg}[4]{\ifthenelse{\equal{#1}{}}{}{#1\quad }
& \texttt{#2}
& \ifthenelse{\equal{#3}{}}{}{$\rightarrow$}
& \texttt{#3}
& \ifthenelse{\equal{#3}{}}{}{\ :\quad}
& \it{#4}\\}
\newcommand{\hex}[1]{\textrm{0x#1}}
\newcommand{\subscript}[1]{\ensuremath{_{\textrm{#1}}}}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "IKE Separation"
\pdf_author "Reto Buerki, Adrian-Ken Rüegsegger"
\pdf_subject "Extraction of security critical components into a Trusted Computing Base (TCB)"
\pdf_keywords "Separation, TCB, IPsec, IKE, IKEv2, Security, Ada"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\listings_params "backgroundcolor={\color{newyellow}},basicstyle={\ttfamily\small},breakautoindent=true,breaklines=true,captionpos=b,commentstyle={\color{colComments}},extendedchars=true,frame=single,identifierstyle={\color{colIdentifier}},keywordstyle={\color{colKeys}},language=Ada,numbers=left,numberstyle={\tiny},showspaces=false,showstringspaces=false,stringstyle={\color{colString}},tabsize=4"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
IKEv2 Separation:
\begin_inset Newline newline
\end_inset

Extraction of security critical components into a Trusted Computing Base
 (TCB)
\end_layout

\begin_layout Author
Reto Bürki, Adrian-Ken Rüegsegger
\end_layout

\begin_layout Standard
\align center
University of Applied Sciences Rapperswil (HSR), Switzerland
\end_layout

\begin_layout Abstract
The IPsec protocol relies on the correct operation of the IKE key exchange
 to meet its security goals.
 The implementation of the IKEv2 protocol is a non-trivial task and results
 in a large and complex code base.
 This makes it hard to gain a high degree of confidence in the correct operation
 of the code.
\end_layout

\begin_layout Abstract
The security and robustness of the IKEv2 implementation strongSwan has been
 augmented, by identifying and separating security critical from non-critical
 components and separating them into a minimal TCB.
 The TCB has been implemented using the Ada programming language.
\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
In a system with high requirements on security, functions relevant to guarantee
 these requirements must be isolated from the rest of the system in a Trusted
 Computing Base (TCB)
\begin_inset Index idx
status open

\begin_layout Plain Layout
TCB
\end_layout

\end_inset

.
 To be trusted, this code must be as minimal as possible to allow formal
 verification of code correctness.
 Lampson et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Lampson:1991:ADS:121133.121160"

\end_inset

 define the TCB of a computer system as:
\end_layout

\begin_layout Quote
A small amount of software and hardware that security depends on and that
 we distinguish from a much larger amount that can misbehave without affecting
 security.
\end_layout

\begin_layout Standard
It is much easier to design a system from scratch with separation properties
 in mind than separating an existing project or protocol later.
 But this is not always possible, or even more important, not intended.
 Functionality in an existing system identified as uncritical should be
 left as is, if possible.
\end_layout

\begin_layout Standard
In order to isolate functionality in a TCB, critical sections of existing
 systems must be identified and they must be separated into a critical (trusted)
 and non-critical (untrusted) part.
 Communication mechanisms between the sections must be established, which
 itself must be robust and well defined.
 If an attacker is able to compromise the untrusted-part of the system,
 the security and integrity functions guaranteed by the TCB must still hold.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Trusted-Computing-Base"

\end_inset

 depicts an example system involving a TCB.
 Components colored in red specify trusted components inside the TCB.
 The TCB normally consists of multiple such components which implement different
, separated functionality.
 One or more untrusted components colored in black exchange data with the
 TCB over a well-defined interface.
 This coloring scheme is used throughout this document to label untrusted
 and untrusted components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trusted-untrusted.svg
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Trusted Computing Base
\begin_inset CommandInset label
LatexCommand label
name "fig:Trusted-Computing-Base"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Synopsis
\end_layout

\begin_layout Standard
This section provides an introduction into the terminology and systems used
 in this project and explains the basic key concepts.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:ipsec-IKEv2"

\end_inset

 briefly outlines IPsec and the IKEv2 protocol, section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:strongSwan"

\end_inset

 introduces an implementation of this protocol in the form of the strongSwan
\begin_inset Index idx
status open

\begin_layout Plain Layout
strongSwan
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.strongswan.org/
\end_layout

\end_inset


\end_layout

\end_inset

 project.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ada"

\end_inset

 summarizes the most important aspects of the Ada programming language which
 is used to implement the Trusted Key Manager (TKM) specified by this paper.
 The term TKM is explained in the following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Trusted-Key-Manager"

\end_inset

.
\end_layout

\begin_layout Subsection
IPsec and IKEv2
\begin_inset CommandInset label
LatexCommand label
name "sub:ipsec-IKEv2"

\end_inset


\end_layout

\begin_layout Standard
Internet Protocol Security (IPsec
\begin_inset Index idx
status open

\begin_layout Plain Layout
IPsec
\end_layout

\end_inset

) provides, as the name implies, security services to the Internet Protocol
 (IP
\begin_inset Index idx
status open

\begin_layout Plain Layout
IP
\end_layout

\end_inset

).
 This is done by encrypting and authenticating IP packets of communication
 sessions.
 The protection is transparent to the communicating applications because
 it is performed by the IP layer.
 To protect IP packets, cryptographic transforms are applied to them which
 in turn require cryptographic keys.
 The bundle of algorithms and data that provide the parameters necessary
 to operate these cryptographic transforms are called a security association
 (SA).
 Parameters and keys needed to establish an SA are normally provided to
 the IPsec protocol suite by means of the Internet Key Exchange (IKE
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE
\end_layout

\end_inset

) protocol.
 For more information on the IPsec protocol suites, the reader is directed
 to the corresponding 
\emph on

\begin_inset Quotes eld
\end_inset

Security Architecture for the Internet Protocol
\begin_inset Quotes erd
\end_inset

 
\emph default
RFC 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4301"

\end_inset

.
\end_layout

\begin_layout Standard
The IKE
\begin_inset Foot
status open

\begin_layout Plain Layout
Internet Key Exchange
\end_layout

\end_inset

 protocol is used within IPsec to establish a security association (SA).
 It is responsible for the key establishment phase and the negotiation of
 the cryptographic algorithms between communicating endpoints.
 There are two versions of the IKE protocol: IKEv1
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv1
\end_layout

\end_inset

 and IKEv2 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc2409,rfc5996"

\end_inset

.
 IKEv2
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv2
\end_layout

\end_inset

 was designed to add new features and correct some problems found in the
 previous version.
 This project exclusively targets the newer IKEv2 protocol, IKEv1 is not
 considered.
\end_layout

\begin_layout Standard
To negotiate cryptographic keys and corresponding parameters, the peers
 exchange message request, response pairs as described in detail in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKEv2-protocol-analysis"

\end_inset

.
 TODO: explain more details here? AUTH etc...
 The service implementing the IKE protocol is normally provided by a user
 space application like strongSwan's charon daemon as described in the following
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:strongSwan"

\end_inset

.
\end_layout

\begin_layout Subsection
strongSwan
\begin_inset Index idx
status open

\begin_layout Plain Layout
strongSwan
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:strongSwan"

\end_inset


\end_layout

\begin_layout Standard
The strongSwan project is an OpenSource IPsec-based VPN solution for Unix-like
 operating systems.
 It provides the charon
\begin_inset Index idx
status open

\begin_layout Plain Layout
charon
\end_layout

\end_inset

 daemon, which is a feature-rich implementation of the Internet key exchange
 protocol version 2 (IKEv2
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv2
\end_layout

\end_inset

) as specified in 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
 The software is implemented using the C
\begin_inset Index idx
status open

\begin_layout Plain Layout
C
\end_layout

\end_inset

 programming language with an object oriented (OO) approach.
 This allows to emulate modern programming paradigms while still using a
 standard C compiler and tool set
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://wiki.strongswan.org/projects/strongswan/wiki/ObjectOrientedC
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The strongSwan architecture is very flexible and easy to extend with new
 features.
 Almost every part of the daemon works as a plugin
\begin_inset Index idx
status open

\begin_layout Plain Layout
Plugin
\end_layout

\end_inset

 and new functionality can be added by simply writing a new plugin.
 This architecture proved very helpful in this present project, as very
 few changes were required in the upstream strongSwan code to implement
 the Trusted Key Manager (TKM
\begin_inset Index idx
status open

\begin_layout Plain Layout
TKM
\end_layout

\end_inset

, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Trusted-Key-Manager"

\end_inset

) architecture.
\end_layout

\begin_layout Subsection
Ada
\begin_inset CommandInset label
LatexCommand label
name "sub:Ada"

\end_inset


\end_layout

\begin_layout Standard
Ada
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada
\end_layout

\end_inset

 is a structured, strongly typed programming language.
 The language has initially been designed by Jean Ichbiah from Honeywell
 Bull in the 1970s.
 Ada has a very similar structure to Pascal
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pascal
\end_layout

\end_inset

 and is often used for systems with a demand for security and integrity
 or which have a huge code base.
\end_layout

\begin_layout Standard
The development of Ada was initiated by the US Department of Defense (DoD
\begin_inset Index idx
status open

\begin_layout Plain Layout
DoD
\end_layout

\end_inset

) in order to consolidate and supersede the hundreds of programming languages
 used in their countless projects.
 The new language should comply with all identified DoD requirements (dubbed
 
\begin_inset Quotes eld
\end_inset

Steelman Language Requirements
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Steelman78"

\end_inset

), which focused strongly on security and safety.
 
\end_layout

\begin_layout Standard
Ada was the first standardized high-level programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "Ada83"

\end_inset

.
 The current version is Ada 2005
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada 2005
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/sp/Ada2006"

\end_inset

 which supports all modern programming pa\SpecialChar \-
ra\SpecialChar \-
digms.
 The next major version of the language is planned to be complete in 2012
 and will naturally be called Ada 2012
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada 2012
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Ada compilers, before used in practice, have to pass a standardized test
 suite which guarantees the compliance of the compiler with the Ada standard.
 Since Ada provides many features which aid in the development of safety
 and security critical applications, it is nowadays mostly used in such
 areas where these aspects are important.
 The primary industries making use of Ada are namely avionics, railway systems,
 banking, military and space technology.
\end_layout

\begin_layout Standard
The language is named after Lady Ada Lovelace (1815-1852), the daughter
 of Lord Byron
\begin_inset Foot
status open

\begin_layout Plain Layout
Ada Lovelace - http://en.wikipedia.org/wiki/Ada_Lovelace
\end_layout

\end_inset

 who is considered to be the first computer programmer.
\end_layout

\begin_layout Subsection
Trusted Key Manager
\begin_inset CommandInset label
LatexCommand label
name "sub:Trusted-Key-Manager"

\end_inset


\end_layout

\begin_layout Standard
The Trusted Key Manager
\begin_inset Index idx
status open

\begin_layout Plain Layout
Trusted Key Manager
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
TKM
\end_layout

\end_inset

 is a minimal TCB developed during this project which implements the identified
 security-critical functions of the IKEv2 protocol using the Ada programming
 language.
 It uses the tkm-rpc
\begin_inset Index idx
status open

\begin_layout Plain Layout
tkm-rpc
\end_layout

\end_inset

 library to communicate with the strongSwan charon daemon.
 The tkm-rpc library is also written in Ada, see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

.
\end_layout

\begin_layout Section
Related work
\begin_inset CommandInset label
LatexCommand label
name "sub:Related-work"

\end_inset


\end_layout

\begin_layout Standard
The concept of separating larger systems into smaller, trusted parts dates
 back to John Rushby in 1981 
\begin_inset CommandInset citation
LatexCommand cite
key "Rushby:1981:DVS:1067627.806586"

\end_inset

.
 The most prominent implementations of the concept exist in the form of
 microkernels
\begin_inset Index idx
status open

\begin_layout Plain Layout
Microkernel
\end_layout

\end_inset

 (µ-kernels), which provide the foundation to separate functionality into
 smaller, separated parts by providing compartments for subjects running
 in userspace.
 Examples of such systems are Fiasco
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://os.inf.tu-dresden.de/fiasco/
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Fiasco
\end_layout

\end_inset

, L4Ka::Pistachio
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.l4ka.org/65.php
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
L4Ka::Pistachio
\end_layout

\end_inset

 and Coyotos
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.coyotos.org/
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
Coyotos
\end_layout

\end_inset

.
 Type-1 (bare-metal) hypervisors
\begin_inset Index idx
status open

\begin_layout Plain Layout
Hypervisor
\end_layout

\end_inset

 like Xen are intentionally excluded from the list because Xen requires
 a complete Linux kernel (dom0) with direct access to hardware to work.
 The fact that the dom0 kernel must be accounted as part of the trusted
 system makes it unsuitable for in-depth review and therefore unusable as
 a TCB.
\end_layout

\begin_layout Standard
Even though the concept proposed by Rushby offers many advantages related
 to security and integrity, it has not been widely realized.
 Common operating systems like Windows
\begin_inset Index idx
status open

\begin_layout Plain Layout
Windows
\end_layout

\end_inset

, Linux
\begin_inset Index idx
status open

\begin_layout Plain Layout
Linux
\end_layout

\end_inset

 and *BSD
\begin_inset Index idx
status open

\begin_layout Plain Layout
BSD
\end_layout

\end_inset

 variants use a monolithic
\begin_inset Index idx
status open

\begin_layout Plain Layout
monolithic
\end_layout

\end_inset

 kernel, which itself must be trusted as a whole, even though the compromise
 of a device driver can corrupt the complete system.
\end_layout

\begin_layout Standard
One reason seems to be the tremendous effort needed to adapt existing software
 to a separation concept.
 In order to move critical parts into a TCB, the existing code must be studied
 and sensitive parts re-implemented using the corresponding APIs and methods
 of the underlying separation platform.
 Of course, the complete system could be rewritten for the dedicated secure
 environment, but often this is not possible and especially not desired
 for code deemed as untrusted.
 The dedicated goal is to only re-implement sensitive parts while leaving
 the untrusted part mostly untouched.
\end_layout

\begin_layout Standard
Research has been done in the formal analysis of the IKEv1
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv1
\end_layout

\end_inset

 and IKEv2
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv2
\end_layout

\end_inset

 protocols 
\begin_inset CommandInset citation
LatexCommand cite
key "Cremers:2011:KEI:2041225.2041249,DBLP:conf/sp/Meadows99"

\end_inset

, pointing out weaknesses in both standards.
 The separation of the sensitive part from the bulk of the IKE protocol
 seems to be a valuable effort to minimize the working surface of attacks.
 Nevertheless, the IKEv2 separation protocol described in this paper must
 still undergo the same formal verification as the original protocols to
 formally show the delivered security improvements compared to its monolithic
 ancestor.
\end_layout

\begin_layout Section
Threat model
\begin_inset CommandInset label
LatexCommand label
name "sub:Threat-model"

\end_inset


\end_layout

\begin_layout Standard
An example system separated in a trusted and untrusted component is shown
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Trusted-Computing-Base"

\end_inset

 on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "fig:Trusted-Computing-Base"

\end_inset

.
 This section describes the thread model used during the development of
 this project.
\end_layout

\begin_layout Standard
It is assumed that the strongSwan charon IKEv2 daemon, which is considered
 an untrusted software component in the designed architecture, is under
 complete control of the attacker
\begin_inset Index idx
status open

\begin_layout Plain Layout
Attacker
\end_layout

\end_inset

.
 This means the attacker has complete access to all data available to the
 IKEv2 daemon and can execute arbitrary code with the privileges of charon
\begin_inset Index idx
status open

\begin_layout Plain Layout
charon
\end_layout

\end_inset

.
 As a result of this assumption, charon is not allowed to have access to
 any sensitive data.
 Also, intermediate values which are needed to create critical values must
 be protected from access by untrusted components.
 The following list summarizes the capabilities of an attacker in the model
 used:
\end_layout

\begin_layout Enumerate
The attacker is also able to analyze network traffic leaving the system.
 
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:thread-model-2"

\end_inset

The attacker is able to compromise the untrusted IKE daemon and read all
 its memory
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:thread-model-3"

\end_inset

As a result of point 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:thread-model-2"

\end_inset

, the attacker knows everything the IKE daemon knows including IKE SA keys,
 IP addresses of endpoints, authentication methods and algorithms.
\end_layout

\begin_layout Enumerate
\begin_inset CommandInset label
LatexCommand label
name "enu:thread-model-4"

\end_inset

The attacker can send arbitrary commands to the TCB (deduced from point
 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:thread-model-3"

\end_inset

).
\end_layout

\begin_layout Enumerate
Resulting from point 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:thread-model-4"

\end_inset

, the attacker can abuse the signature service (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Creation-of-an-ike-sa"

\end_inset

) provided by the TKM.
 It is able to control parts of the to be signed data (i.e.

\emph on
 init_message
\emph default
).
\end_layout

\begin_layout Section
TCB properties
\end_layout

\begin_layout Standard
TODO: describe these as well?
\end_layout

\begin_layout Standard
Even if an attacker manages to take over control of the untrusted part of
 the system as described by the thread model in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

, the TCB still guarantees the following properties:
\end_layout

\begin_layout Itemize
The attacker has no access to the IPsec SA keying material.
\end_layout

\begin_layout Itemize
The attacker has no mean to draw conclusions about the IPsec SA keying material
 from sensitive intermediate values.
\end_layout

\begin_layout Itemize
The attacker is not able to forge authentication exchanges with unauthorized
 peers.
 
\end_layout

\begin_layout Itemize
The attacker is not able to derive child keying material for an unauthorized
 connection.
\end_layout

\begin_layout Chapter
Analysis of strongSwan
\begin_inset Argument
status open

\begin_layout Plain Layout
Analysis
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This section describes the current operation of the strongSwan charon IKEv2
 daemon.
 A deep understanding of these mechanisms is a prerequisite for the separation
 of the daemon in a trusted and untrusted part to achieve the requirements
 specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Section
IKEv2 protocol analysis
\begin_inset CommandInset label
LatexCommand label
name "sub:IKEv2-protocol-analysis"

\end_inset


\end_layout

\begin_layout Standard
The following section provides a detailed analysis of the IKEv2 message
 exchanges (as specified by 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

), focusing on the security relevance of the transmitted data.
 All communication using IKE consists of a request / response pair.
 
\end_layout

\begin_layout Standard
In the following descriptions, the payloads contained in the message are
 indicated by names as listed in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:IKEv2-payloads"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Payload
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AUTH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Authentication
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CERT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Certificate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CERTREQ
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Certificate Request
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Configuration
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EAP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Extensible Authentication
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IKE header (not a payload)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IDi 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identification - Initiator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IDr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identification - Responder
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
KE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Exchange
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ni, Nr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nonce
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notify
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Security Association
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted and Authenticated
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TSi
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Traffic Selector - Initiator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TSr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Traffic Selector - Responder
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vendor ID
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKEv2 payloads
\begin_inset CommandInset label
LatexCommand label
name "tab:IKEv2-payloads"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every IKE message contains a Message 
\emph on
ID
\emph default
 as part of its fixed header (
\emph on
HDR
\emph default
).
 This Message 
\emph on
ID
\emph default
 is used to match up requests and responses, and to identify retransmissions
 of messages 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
 The fixed header does not contain information identified as critical, therefore
 the header is omitted from the discussion in the following sections.
 
\end_layout

\begin_layout Standard
A value declared as 'critical' or 'sensitive
\begin_inset Index idx
status open

\begin_layout Plain Layout
sensitive values
\end_layout

\end_inset

' in the following sections must not be accessible by the untrusted part,
 i.e.
 it must not be present in memory or storage accessible by the untrusted
 part.
 Other payloads (such as 
\emph on
AUTH
\emph default
) are calculated from critical values inside the TKM but then handed to
 the untrusted part for further processing and transmission.
\end_layout

\begin_layout Subsection
IKE_SA_INIT
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-IKE_SA_INIT"

\end_inset


\end_layout

\begin_layout Standard
The first pair of messages (IKE_SA_INIT
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE_SA_INIT
\end_layout

\end_inset

) negotiate cryptographic algorithms, exchange nonces, and do a Diffie-Hellman
\begin_inset Index idx
status open

\begin_layout Plain Layout
Diffie-Hellman
\end_layout

\end_inset

 exchange 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{1}{A}{B}{HDR, SAi1, KEi, Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{2}{B}{A}{HDR, SAr1, KEr, Nr, [CERTREQ]}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SAi1
\emph default
 payload states the cryptographic algorithms the initiator supports for
 an IKE SA.
 This payload is not considered critical because the TKM only supports a
 subset of cryptographic algorithms, which are strong enough and believed
 to be secure.
 A deviation from allowed proposals would only result in a non-functional
 configuration.
\end_layout

\begin_layout Standard
Child keys are derived from the shared secret
\begin_inset Index idx
status open

\begin_layout Plain Layout
shared secret
\end_layout

\end_inset

 value resulting from the Diffie-Hellman exchange after the IKE_SA_INIT
 messages.
 Therefore the TKM must implement the DH protocol in the TCB and compute
 the public 
\emph on
KE
\emph default
 payload on behalf of the untrusted part.
\end_layout

\begin_layout Standard
The nonce
\begin_inset Index idx
status open

\begin_layout Plain Layout
Nonce
\end_layout

\end_inset

 
\emph on
Ni
\emph default
 is used as input to cryptographic functions and provides freshness to the
 key derivation technique used to obtain keys for the child SA, and to ensure
 creation of strong pseudorandom bits from the Diffie-Hellman key.
 Therefore, the nonce 
\emph on
Ni
\emph default
 used in the initial exchange must be randomly chosen, must be at least
 128 bits in size, and must be at least half the key size of the negotiated
 pseudorandom function (PRF).
 These constraints must be enforced by the TKM.
\end_layout

\begin_layout Standard
Values created by the responder can not be controlled by the TKM so these
 values are taken as is.
 This is true for all IKE message exchanges of course.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
KEi, Ni
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical IKE_SA_INIT payloads
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
IKE_AUTH
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-IKE_AUTH"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE_AUTH
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After the completion of the IKE_SA_INIT exchange, each party is able to
 compute SKEYSEED
\begin_inset Index idx
status open

\begin_layout Plain Layout
SKEYSEED
\end_layout

\end_inset

, from which all keys are derived for that SA.
 The messages that follow are encrypted and integrity protected in their
 entirety, with the exception of the message headers.
 The keys used for the encryption and integrity protection are derived from
 SKEYSEED and are known as SK_e (encryption) and SK_a (authentication, a.k.a.
 integrity protection).
 A separate SK_e and SK_a is computed for each direction.
 The notation SK { ...
 } indicates that these payloads are encrypted and integrity protected using
 that direction's SK_e and SK_a (
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 1.2).
\end_layout

\begin_layout Standard
The DH protocol is implemented in the TKM so the SK_e and SK_a keys must
 be provided to the untrusted part.
 The generated IKE keys 
\emph on
SK
\emph default
 are not considered critical because an attacker taking over the untrusted
 part is already able to extract all information protected by these keys
 (see the threat model section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{3}{A}{B}{HDR, SK 
\backslash
{IDi, [CERT,] [CERTREQ,] [IDr,] AUTH, SAi2, TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{4}{B}{A}{HDR, SK 
\backslash
{IDr, [CERT,] AUTH, SAr2, TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The initiator asserts its identity with the 
\emph on
IDi
\emph default
 payload.
 This value is not sensitive so it's directly configured using the standard
 strongSwan configuration mechanism.
 Nevertheless, the TKM must enforce correct identities to assure that only
 trusted ones are allowed.
\end_layout

\begin_layout Standard
The Authentication payload 
\emph on
AUTH
\emph default
 contains data used for authentication purposes and must be created by the
 TKM since it is signed by a private key only known to the TCB.
 The signed AUTH payload is handed to the untrusted part because the TKM
 assures that the PRF used to generate AUTH (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-generation"

\end_inset

) is strong enough.
\end_layout

\begin_layout Standard

\emph on
SAi2
\emph default
 is not considered critical and can be configured directly in the untrusted
 part.
 The TKM enforces the correct algorithms before deriving child keys.
 The same is true for the 
\emph on
TS
\emph default
 payloads.
 TODO CERT.
 The 
\emph on
CERTREQ
\emph default
 used to TODO payload can be used but makes no difference because the TKM
 currently trusts only one CA.
\end_layout

\begin_layout Standard
Payloads created by the responder can again not be controlled.
 The TKM enforces the selected algorithms before deriving child keys by
 consulting the policy.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK, AUTH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Enforced by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID, CERT, CERTREQ, SAi, TS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical IKE_AUTH payloads
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CREATE_CHILD_SA
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-CREATE_CHILD_SA"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
CREATE_CHILD_SA
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SK
\emph default
 used to protect the CREATE_CHILD_SA exchange is the same as described in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_AUTH"

\end_inset

.
 The 
\emph on
SK
\emph default
 is created by the TKM but handed to the untrusted part to protect the IKE
 exchanges from outside attackers.
 Attackers which have taken over the untrusted part are already able to
 extract all information protected by these keys.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{5}{A}{B}{HDR, SK 
\backslash
{SA, Ni, [KEi], TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{6}{B}{A}{HDR, SK 
\backslash
{SA, Nr, [KEr], TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SA
\emph default
 is again not considered critical and can be configured directly in the
 untrusted part.
 The TKM enforces the correct algorithms before deriving new child keys.
 The same is true for the 
\emph on
TS
\emph default
 payloads.
\end_layout

\begin_layout Standard
Depending on the PFS
\begin_inset Index idx
status open

\begin_layout Plain Layout
PFS
\end_layout

\end_inset

 configuration of the connection, the CREATE_CHILD_SA request may optionally
 contain a 
\emph on
KE
\emph default
 payload for an additional Diffie-Hellman exchange to enable stronger guarantees
 of forward secrecy for the child SA.
 The keying material for the child SA is a function of SK_d created during
 the establishment of the IKE SA, the nonces exchanged during the CREATE_CHILD_S
A exchange, and the Diffie-Hellman value (if 
\emph on
KE
\emph default
 payloads are included in the CREATE_CHILD_SA exchange) (
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 1.3).
\end_layout

\begin_layout Standard
Payloads created by the responder can not be controlled but the algorithms
 selected from 
\emph on
SA
\emph default
 and the traffic selectors selected from 
\emph on
TS
\emph default
 must be checked by the TKM.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK, Ni, [KEi]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Enforced by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAi, TS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical CREATE_CHILD_SA payloads
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Code analysis
\begin_inset CommandInset label
LatexCommand label
name "sub:Code-analysis"

\end_inset


\end_layout

\begin_layout Standard
This section illustrates the charon source code, which processes the IKEv2
 message and other security relevant data as described by section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKEv2-protocol-analysis"

\end_inset

.
 Graphs are used to illustrate the code flow which implement a certain functiona
lity and possibilities to interfere with the current design are explored.
 
\end_layout

\begin_layout Subsection
IKE_SA_INIT
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-IKE_SA_INIT"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

 shows the code involved in the IKE SA establishment.
 The exchange involves an initiator and a responder which are displayed
 in separate blocks in the graph.
 During IKE_SA_INIT two messages are exchanged which are indicated between
 the initiator and responder code blocks.
 Round labels, e.g.
 the label 
\emph on
(CD
\emph default
) are references to subgraphs which illustrate a continuative process in
 detail.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-sa-init.svg
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
IKE SA establishment
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-establishment"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
IKE exchanges are implemented as task entities in charon and life in the
 
\family typewriter
libcharon/sa/ikev2/tasks
\family default
 directory.
 The IKE SA establishment process is implemented in the 
\family typewriter
ike_init.c
\family default
 file in this directory.
 The tasks are implemented as FSM
\begin_inset Foot
status open

\begin_layout Plain Layout
Finite-state machine
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
FSM
\end_layout

\end_inset

 which change state depending on internal or external events like received
 messages.
 The 
\family typewriter
NEED_MORE
\family default
 transition indicates that the state machine is expecting more data to proceed.
 This state separates the sending path from the receiving path inside the
 
\family typewriter
build_i/process_i
\family default
 and 
\family typewriter
process_r/build_r
\family default
 blocks of figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

.
 The tasks access required functionality by using requesting plugins from
 different factories.
 Examples of such plugins are RNGs
\begin_inset Foot
status open

\begin_layout Plain Layout
Random number generator
\end_layout

\end_inset

 or plugins which perform the DH exchange.
\end_layout

\begin_layout Standard
The initiator creates the payloads of the initial message in the 
\family typewriter
build_i
\family default
 code block during which the initial steps of the Diffie-Hellman protocol
 are performed.
 The task calls the 
\family typewriter
create_dh
\family default
 function of the 
\family typewriter
keymat
\family default
 object which internally requests a new DH plugin instance from the crypto
 factory and returns this instance to the calling task (
\emph on
CD
\emph default
).
 A 
\family typewriter
keymat
\family default
 object stores the complete IKE SA key material and is used to derive IKE
 and child SA keys.
 A 
\family typewriter
keymat
\family default
 object is always associated with an IKE SA inside the IKE SA manager.
\end_layout

\begin_layout Standard
After constructing all payloads, the initiator sends the IKE_SA_INIT message
 to the peer and waits for a response (error handling if no peer answers
 is omitted in this discussion).
 The responder processes the request in the 
\family typewriter
process_r
\family default
 code block and performs the DH protocol on his side.
 Since it already received the DH public value from the initiator, it is
 able to complete the DH exchange without waiting for further data.
 It then uses the SKEYSEED from the DH exchange to derive the IKE SA keying
 material (
\emph on
DK
\emph default
) and creates an IKE_SA_INIT response containing its DH public value to
 allow the initiator to complete the initial exchange on his side.
\end_layout

\begin_layout Standard
The initiator then also derives IKE SA keying material used to protect the
 following IKE_AUTH or CHILD_CREATE_SA exchanges (
\emph on
DK
\emph default
).
 This completes phase 1.
\end_layout

\begin_layout Subsection
IKE_AUTH
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-IKE_AUTH"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA authentication
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-authentication"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-authentication"

\end_inset

 shows the code involved during the authentication of an IKE SA.
 This exchange is more complex than the IKE_SA_INIT exchange, that's the
 reason why the graph contains seven subgraphs, including the one depicted
 in the separate figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-Certificate-trustchain"

\end_inset

 which illustrates the trustchain verification code flow.
 The subgraphs cross-reference themselves which is again indicated by round
 labels.
\end_layout

\begin_layout Standard
The initiator begins the exchange by building it's own AUTH payload used
 to prove his identity to the responder.
 This is done by creating a so called 'authenticator' (see the 
\emph on
CB
\emph default
 label) which is again implemented as a plugin.
 After that, the authenticator's 
\family typewriter
build
\family default
 function is called which is illustrated by the 
\emph on
BA
\emph default
-subgraph shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

.
 To construct the signed AUTH octets the authenticator plugin requests a
 private key (
\emph on
GP
\emph default
) matching a specific certificate configured for this connection.
 The returned private key is used to sign the AUTH octets requested from
 the keymat object (
\emph on
A8
\emph default
) of the associated IKE SA and is again implemented in a plugin.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth-ba-pa.svg
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE public key authenticators
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-public-key-auth"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
It then sends a message containing the constructed payloads to the responder
 and waits for a response message (error handling omitted).
\end_layout

\begin_layout Standard
The responder creates a 'verifier' plugin to check the AUTH payload extracted
 from the initiator's message.
 The creation of a verifier plugin is depicted in the 
\emph on
CV
\emph default
 graph.
 It then processes the AUTH octets of the initiator by calling the verifier's
 
\family typewriter
process
\family default
 function (
\emph on
PA
\emph default
).
 The authenticator requests the AUTH octets from the IKE SA keymat (
\emph on
A8
\emph default
) and retrieves the associated public key needed to verfiy the signature
 from the credential manager.
 To use the public key, it's chain of trust must be verified.
 
\end_layout

\begin_layout Standard
The trustchain verification process is shown in (
\emph on
PU
\emph default
) of figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-Certificate-trustchain"

\end_inset

.
 The credential manager iterates over all certificates linked with the public
 key until it reaches a trusted CA certificate.
 TODO: explain more
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth-pu.svg
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
IKE Certificate trustchain verification
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-Certificate-trustchain"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create the response message, the responder performs the same steps as
 the initiator to create it's AUTH payload (
\emph on
CB
\emph default
, 
\emph on
BA
\emph default
).
 The initiator verifies the AUTH payload of the responder using the same
 steps as described for the responder (
\emph on
CV
\emph default
, 
\emph on
PA
\emph default
).
\end_layout

\begin_layout Standard
After the IKE SA is established, both peers normally install the first child
 SA.
 This step is omitted and explained in detail in the next section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-CHILD_CREATE_SA"

\end_inset

.
\end_layout

\begin_layout Subsection
CHILD_CREATE_SA
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-CHILD_CREATE_SA"

\end_inset


\end_layout

\begin_layout Standard
The CHILD_CREATE_SA exchange is implemented as task in the 
\family typewriter
child_create.c
\family default
 file.
 The initiator starts by collecting the traffic selectors and proposals
 from the configuration (not visible in the graph) and allocates a SPI by
 calling the 
\family typewriter
allocate_spi
\family default
 function.
 This function dispatches into the registered kernel plugin to acquire a
 free SPI from the OS kernel.
 If the connection has PFS
\begin_inset Foot
status open

\begin_layout Plain Layout
Perfect forward secrecy
\end_layout

\end_inset

 enabled, the initiator starts a new DH exchange and builds all required
 payloads.
 After sending the message, the task changes it's state to NEED_MORE and
 waits for an answer.
\end_layout

\begin_layout Standard
The responder processes the received CHILD_CREATE_SA message and extracts
 the contained payloads.
 It conducts the DH exchange and then directly installs the derived child
 SA keying material in the kernel.
 The complete process of deriving keys for the new child SA is depicted
 in 
\emph on
(SI
\emph default
).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/child-create-sa.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Child SA establishment
\begin_inset CommandInset label
LatexCommand label
name "fig:Child-SA-establishment"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
First the child SA data structure associated with the task is set into the
 CHILD_INSTALLING state.
 The derive_child_keys function of the keymat is called to derive keying
 material for the child SA (
\emph on
DC
\emph default
).
 The kernel plugin's add_policy (
\emph on
IP
\emph default
) and add_sa (
\emph on
IS
\emph default
) functions are used to install the new policy and state into the kernel's
 SPD and SAD databases.
 If no errors occured, the state of the child SA is set to CHILD_INSTALLED
 and it it attached to the associated IKE SA object.
\end_layout

\begin_layout Standard
The responder then builds the payloads of the response message and sends
 it back to the initiator.
 The initiator processes the message and after extracting the payloads,
 it calls the select_and_install function to derive child keying material
 and install the new policy and state in the kernel.
\end_layout

\begin_layout Subsection
Source of randomness
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Source-of-randomness"

\end_inset


\end_layout

\begin_layout Standard
Randomness is provided by requesting a random number generator plugin instance
 (
\family typewriter
rng_t
\family default
) from the crypto factory of libstrongswan.
 This process is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Nonce-generation"

\end_inset

 using the example of creating new nonces.
 As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

, nonces are used to guarantee freshness in the key derivation process and
 must be created using a good random source (TODO: explain good?).
\end_layout

\begin_layout Standard
Depending on the requested quality (RNG_WEAK or RNG_STRONG) a suitable RNG
 plugin providing the needed quality is created and returned to the caller
 by the crypto factory.
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/nonce-generation.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nonce generation
\begin_inset CommandInset label
LatexCommand label
name "fig:Nonce-generation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Payload encryption
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Payload-encryption"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-payload-enc"

\end_inset

 schematically shows the code involved in the encryption of payloads in
 the IKE message exchanges.
 If a new connection is initiated by calling the initiate function of the
 IKE SA, all tasks (see previous sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-IKE_SA_INIT"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-CHILD_CREATE_SA"

\end_inset

) required to establish an IKE SA and the associated child SA are created
 and run by the task manager.
 The tasks then callback to the IKE SA 
\family typewriter
generate_message
\family default
 function to create the message sent to the peer in their exchange.
\end_layout

\begin_layout Standard
The 
\family typewriter
generate_message
\family default
 function calls the 
\family typewriter
generate
\family default
 function of the message which in turn checks if the message is required
 to be encrypted.
 If encryption is enabled, an encrypted payload is created by accessing
 the key material of the IKE SA's 
\family typewriter
keymat
\family default
 object.
 The actual encryption is done by a crypter plugin which in turn uses an
 RNG plugin to retrieve random bytes needed for the IV
\begin_inset Foot
status open

\begin_layout Plain Layout
Initialization vector
\end_layout

\end_inset

.
 TODO: explain AEAD
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/payload-encryption.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA payload encryption
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-payload-enc"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Payload decryption
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Payload-decryption"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-payload-dec"

\end_inset

 shows the process of payload decryption which reverses the process of payload
 encryption explained in the previous chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-Payload-encryption"

\end_inset

.
 An incoming message is processed by calling the task managers 
\family typewriter
process_message
\family default
 function.
 This function parses the message by calling the message 
\family typewriter
parse_body
\family default
 function with the keymat object from the IKE SA as function argument.
\end_layout

\begin_layout Standard
The 
\family typewriter
parse_body
\family default
 function calls 
\family typewriter
decrypt_payloads
\family default
 which determines if the payloads are encrypted or not.
 If they are, it decrypts them by using an encryption payload object which
 uses the keymat's keying material to decrypt and verify the payloads.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/payload-decryption.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA payload decryption
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-payload-dec"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Design
\begin_inset CommandInset label
LatexCommand label
name "chap:Design"

\end_inset


\end_layout

\begin_layout Standard
The main concept is to separate the security relevant services from all
 other IKEv2 services and split the IKEv2 key management daemon into two
 components: a trusted and an untrusted part.
 The trusted part performs the critical services, stores all relevant keying
 material and exposes the necessary services to the untrusted component
 via a well defined and minimal interface.
 The split of the components must guarantee the fullfilment of the security
 requirements defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Section
Split of IKE
\end_layout

\begin_layout Standard
The charon software design is based on a plugin architecture.
 Almost every functional part of the daemon is implemented as a plugin.
 This provides the flexibility to extend or exchange specific parts of the
 system.
 As outlined in the code analysis section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Code-analysis"

\end_inset

, most security critical operations and values are already encapsulated
 in plugins.
 The changes needed to allow complete separation of the critical parts from
 the charon daemon are limited.
 Therefore, the architecture depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Split-of-IKE"

\end_inset

 is proposed.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/design-overview.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Split of IKE into trusted and untrusted parts
\begin_inset CommandInset label
LatexCommand label
name "fig:Split-of-IKE"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
By implementing custom plugins which act as proxy between the trusted and
 untrusted parts of the component, it is possible to move the key material
 and related operations into the TCB.
 This ensures that the untrusted part has no direct access to security relevant
 data.
 The critical parts extracted from charon are implemented by the trusted
 key manager which is part of the TCB.
 
\end_layout

\begin_layout Standard
By using a well-defined interface, the internal functionality of the TCB’s
 key manager is completely hidden from the charon plugins.
 The plugins reference the data (and their associated state) needed for
 processing via context identifiers.
 They have no direct access to the objects referenced by the identifiers
 but can instruct the key manager to perform certain, allowed operations
 with the specified context(s).
 Only uncritical results of operations are returned to the caller plugin
 (e.g.
 the public value of a DH exchange).
 This architecture allows the trusted part to be minimal while the bulk
 of the charon code can be used as is, in the untrusted part to handle the
 vast majority of IKEv2 processing.
\end_layout

\begin_layout Standard
TODO: make context/ID handling a sep.
 section? explain upper limit of ID
\end_layout

\begin_layout Standard
TODO: further elaborate the design
\end_layout

\begin_layout Section
Requirements
\begin_inset CommandInset label
LatexCommand label
name "sec:Requirements"

\end_inset


\end_layout

\begin_layout Standard
This section outlines the identified requirements of the separated system
 in detail.
 The following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Functional-requirements"

\end_inset

 covers functional requirements, while section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Security-requirements"

\end_inset

 specifies security requirements.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Additional-requirements"

\end_inset

 describes additional requirements.
\end_layout

\begin_layout Standard
TODO: remove functional, security requirements sub-sections? The definition
 of 
\begin_inset Quotes eld
\end_inset

functional requirement
\begin_inset Quotes erd
\end_inset

 does not match our usage, see wikipedia.
\end_layout

\begin_layout Subsection
Functional requirements
\begin_inset CommandInset label
LatexCommand label
name "sub:Functional-requirements"

\end_inset


\end_layout

\begin_layout Standard
This section specifies the functional requirements of the separated IKEv2
 system.
\end_layout

\begin_layout Subsubsection
Separation
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Separation"

\end_inset


\end_layout

\begin_layout Standard
The IKEv2 component must be separated into a trusted and untrusted part,
 to minimize the size and complexity of the TCB.
 The trusted part must enforce all security requirements specified in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Security-requirements"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Communication
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Communication"

\end_inset


\end_layout

\begin_layout Standard
The communication protocol between the trusted and untrusted parts must
 be simple, robust and well-defined to allow a verifiable implementation.
 
\end_layout

\begin_layout Subsection
Security requirements
\begin_inset CommandInset label
LatexCommand label
name "sub:Security-requirements"

\end_inset


\end_layout

\begin_layout Standard
The security requirements identified in this section specify the properties
 the TCB must enforce even in the event of a complete compromise of the
 untrusted part of the system (see also the section explaining the thread
 model 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Separation of key material
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Separation-of-key"

\end_inset


\end_layout

\begin_layout Standard
The untrusted part of the IKEv2 component must not have access to generated
 key material that is used for authentication of peers, encryption and integrity
 protection of user data (i.e.
 child SA keys).
 This also includes critical intermediate values, which may result from
 the key agreement, generation and derivation process.
 
\end_layout

\begin_layout Standard
Excluded from the critical material are keys used to protect the IKE SA.
 As defined by the thread model in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

, an attacker might be able to compromise the untrusted IKE daemon and read
 all its memory (point 
\begin_inset CommandInset ref
LatexCommand ref
reference "enu:thread-model-2"

\end_inset

).
 If an attacker is able to do that, protecting the IKE SA keys is unneeded
 since the attacker already knows everything these keys are intended to
 protect.
\end_layout

\begin_layout Subsubsection
Cryptographic operations
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Cryptographic-operations"

\end_inset


\end_layout

\begin_layout Standard
All relevant cryptographic operations must be performed by the trusted computing
 base (TCB) to assure the correctness of the resulting values.
 Since key material is needed to perform crypto operations, this is also
 a consequence of the requirement specified in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation-of-key"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Authentication
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Authentication"

\end_inset


\end_layout

\begin_layout Standard
The IKEv2 component must only allow IPSec SAs to be established for peers
 that have successfully been authenticated.
 The authentication must be performed by the TCB to assure the correctness
 of the process.
\end_layout

\begin_layout Standard
The authentication state in the TCB must always be unambiguously associated
 with the corresponding SA.
\end_layout

\begin_layout Subsubsection
Integrity
\begin_inset CommandInset label
LatexCommand label
name "sub:req-Integrity"

\end_inset


\end_layout

\begin_layout Standard
The security of the IKEv2 component must solely depend on the correct operation
 of the trusted part.
 The security operation of the system must not be violated by a misbehaving
 untrusted part.
\end_layout

\begin_layout Subsection
Additional requirements
\begin_inset CommandInset label
LatexCommand label
name "sub:Additional-requirements"

\end_inset


\end_layout

\begin_layout Standard
The resulting system must be freely available to guarantee broader review
 and allow it to be extended by other interested parties.
 The TKM-specific changes and plugins should be integrated into the upstream
 strongSwan project.
 Also, integration tests must be provided for the TKM use-case.
\end_layout

\begin_layout Standard
TODO: specify TCB specific requirements? Coding practices, pair programming,
 Ada etc.
\end_layout

\begin_layout Section
Fulfillment of requirements
\end_layout

\begin_layout Standard
This section describes how the proposed design meets the requirements defined
 in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Itemize
TKM, how is it written? Coding style, language etc.
 What makes it improve the trust?
\end_layout

\begin_layout Itemize
The separation and communication requirements 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Communication"

\end_inset

 demand that the untrusted and trusted parts of the system are separated
 and communication is only possible over a well-defined, minimal interface.
 These requirements are guaranteed by automatically creating the interface
 code from an XML-specification as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:XML-Specification"

\end_inset

 and by using a simple library providing RPC services by exporting the generated
 interface over UNIX domain sockets (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

).
\end_layout

\begin_layout Itemize
Requirements 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Separation-of-key"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Cryptographic-operations"

\end_inset

 require that the untrusted part must not have access to critical keying
 material and that the cryptographic operations using this material must
 be implemented in the TCB to guarantee proper operation.
 These requirements are fulfilled in the design by implementing plugins
 which act as proxy objects between the untrusted charon-tkm daemon and
 the TKM.
 These plugins operate with references to the real, sensitive data and are
 kept very simple.
 No sensitive data leaves the TCB.
 This directly demands that critical cryptographic operations used to either
 create sensitive material or operating on sensitive material must be implemente
d in the TCB as well.
 The following TKM-specific strongSwan plugins are responsible to achieve
 the desired degree of separation:
\end_layout

\begin_deeper
\begin_layout Itemize
Nonce generation plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Nonce-generation"

\end_inset

)
\end_layout

\begin_layout Itemize
DH plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Diffie-Hellman"

\end_inset

)
\end_layout

\begin_layout Itemize
Keymat plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Keymat"

\end_inset

)
\end_layout

\begin_layout Itemize
Kernel IPsec plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:pluginKernel-IPsec"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Requirement 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Authentication"

\end_inset

 requires that the TCB must enforce proper authentication.
 The system supports strong authentication methods based on public-key cryptogra
phy only.
 The secret private key required to create valid signatures and the trusted
 CA certificate used to verify the peer's authentication data must reside
 in the TCB.
 To make this separation possible, the following TKM-specific strongSwan
 plugins are proposed:
\end_layout

\begin_deeper
\begin_layout Itemize
Private key plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Private-key"

\end_inset

)
\end_layout

\begin_layout Itemize
Public key plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Public-key"

\end_inset

)
\end_layout

\begin_layout Itemize
Bus listener plugin (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Bus-listener"

\end_inset

)
\end_layout

\end_deeper
\begin_layout Itemize
Requirement 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Integrity"

\end_inset

 demands that a misbehaving untrusted part is not able to violate the security
 properties guaranteed by the TCB.
 As a formal model checking of the proposed IKEv2 separation protocol is
 still outstanding, this property is only assumed but not yet formally proven.
 See also section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
\end_layout

\begin_layout Section
Assumptions
\end_layout

\begin_layout Standard
IKE and TKM can only exchange messages via the well defined interface and
 are otherwise completely isolated from each other.
 In a real system this is very difficult to achieve since there are many
 possibilities for side channels, which have been demonstrated to work,
 see for example 
\begin_inset CommandInset citation
LatexCommand cite
key "cryptoeprint:2010:594"

\end_inset

,
\begin_inset CommandInset citation
LatexCommand cite
key "Zhang:2012:CSC:2382196.2382230"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand cite
key "Aciicmez:2007:PSB:1229285.1266999"

\end_inset

.
 TODO: explain why this is out of scope and how this could be solved (e.g.
 SK, special algos for crypto).
\end_layout

\begin_layout Chapter
TKM interface
\end_layout

\begin_layout Standard
This chapter specifies the interface between the trusted and the untrusted
 parts of the system.
 In a first step an overview of the communication between IKE and TKM is
 given by describing how the main operations of IKE are achieved through
 the usage of the services provided by the interface.
 After the abstract illustration of the protocol, the data types and constants
 are specified.
 These are the building blocks of the message exchanges which are described
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exchanges"

\end_inset

.
\end_layout

\begin_layout Standard
TODO: Are state machines really part of the interface or are they part of
 how the TKM server-side of the interface is implemented?
\end_layout

\begin_layout Section
Protocol overview
\end_layout

\begin_layout Standard
This section gives an overview of the main IKE operations: creation and
 rekeying of IKE and Child SAs.
 The description presents the success case and specifies which parameters
 are passed back and forth between IKE and the TKM using the exchanges specified
 in the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-Exchanges"

\end_inset

.
\end_layout

\begin_layout Standard
In the illustrated negotiation of SAs with the peer IKE is assuming the
 role of the initiator of the exchanges.
 The responder case varies only slightly and is thus not presented here.
 Where necessary the exchanges provide a parameter called 
\shape italic

\begin_inset Quotes eld
\end_inset

initiator
\begin_inset Quotes erd
\end_inset


\shape default
 which is used to specify whether IKE is the initiator or responder of an
 IKEv2 message exchange with the remote peer.
\end_layout

\begin_layout Standard
Note that child SA and ESP
\begin_inset Index idx
status open

\begin_layout Plain Layout
ESP
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Encapsulating Security Payload is part of the IPsec protocol suite and provides
 authenticity, integrity and confidentiality of data packets.
\end_layout

\end_inset

 SA are used interchangeably.
\end_layout

\begin_layout Subsection
Creation of an IKE SA
\begin_inset CommandInset label
LatexCommand label
name "sub:Creation-of-an-ike-sa"

\end_inset


\end_layout

\begin_layout Standard
In a first step the client gets a nonce and a Diffie Hellman public value
 from the TKM using the 
\family typewriter
nc_create
\family default
 and 
\family typewriter
dh_create
\family default
 operations:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates an IKE SA exchange with the remote peer, which
 is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

.
 Upon receipt of the peer's response the Diffie Hellman shared secret can
 be calculated.
 Thus IKE issues the 
\family typewriter
dh_generate_key
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM performs the calculation and stores the DH key for future consumption.
 No data other than the status code of the operation is passed back to IKE.
\end_layout

\begin_layout Standard
Using the previously created nonce and Diffie Hellman value plus the nonce
 (
\shape italic
Nr
\shape default
) received from the remote peer, a new IKE SA is created:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_create}{IKE}{TKM}{isa
\backslash
_id, ae
\backslash
_id, ia
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, init, spi
\backslash
subscript{local}, spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{sk
\backslash
_ai, sk
\backslash
_ar, sk
\backslash
_ei, sk
\backslash
_er}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The returned encryption and integrity protection keys can now be used by
 the IKE daemon to send encrypted and integrity protected IKEv2 messages
 to the remote peer.
 For a consideration of why these keys can be handed out by TKM to the untrusted
 side, please refer to section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Handling-of-key"

\end_inset

.
\end_layout

\begin_layout Standard
To authenticate itself to the remote peer the IKE daemon requests signed
 local authentication data from TKM using the 
\family typewriter
isa_sign
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_sign}{IKE}{TKM}{isa
\backslash
_id, lc
\backslash
_id, init
\backslash
_message}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{AUTH
\backslash
subscript{local}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In possesion of the necessary data and keys, the IKE_AUTH protocol step,
 described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_AUTH"

\end_inset

, is performed with the remote peer.
\end_layout

\begin_layout Standard
Upon reception of the peer's response the IKE daemon starts to validate
 the certificate chain of the remote peer certificate 
\shape italic
CERT
\shape default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_set
\backslash
_user
\backslash
_certificate}{IKE}{TKM}{cc
\backslash
_id, ri
\backslash
_id, autha
\backslash
_id, CERT}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each certificate in the chain is added by issuing the 
\family typewriter
cc_add_certificate
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_add
\backslash
_certificate}{IKE}{TKM}{cc
\backslash
_id, autha
\backslash
_id, CERT}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the root of the certificate chain is reached it must be asserted that
 the CA is trusted.
 This is done using the 
\family typewriter
cc_check_ca
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_check
\backslash
_ca}{IKE}{TKM}{cc
\backslash
_id, ca
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After successful verification of the remote certificate, IKE can authenticate
 the peer:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_auth}{IKE}{TKM}{isa
\backslash
_id, cc
\backslash
_id, init
\backslash
_message, AUTH
\backslash
subscript{remote}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a final step the first child SA can be created issuing the 
\family typewriter
esa_create_first
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_create
\backslash
_first}{IKE}{TKM}{esa
\backslash
_id, isa
\backslash
_id, sp
\backslash
_id, ea
\backslash
_id, esp
\backslash
_spi
\backslash
subscript{local}, esp
\backslash
_spi
\backslash
subscript{remote}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this exchange processed successfully by TKM, IKE has established an
 IKE and one ESP SA which can be used to encrypt application data according
 to the associated security policy identified by 
\shape italic
sp_id
\shape default
.
\end_layout

\begin_layout Subsection
Creation of a Child SA
\begin_inset CommandInset label
LatexCommand label
name "sub:Child-SA-creation"

\end_inset


\end_layout

\begin_layout Standard
Creating a child SA is quite similar to creating an IKE SA.
 All steps related to peer authentication can be omitted since the remote
 identity has already been authenticated.
\end_layout

\begin_layout Standard
To create a new child SA with perfect forward secrecy (PFS) a fresh nonce
 and Diffie Hellman value must be created:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates a CREATE_CHILD_SA exchange with the remote
 peer (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-CREATE_CHILD_SA"

\end_inset

).
 Upon receipt of the peer's response the Diffie Hellman shared secret is
 calculated by issuing the 
\family typewriter
dh_generate_key
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM performs the calculation and stores the DH key for future consumption.
 Only the status code of the operation is passed back to IKE.
\end_layout

\begin_layout Standard
Finally the child SA can be created using the 
\family typewriter
esa_create
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_create}{IKE}{TKM}{esa
\backslash
_id, isa
\backslash
_id, sp
\backslash
_id, ea
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, initiator, esp
\backslash
_spi
\backslash
subscript{local}, esp
\backslash
_spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this final step the IKE daemon has successfully established a new
 child SA.
\end_layout

\begin_layout Subsection
Rekeying of an IKE SA
\end_layout

\begin_layout Standard
An IKE SA is rekeyed by replacing it with a new IKE SA.
 For this purpose a fresh nonce and a DH public value is needed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates a CREATE_CHILD_SA exchange to rekey the existing
 IKE SA with the peer.
 Upon receipt of the peers response the Diffie Hellman shared secret can
 be calculated:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rekeying of the IKE SA, identified by 
\shape italic
parent_isa_id
\shape default
, is performed using the 
\family typewriter
isa_create_child
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_create
\backslash
_child}{IKE}{TKM}{isa
\backslash
_id, parent
\backslash
_isa
\backslash
_id, ia
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, initiator, spi
\backslash
subscript{local}, spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{sk
\backslash
_ai, sk
\backslash
_ar, sk
\backslash
_ei, sk
\backslash
_er}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM returns the new encryption and integrity keys of the new IKE SA, which
 from this point on is used to exchange IKEv2 messages with the remote peer.
\end_layout

\begin_layout Standard
To effectively complete the rekeying operation, the superseded IKE SA must
 be reset:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_reset}{IKE}{TKM}{isa
\backslash
_id
\backslash
subscript{old}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\shape italic
isa_id
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subscript{old}
\end_layout

\end_inset


\shape default
 is the same as the 
\shape italic
parent_isa_id
\shape default
 used in the 
\family typewriter
isa_create_child
\family default
 operation.
\end_layout

\begin_layout Subsection
Rekeying of a Child SA
\end_layout

\begin_layout Standard
A child SA is rekeyed by replacing it with a new child SA.
 In order to achieve this, the steps described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Child-SA-creation"

\end_inset

 must be performed.
 After the new child SA has been established the new SA must be selected,
 making it the for ESP encryption:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_select}{IKE}{TKM}{esa
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only thing left to do is to reset the old, rekeyed child SA:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_reset}{IKE}{TKM}{esa
\backslash
_id
\backslash
subscript{old}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Data types and constants
\end_layout

\begin_layout Standard
This section presents the data types and constants that are used in the
 specification of the TKM interface.
 They are referenced in the description of the interface exchanges, which
 follows in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exchanges"

\end_inset

.
\end_layout

\begin_layout Subsection
Integer types
\begin_inset CommandInset label
LatexCommand label
name "sub:Integer-types"

\end_inset


\end_layout

\begin_layout Standard
These types are numeric integers.
 Their 
\family typewriter
size
\family default
 is specified in bytes, which is also the amount of memory an object of
 such a type consumes.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-integer.tex"

\end_inset


\end_layout

\begin_layout Subsection
Variable octet types
\end_layout

\begin_layout Standard
These types are octet sequences of variable size.
 
\family typewriter
Data
\family default
 is the maximum number of data bytes that can be stored in the octet sequence,
 while 
\family typewriter
size
\family default
 is the number of bytes an object of this type occupies in memory.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-varoctets.tex"

\end_inset


\end_layout

\begin_layout Subsection
Constants
\begin_inset CommandInset label
LatexCommand label
name "sub:Constants"

\end_inset


\end_layout

\begin_layout Standard
The TKM interface specifies various numeric constants, which can be referenced
 by the IKE daemon or the TKM.
 All constants are typed which restricts their range of valid values.
 All constants are given in hexadecimal form.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-constants.tex"

\end_inset


\end_layout

\begin_layout Section
Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sec:Exchanges"

\end_inset


\end_layout

\begin_layout Standard
This section describes all exchanges of the different TKM interfaces.
 The interface is comprised of two service-specific parts: IKE and ESP Event
 Service (EES).
\end_layout

\begin_layout Standard
Communication is seen as an exchange of request and response message pairs
 between a client and a server.
 In the concrete implementation, which is presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:charon-tkm"

\end_inset

, the untrusted charon daemon takes the role of the client while TKM is
 the server of the IKE interface.
 Contrary charon acts as a server of the EES interface, described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

, while the xfrm-proxy (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:xfrm-proxy"

\end_inset

) implements the client side.
\end_layout

\begin_layout Standard
Exchanges are allocated an identifier (
\family typewriter
operation_type
\family default
 defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Integer-types"

\end_inset

) which is unique on a per-interface basis.
\end_layout

\begin_layout Standard
Requests contain an identifier (
\family typewriter
req_id
\family default
)
\shape italic
 
\shape default
which is chosen by the client of an exchange.
 The server must set the 
\family typewriter
req_id
\family default
 of the corresponding response to be identical.
 This enables the client to match responses to their requests and handle
 multiple pending exchanges with possible 
\shape italic
out-of-order
\shape default
 arrival of responses.
\end_layout

\begin_layout Standard
The basic layout of a request and response object is show in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-and-response"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/request-response-structure.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Request and response structure
\begin_inset CommandInset label
LatexCommand label
name "fig:Request-and-response"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
IKE Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sub:IKE-Exchanges"

\end_inset


\end_layout

\begin_layout Standard
All the following exchanges are used by IKE to communicate with the TKM
 and perform operations related to IKE or ESP SA establishment.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-nc_create.tex"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsub:Exchanges-nc-create"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-nc_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_generate_key.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_set_user_certificate.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_add_certificate.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_check_ca.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-ae_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_sign.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_auth.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_create_child.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create_first.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create_no_pfs.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_select.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_version.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_limits.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_reset.tex"

\end_inset


\end_layout

\begin_layout Subsection
ESP SA Event Service (EES) Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sub:ESP-SA-Event"

\end_inset


\end_layout

\begin_layout Standard
The exchanges specified in this section are used by the xfrm-proxy to communicat
e with IKE.
 EES is used to send notifications about ESP SA events such as acquire or
 expire.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-EES-esa_acquire.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-EES-esa_expire.tex"

\end_inset


\end_layout

\begin_layout Section
State machines
\begin_inset CommandInset label
LatexCommand label
name "sec:State-machines"

\end_inset


\end_layout

\begin_layout Standard
Contexts are used to describe stateful entities within the TKM.
 They are finite state machines (FSM
\begin_inset Index idx
status open

\begin_layout Plain Layout
FSM
\end_layout

\end_inset

) which have a set of states and transitions between those states.
 The FSM is in a specific state at any given time and can only change its
 state by performing a transition.
 A transition prescribes the source state the FSM has to be in, the actions
 to execute and the new target state once the transition has completed.
\end_layout

\begin_layout Standard
The state machine transitions to a known failure state if an error occurs.
 To recover from such an error the FSM has to be reinitialized by explicitly
 performing a reset operation.
\end_layout

\begin_layout Standard
The state of the overall TKM system can be interpreted as the sum of the
 states of all FSMs and their associated data at any given time.
\end_layout

\begin_layout Subsection
Graph notation
\end_layout

\begin_layout Standard
Each state machine is depicted by a diagram.
 Transitions are drawn as directed arrows from the source to the target
 state with a label identifying the name of the transition.
\end_layout

\begin_layout Standard

\shape italic
Reset
\shape default
 and 
\shape italic
error
\shape default
 transitions are treated differently in order to create less cluttered graphs.
 These two transitions can be triggered from any state so their labels are
 omitted and their arrows have different styles.
 Reset transitions are shown using blue lines and error transitions are
 marked with red dashed lines.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-nc.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-nc.svg
	width 57text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nonce context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-dh.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-dh.svg
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diffie Hellman context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-cc.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-cc.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Certificate chain context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-ae.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-ae.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Authenticated endpoint context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-isa.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-isa.svg
	width 72text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-esa.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-esa.svg
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ESP SA context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard
This chapter describes the implementation of the design outlined in the
 previous chapter.
 The first section briefly presents how the interface is described in XML,
 how that specification is transformed into various formats and what parts
 of the system are generated based on that specification.
 The next section then describes the remote procedure call library (RPC
\begin_inset Index idx
status open

\begin_layout Plain Layout
RPC
\end_layout

\end_inset

) which is used by the various components for communication.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:charon-tkm"

\end_inset

 gives an in-depth characterization of the changes to the strongSwan project,
 the newly implemented plugins and how the integration of Ada code into
 the existing project is realized.
 Following that the trusted key manager TKM implementation is presented.
\end_layout

\begin_layout Standard
The new component xfrm-proxy which provides ESP SA events to charon-tkm
 is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:xfrm-proxy"

\end_inset

.
 Additional libraries that are used by either TKM or xfrm-proxy are illustrated
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Additional-components"

\end_inset

.
 Finally limitations of the current implementation with regards to the design
 are listed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
\end_layout

\begin_layout Section
XML-Specification
\begin_inset CommandInset label
LatexCommand label
name "sec:XML-Specification"

\end_inset


\end_layout

\begin_layout Standard
The specification of the interface which is the basis of the communication
 of system components is done in XML.
 Extensible stylesheet language transformations (XSLT
\begin_inset Index idx
status open

\begin_layout Plain Layout
XSLT
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
XSLT is a language standardized by the W3C (World Wide Web Consortium) for
 transforming XML documents
\end_layout

\end_inset

) are used to generate many different representations of the XML document.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/xsl-transformations.svg
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
XSL Transformation of XML specification
\begin_inset CommandInset label
LatexCommand label
name "fig:XSL-Transformation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By automatically generating code and documentation from one single XML document
 assures that the generated documents are always in sync and there is no
 mismatch between the implementation and the specification.
 The cost of interface change and extension is lowered considerably since
 the generation process is automated and no manual steps are necessary.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:XSL-Transformation"

\end_inset

 shows the process of applying the XSL transformations to the specification
 and the various generated outputs.
\end_layout

\begin_layout Standard
An interesting example of such a transformation is the generation of the
 Ada context state machine code.
 Leveraging the newly added contract feature of Ada 2012, the transitions
 of a context state machine are translated into pre- and postconditions.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-spec"

\end_inset

 shows the specification of the 
\family typewriter
nc_create
\family default
 transition.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=XML"
inline false
status open

\begin_layout Plain Layout

<transition name="create">
\end_layout

\begin_layout Plain Layout

	<descr>Create new nonce.</descr>
\end_layout

\begin_layout Plain Layout

	<source_states>
\end_layout

\begin_layout Plain Layout

		<state name="clean"/>
\end_layout

\begin_layout Plain Layout

	</source_states>
\end_layout

\begin_layout Plain Layout

	<target>
\end_layout

\begin_layout Plain Layout

		<state name="created"/>
\end_layout

\begin_layout Plain Layout

		<field name="nonce"> nonce </field>
\end_layout

\begin_layout Plain Layout

	</target>
\end_layout

\begin_layout Plain Layout

</transition> 
\begin_inset Caption

\begin_layout Plain Layout
Specification of nonce create transition
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-spec"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The generated Ada code is shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-ada"

\end_inset

.
 The preconditions state that the nonce context with the given id must be
 in the 
\begin_inset Quotes eld
\end_inset

clean
\begin_inset Quotes erd
\end_inset

 state.
 This corresponds to the source state element of the XML specification.
 Transitioning to the target state 
\begin_inset Quotes eld
\end_inset

created
\begin_inset Quotes erd
\end_inset

 is assured by the postcondition.
 If a violation of a pre- or postcondition occurs a 
\begin_inset Quotes eld
\end_inset

System.Assertions.Assert_Failure
\begin_inset Quotes erd
\end_inset

 exception is raised by the Ada runtime.
 This assures that only transitions conforming to the specification are
 possible.
 Confidence that the code implements the specification can be raised further
 by applying the GNATprove
\begin_inset Index idx
status open

\begin_layout Plain Layout
GNATprove
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
GNATprove is a formal verification tool for Ada 2012 contracts.
 It can prove that subprograms respect their preconditions and postconditions.
\end_layout

\end_inset

 tool 
\begin_inset CommandInset citation
LatexCommand cite
key "gnatprove"

\end_inset

 to the source.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure create (Id : Types.nc_id_type;
\end_layout

\begin_layout Plain Layout

				  nonce : Types.nonce_type)
\end_layout

\begin_layout Plain Layout

with
\end_layout

\begin_layout Plain Layout

  Pre  => Is_Valid (Id) and then
\end_layout

\begin_layout Plain Layout

		 (Has_State (Id, clean)),
\end_layout

\begin_layout Plain Layout

  Post => Has_State (Id, created) and
\end_layout

\begin_layout Plain Layout

		  Has_nonce (Id, nonce);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Generated Ada nonce create procedure
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-ada"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another example of generated output are the state machine diagrams show
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-machines"

\end_inset

.
\end_layout

\begin_layout Standard
The following list enumerates the main XSLT output that is generated from
 the specification:
\end_layout

\begin_layout Description
Types Ada and C type definitions
\end_layout

\begin_layout Description
Constants Ada and C constant definitions
\end_layout

\begin_layout Description
RPC Ada RPC library with exported C functions, includes request/response
 marshaling and server-side exchange id to service procedure dispatching
\end_layout

\begin_layout Description
Contexts Ada context state machines including Ada 2012 contracts
\end_layout

\begin_layout Description
Documentation Types, constants and exchange description as well as state
 machine diagrams
\end_layout

\begin_layout Section
RPC library: tkm-rpc
\begin_inset CommandInset label
LatexCommand label
name "sub:tkm-rpc-library"

\end_inset


\end_layout

\begin_layout Standard
Since the main objective of this project is to separate security-critical
 functionality from untrusted software components and extract it into a
 TCB the need for a communication mechanism between the disjointed parts
 arises.
 The communication layer is abstracted into a self-contained library called
 tkm-rpc.
 It allows the untrusted and trusted side to exchange well-formed messages,
 so called request and responses, as defined by the interface specification.
\end_layout

\begin_layout Standard
At the core of an exchange are the request and response data types.
 Clients send a request object to a server and the server responds by sending
 back a corresponding response object.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Basic-operation"

\end_inset

 describes the general operation of the tkm-rpc library.
\end_layout

\begin_layout Standard
To make use of the tkm-rpc library clients simply include the necessary
 project or header files, which contain the type, constant definitions and
 procedure or function specifications.
 How the library is intended to be used by clients is described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Client-side-usage"

\end_inset

.
\end_layout

\begin_layout Standard
Server-side components are expected to provide an implementation of interface-sp
ecific procedures.
 How the server processing is done is illustrated in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Server-side-processing"

\end_inset

.
\end_layout

\begin_layout Standard
When appropriate the concrete implementation is illustrated using the 
\family typewriter
nc_create
\family default
 exchange, which is specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsub:Exchanges-nc-create"

\end_inset

.
\end_layout

\begin_layout Subsection
Basic operation
\begin_inset CommandInset label
LatexCommand label
name "sub:Basic-operation"

\end_inset


\end_layout

\begin_layout Standard
The tkm-rpc library provides an RPC
\begin_inset Index idx
status open

\begin_layout Plain Layout
RPC
\end_layout

\end_inset

 (remote procedure call) interface that use a data transmission channel
 to pass client requests to a server and responses back to the client.
 The basic layout of request and response data types are shown in figure
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-and-response"

\end_inset

.
 The operation type of a request or response specifies what exchange it
 is part of.
 Requests are matched to their corresponding responses using the req_id
 field.
 However, this is currently not implemented.
 It is a limitation of the current implementation, see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
 Support for multiple simultaneous exchanges and asynchronous request processing
 can be implemented using the req_id matching.
 Currently a call to the tkm-rpc library blocks the client until the server's
 response is received.
\end_layout

\begin_layout Standard
Most of the library code is automatically generated based on the XML specificati
on, as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:XML-Specification"

\end_inset

.
 Only the transport-specific parts of sending and receiving requests and
 responses using a specific communication method is implemented.
 The exchange of data is performed using UNIX domain sockets.
 The necessary networking functionality is provided by the Anet library,
 which is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anet"

\end_inset

.
\end_layout

\begin_layout Standard
The round trip of an exchange is illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Basic-IPC-operation"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ipc-overview.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Basic IPC operation
\begin_inset CommandInset label
LatexCommand label
name "fig:Basic-IPC-operation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A client calls a function or procedure that is specified by the TKM interface.
 That call is translated into a request object with the operation set to
 the corresponding exchange id.
 Any parameters are marshaled into data fields of the request object.
 The request is then transmitted to the server via a Unix domain socket
\begin_inset Foot
status open

\begin_layout Plain Layout
Unix domain sockets are a standard IPC mechanism and are part of the POSIX
 socket API
\end_layout

\end_inset

 TODO: reference to POSIX.
\end_layout

\begin_layout Standard
On the server side of the socket, the request object is unmarshaled.
 The operation is dispatched according to the exchange id and the parameters
 of the exchange are extracted from the request object.
 The call is then forwarded to the server passing it the necessary arguments
 sent by the client.
 At this point the server performs all necessary actions to service the
 requested operation.
 After the server has finished handling the operation, it returns result
 data.
 A response data object is created with the same exchange and request ids
 as the request object.
 The response parameters are then marshaled into the corresponding response
 data fields and the response object is sent back to the client via the
 Unix socket.
\end_layout

\begin_layout Standard
Back on the client side the response is unmarshaled and any return parameters
 are extracted from the response object.
 These values are then passed back to the client as out mode or return parameter
s thus completing the exchange.
\end_layout

\begin_layout Standard
A complete list of all IKE exchanges is given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-Exchanges"

\end_inset

.
\end_layout

\begin_layout Subsection
Request and Response types
\end_layout

\begin_layout Standard
Each exchange has a specific request and response type.
 These are generated from the XML specification and their basic structure
 is depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-and-response"

\end_inset

.
 Every request has a header which contains the exchange and the request
 identifier.
 Responses contain the same header information plus an additional status
 code.
 The result code signals success or error conditions to the caller using
 the constant values specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Constants"

\end_inset

.
\end_layout

\begin_layout Standard
Exchange specific data is stored in additional record fields after the header.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-request-specific-data"

\end_inset

 shows the generated data type of the 
\family typewriter
nc_create
\family default
 exchange, consisting of the header and request-specific data.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

type Data_Type is record
\end_layout

\begin_layout Plain Layout

   Nc_Id        : Types.Nc_Id_Type;
\end_layout

\begin_layout Plain Layout

   Nonce_Length : Types.Nonce_Length_Type;
\end_layout

\begin_layout Plain Layout

end record;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

for Data_Type use record
\end_layout

\begin_layout Plain Layout

   Nc_Id        at 0 range 0 ..
 (8 * 8) - 1;
\end_layout

\begin_layout Plain Layout

   Nonce_Length at 8 range 0 ..
 (8 * 8) - 1;
\end_layout

\begin_layout Plain Layout

end record;
\end_layout

\begin_layout Plain Layout

for Data_Type'Size use Data_Size * 8;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

type Request_Type is record
\end_layout

\begin_layout Plain Layout

   Header  : Request.Header_Type;
\end_layout

\begin_layout Plain Layout

   Data    : Data_Type;
\end_layout

\begin_layout Plain Layout

   Padding : Padding_Type;
\end_layout

\begin_layout Plain Layout

end record;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
nc_create request-specific data type
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-request-specific-data"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As is apparent, the requests parameters as specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsub:Exchanges-nc-create"

\end_inset

 have a corresponding record field in the exchange-specific data type.
 The exact memory layout of the record is specified using an Ada record
 representation clause.
 All requests like all response types are of the same size.
 Requests that are smaller than the required length are padded with zeros.
\end_layout

\begin_layout Standard
Responses are constructed following the same idiom.
\end_layout

\begin_layout Subsection
Client-side usage
\begin_inset CommandInset label
LatexCommand label
name "sub:Client-side-usage"

\end_inset


\end_layout

\begin_layout Standard
The purpose of an RPC library is to hide the complicated exchange and transport
 details from the user.
 It must be very easy to use and remote calls should look like local procedure
 or function calls to the client.
 The majority of the RPC client library is automatically generated from
 the XML specification.
 An exception is the transport layer.
 The next section explains the motivation and the operation of the transport
 layer abstraction.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Request-handling"

\end_inset

 illustrates how clients use the RPC library and how the internal processing
 works.
\end_layout

\begin_layout Subsubsection
Transport mechanism abstraction
\begin_inset CommandInset label
LatexCommand label
name "sub:Transport-mechanism-abstraction"

\end_inset


\end_layout

\begin_layout Standard
The transport layer constitutes the lowest level of the RPC library.
 To easy the usage of different communication mechanisms all necessary functiona
lity is encapsulated in the 
\family typewriter
Tkmrpc.Transport.Client
\family default
 package.
 The current implementation employs stream-oriented Unix sockets using the
 functionality provided by Anet, which is presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Anet"

\end_inset

.
 To run the TKM daemon on a different physical machine, switching to a TCP
 socket implementation and connecting to an IP address and port, is all
 that is necessary from the client's point of view.
\end_layout

\begin_layout Standard
The interface, which is automatically generated, is rather simple and only
 three procedures must be implemented, see listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Client-Tkmrpc-transport"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

with Tkmrpc.Request;
\end_layout

\begin_layout Plain Layout

with Tkmrpc.Response;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

package Tkmrpc.Transport.Client is
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   procedure Connect (Address : String);
\end_layout

\begin_layout Plain Layout

   --  Connect to the RPC server given by socket address.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   procedure Send (Data : Request.Data_Type);
\end_layout

\begin_layout Plain Layout

   --  Send request data to RPC server.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   procedure Receive (Data : out Response.Data_Type);
\end_layout

\begin_layout Plain Layout

   --  Receive response data from RPC server.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

end Tkmrpc.Transport.Client;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Client Tkmrpc transport abstraction
\begin_inset CommandInset label
LatexCommand label
name "lis:Client-Tkmrpc-transport"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before a client can do remote procedure calls using tkm-rpc it must connect
 to the remote server component specifying the filename of the UNIX socket,
 where the server is listening for exchanges.
 The 
\family typewriter
Send
\family default
 procedure is used to transmit request objects to the connected RPC server
 while the 
\family typewriter
Receive
\family default
 procedure returns a response object received from the server.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Request-handling"

\end_inset

 explains how the two procedures are used to implement request and response
 handling.
\end_layout

\begin_layout Subsubsection
Request handling
\begin_inset CommandInset label
LatexCommand label
name "sub:Request-handling"

\end_inset


\end_layout

\begin_layout Standard
Based on the XML exchange description Ada procedure definitions are generated.
 Since the exchanges are specified on a per-interface basis (e.g.
 ike) procedures belonging together are put in the same package, e.g.
 
\family typewriter
Tkmrpc.Clients.Ike
\family default
.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Nc_Create-procedure-declaration"

\end_inset

 shows the generated procedure declaration for the 
\family typewriter
nc_create
\family default
 exchange.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure Nc_Create
\end_layout

\begin_layout Plain Layout

  (Result       : out Results.Result_Type;
\end_layout

\begin_layout Plain Layout

   Nc_Id        : Types.Nc_Id_Type;
\end_layout

\begin_layout Plain Layout

   Nonce_Length : Types.Nonce_Length_Type;
\end_layout

\begin_layout Plain Layout

   Nonce        : out Types.Nonce_Type);
\end_layout

\begin_layout Plain Layout

  pragma Export (C, Nc_Create, "ike_nc_create");
\end_layout

\begin_layout Plain Layout

  pragma Export_Valued_Procedure
\end_layout

\begin_layout Plain Layout

    (Nc_Create,
\end_layout

\begin_layout Plain Layout

     Mechanism => (Nc_Id => Value, Nonce_Length => Value));
\end_layout

\begin_layout Plain Layout

--  Create a nonce.
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Nc_Create procedure declaration (client-side)
\begin_inset CommandInset label
LatexCommand label
name "lis:Nc_Create-procedure-declaration"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The export pragmas make the procedures callable from the C programming language.
 To enable the use of the library in C, a header file containing corresponding
 C function declarations for each exchange is also generated.
 Since the C language has no notion of packages and has one global namespace,
 all procedures are prefixed with the name of the interface they belong
 to.
 Thus the exchange to create a nonce is called 
\family typewriter
Nc_Create
\family default
 in Ada and 
\family typewriter
ike_nc_create
\family default
 in C.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:ike_nc_create-function-declarati"

\end_inset

 shows the C function declaration equivalent of the Ada procedure presented
 in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:ike_nc_create-function-declarati"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

/**
\end_layout

\begin_layout Plain Layout

 * Create a nonce.
\end_layout

\begin_layout Plain Layout

 */
\end_layout

\begin_layout Plain Layout

extern result_type ike_nc_create(const nc_id_type nc_id,
\end_layout

\begin_layout Plain Layout

                const nonce_length_type nonce_length,
\end_layout

\begin_layout Plain Layout

                nonce_type *nonce);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
ike_nc_create function declaration
\begin_inset CommandInset label
LatexCommand label
name "lis:ike_nc_create-function-declarati"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
When a client calls the Nc_Create procedure a request object is created,
 filling in the passed in parameters.
 Next the object is transmitted using the Send procedure described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Transport-mechanism-abstraction"

\end_inset

.
 Afterwards the Receive procedure is used to get a response from the server.
 The result parameters are extracted from the response data type and returned
 to the client.
\end_layout

\begin_layout Subsection
Server-side processing
\begin_inset CommandInset label
LatexCommand label
name "sub:Server-side-processing"

\end_inset


\end_layout

\begin_layout Standard
RPC servers are passive components which respond to requests sent by clients.
 The main focus of server-side processing is automatic mapping of requests
 to concrete exchanges as specified by the interface.
 A server implementation should not be burdened with the details of exchange
 and request id handling but concentrate on the implementation of the functional
ity prescribed by the exchange.
\end_layout

\begin_layout Standard
Much like the client part of the RPC library, most of the code is automatically
 generated.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Operation-dispatching"

\end_inset

 describes how incoming requests are dispatched to their corresponding exchange
 handlers.
 After that a description of error handling is given in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Error-handling"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Operation dispatching
\begin_inset CommandInset label
LatexCommand label
name "sub:Operation-dispatching"

\end_inset


\end_layout

\begin_layout Standard
All operations exposed to the client via the tkm-rpc library must be implemented
 by a RPC server.
 To ensure this, an Ada package containing procedure declarations is generated
 for each interface described in the XML specification.
 As can be seen by comparing listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Nc_Create-procedure-declaration-server"

\end_inset

 to listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Nc_Create-procedure-declaration"

\end_inset

, the client and server side procedure declarations are almost identical.
 The procedure is not exported since all processing is done in Ada and the
 procedure is not meant to be called from C code.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure Nc_Create
\end_layout

\begin_layout Plain Layout

  (Result       : out Results.Result_Type;
\end_layout

\begin_layout Plain Layout

   Nc_Id        : Types.Nc_Id_Type;
\end_layout

\begin_layout Plain Layout

   Nonce_Length : Types.Nonce_Length_Type;
\end_layout

\begin_layout Plain Layout

   Nonce        : out Types.Nonce_Type);
\end_layout

\begin_layout Plain Layout

--  Create a nonce.
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Nc_Create procedure declaration (server-side)
\begin_inset CommandInset label
LatexCommand label
name "lis:Nc_Create-procedure-declaration-server"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A server implementing the 
\shape italic
ike
\shape default
 interface must provide package body implementing the 
\family typewriter
Tkmrpc.Servers.Ike
\family default
 package.
\end_layout

\begin_layout Standard
A dispatcher which takes a request data object as input and calls the correspond
ing procedure according to the exchange identifier is generated also.
 This takes the burden of mapping exchange ids to correct operation handler
 from the server implementation.
 This avoids possible errors such as typos, which can be hard to detect.
 Additionally the generated code guarantees that all specified exchanges
 are handled and unknown exchanges are handled by returning an Invalid_Operation
 status code via response data object.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Ike-request-dispatcher"

\end_inset

 shows the procedure declaration of the Ike dispatcher, which is located
 in the (generated) 
\family typewriter
Tkmrpc.Dispatchers.Ike
\family default
 package.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure Dispatch
\end_layout

\begin_layout Plain Layout

  (Req : Request.Data_Type;
\end_layout

\begin_layout Plain Layout

   Res : out Response.Data_Type);
\end_layout

\begin_layout Plain Layout

--  Dispatch IKE request to concrete operation handler.
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Ike request dispatcher
\begin_inset CommandInset label
LatexCommand label
name "lis:Ike-request-dispatcher"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since data received from the client via the Unix socket is just a sequence
 of octets a method to translate the binary data into requests types and
 passing them to the presented dispatcher is needed.
 The different parts are brought together by the 
\family typewriter
Tkmrpc.Process_Stream
\family default
 generic.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Process-stream-generic"

\end_inset

 shows the declaration of the generic procedure.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

generic
\end_layout

\begin_layout Plain Layout

   with procedure Dispatch
\end_layout

\begin_layout Plain Layout

     (Req :     Request.Data_Type;
\end_layout

\begin_layout Plain Layout

      Res : out Response.Data_Type);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   with procedure Exception_Handler
\end_layout

\begin_layout Plain Layout

     (Ex : Ada.Exceptions.Exception_Occurrence) is null;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

procedure Tkmrpc.Process_Stream
\end_layout

\begin_layout Plain Layout

  (Recv_Data :     Ada.Streams.Stream_Element_Array;
\end_layout

\begin_layout Plain Layout

   Send_Data : out Ada.Streams.Stream_Element_Array;
\end_layout

\begin_layout Plain Layout

   Send_Last : out Ada.Streams.Stream_Element_Offset);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Process stream generic
\begin_inset CommandInset label
LatexCommand label
name "lis:Process-stream-generic"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To instantiate the generic a Dispatch procedure matching the given signature
 must be provided.
 Optionally an exception handler can also be specified.
 The generic Process_Stream procedure automatically converts stream data
 to Tkmrpc request/response objects and passes them on to the given dispatch
 procedure.
 The exception handler is called when the specified dispatching procedure
 raises an exception.
 How exceptions are handled is subject of the following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Error-handling"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Error handling
\begin_inset CommandInset label
LatexCommand label
name "sub:Error-handling"

\end_inset


\end_layout

\begin_layout Standard
The intended way for indicating errors during processing of client requests
 is by raising exceptions.
 Such an exception propagates all the way up to the 
\family typewriter
Process_Stream
\family default
 generic's exception block.
 There the result code of the response is set to failure to inidicate an
 error to the client.
\end_layout

\begin_layout Standard
This mechanism works well in combination with the automatically generated
 context state machines because violation of pre- and postconditions raise
 an 
\begin_inset Quotes eld
\end_inset

System.Assertions.Assert_Failure
\begin_inset Quotes erd
\end_inset

 exception, as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-ada"

\end_inset

.
 These are then properly processed by the 
\family typewriter
Process_Stream
\family default
 generic to relieve the server implementation of the burden of dealing with
 all possible error cases.
\end_layout

\begin_layout Standard
The current implementation returns 
\begin_inset Quotes eld
\end_inset

Invalid_Operation
\begin_inset Quotes erd
\end_inset

 if an error occurs and does not translate exceptions to their corresponding
 error codes, see also section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
\end_layout

\begin_layout Section
charon-tkm
\begin_inset CommandInset label
LatexCommand label
name "sec:charon-tkm"

\end_inset


\end_layout

\begin_layout Standard
The untrusted IKEv2 component used in conjunction with the trusted key manager
 infrastructure is implemented as a separate charon 'instance' in it's own
 directory below the strongSwan top-level source directory (
\family typewriter
src/charon-tkm
\family default
).
 This has the advantage that the TKM code is contained and does not mix
 with other strongSwan files.
 The charon-tkm binary startup code works like the already existing charon-nm
 instance, a special charon daemon variant to be used with the GNOME NetworkMana
ger project
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://projects.gnome.org/NetworkManager/
\end_layout

\end_inset


\end_layout

\end_inset

.
 The only difference is the registration of custom TKM plugins as final
 step in the startup phase.
 The charon-tkm daemon does not rely on the dynamic plugin loading mechanism
 for it's core plugins, they are statically registered before entering the
 main processing loop.
\end_layout

\begin_layout Standard
Since the charon-tkm code uses the tkm-rpc library written in Ada, the daemon
 has to be built using an Ada-aware toolchain.
 This integration of Ada code into the strongSwan codebase is explained
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Ada-integration"

\end_inset

.
 Apart from the library, the ESP SA event service and the special exception
 handler component are directly written in Ada inside the charon-tkm project
 itself.
 These subsystems are outlined in sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Exception-handler-(EH)"

\end_inset

.
\end_layout

\begin_layout Subsection
Ada integration
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-Ada-integration"

\end_inset


\end_layout

\begin_layout Standard
As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

, the tkm-rpc library is written in pure-Ada and uses the export feature
 of Ada (
\family typewriter
pragma
\family default
 Export) to make procedures available to the charon-tkm C code.
 To call Ada code from C requires an initialized Ada runtime (ZFP case ignored),
 that's why the special 
\family typewriter
adainit
\family default
 and 
\family typewriter
adafinal
\family default
 procedures must be called before and after Ada code is used.
 Setup and teardown of the Ada runtime is handled by the tkm-rpc library
 (tkmlib_init/tkmlib_final) but still imposes the requirement that the charon-tk
m code must be compiled with an Ada-aware toolchain to correctly compile,
 bind and link the daemon binary.
 TODO: explain why in detail.
\end_layout

\begin_layout Standard
strongSwan uses the GNU build system, also known as the Autotools
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/GNU_build_system
\end_layout

\end_inset


\end_layout

\end_inset

, to configure, compile and install the project.
 Ada projects using the GNAT Ada compiler normally use gnatmake or gprbuild
\begin_inset Foot
status open

\begin_layout Plain Layout
GNAT's Project Manager
\end_layout

\end_inset

 to build projects.
 Luckily these concepts are easily mixed by calling the respective GNAT
 project manager from inside a Makefile.
 The charon-tkm project provides a Makefile.am file which describes how to
 build the charon-tkm binary with gprbuild.
 The project uses the more advanced gprbuild manager because it provides
 improved support for mixed language projects (C and Ada in this case).
\end_layout

\begin_layout Subsection
Initialization
\end_layout

\begin_layout Standard
Before entering the main loop, the charon-tkm daemon calls the 
\family typewriter
tkm_init
\family default
 function implemented in 
\family typewriter
tkm.c
\family default
.
 This function initializes the tkm-rpc library explained above and also
 starts the exception handler (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Exception-handler-(EH)"

\end_inset

) used to catch Ada exceptions.
\end_layout

\begin_layout Standard
It then calls the 
\family typewriter
ike_init
\family default
 function to connect to the IKE interface of the TKM.
 After that the ESP SA event service is started which accepts ESA acquire
 and expire events from clients (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

).
 If no error occurred (which would result in the termination of the daemon),
 the initialization code instructs the TKM inside the TCB to reset itself
 to a pristine state by calling the 
\family typewriter
ike_tkm
\family default
_reset function.
 
\end_layout

\begin_layout Standard
Since the TKM supports a static number of contexts (see TODO), the upper
 limit of context IDs is requested from the TKM.
 This limit configuration is then passed on to the TKM ID manager which
 is initialized as final step along with the TKM chunk map.
\end_layout

\begin_layout Subsection
ID manager
\begin_inset CommandInset label
LatexCommand label
name "sub:ID-manager"

\end_inset


\end_layout

\begin_layout Standard
The TKM ID manager handles the management of the different context ID kinds.
 It's interface is very simple.
 The 
\family typewriter
acquire_id
\family default
 function can be used to acquire (reserve) a new ID for a given context
 (e.g.
 
\family typewriter
TKM_CTX_DH
\family default
 for a new DH context ID).
 The 
\family typewriter
release_id
\family default
 function releases an already reserved ID.
 If no ID can be acquired because no one is available, the 
\family typewriter
acquire_id
\family default
 function indicates this error by returning zero.
 The first valid ID of a given context always starts at one.
\end_layout

\begin_layout Subsection
Chunk map
\begin_inset CommandInset label
LatexCommand label
name "sub:Chunk-map"

\end_inset


\end_layout

\begin_layout Standard
The TKM code uses two main techniques to pass on information from one plugin
 to another for cases where the strongSwan interface is not prepared to
 handle the use case.
 These two techniques allowed to implement the required TKM functionality
 without being to invasive to the upstream strongSwan codebase.
 This is especially true for use cases which are only relevant for the TKM
 project with no benefit for the project as a whole.
\end_layout

\begin_layout Standard
One of these mechanisms uses a chunk map, the other is explained in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

.
 The chunk map can be used to store mappings of context IDs to chunks (which
 are chunks of binary data such as nonces or cryptographic keys).
 This is required to preserve context ID information over plugin borders.
 If for example the nonce plugin allocates a new nonce in a new context,
 this relation has to be stored because the strongSwan interfaces have no
 knowledge of context IDs, such IDs are only used inside the TKM code.
 Therefore, the nonce plugin would store the chunk to context ID relation
 in the chunk map.
 Another plugin which receives the nonce chunk (which is random enough to
 be unique) is able to retrieve the associated context ID by consulting
 the chunk map.
\end_layout

\begin_layout Subsection
Piggybacking
\begin_inset CommandInset label
LatexCommand label
name "sub:Piggybacking"

\end_inset


\end_layout

\begin_layout Standard
Another method of passing TKM specific information over plugin borders uses
 a piggybacking technique to store informational structs inside chunk (chunk_t)
 objects.
 strongSwan often treats such chunks as opaque values while passing them
 between plugins.
 This allows to store information like context IDs in it for other plugins
 which need this information to initiate an action with the TKM.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:isa_info_t-struct"

\end_inset

 shows the 
\family typewriter
isa_info_t
\family default
 informational structure used to transfer ISA information from the keymat
 of a parent SA to the keymat of the new IKE SA while rekeying.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

struct isa_info_t {
\end_layout

\begin_layout Plain Layout

	/** 	 
\end_layout

\begin_layout Plain Layout

     * Parent isa context id.
 	 
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

     isa_id_type parent_isa_id;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

	 * Authenticated endpoint context id.
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

     ae_id_type ae_id;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
isa_info_t struct
\begin_inset CommandInset label
LatexCommand label
name "lis:isa_info_t-struct"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For this purpose the skd data chunk returned by the 
\family typewriter
get_skd
\family default
 function is used.
 This is possible since the sk_d chunk is treated as an opaque value and
 handed to the 
\family typewriter
derive_ike_keys
\family default
 procedure of the new keymat as-is without  any processing.
 The information is stored in the skd chunk as shown by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Piggybacking"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

isa_info_t *isa_info;
\end_layout

\begin_layout Plain Layout

INIT(isa_info,
\end_layout

\begin_layout Plain Layout

     .parent_isa_id = this->isa_ctx_id,
\end_layout

\begin_layout Plain Layout

     .ae_id = this->ae_ctx_id,
\end_layout

\begin_layout Plain Layout

);  
\end_layout

\begin_layout Plain Layout

*skd = chunk_create((u_char *)isa_info, sizeof(isa_info_t)); 
\begin_inset Caption

\begin_layout Plain Layout
Piggybacking
\begin_inset CommandInset label
LatexCommand label
name "lis:Piggybacking"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nonce generation plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Nonce-generation"

\end_inset


\end_layout

\begin_layout Standard
Nonce generation plugins are a new feature of strongSwan introduced during
 this project.
 A nonce generation plugin is responsible to create new nonces needed in
 the IKE_SA_INIT and CHILD_CREATE_SA exchanges (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-CREATE_CHILD_SA"

\end_inset

).
 In case of the TKM, the nonce generation plugin requests a new nonce from
 the TKM by calling the 
\family typewriter
ike_nc_create
\family default
 RPC and then registers the nonce in the chunk map to store the nonce to
 context ID mapping.
 This mapping is used by other plugins which need to pass on a nonce context
 to the TKM for key derivation purposes.
\end_layout

\begin_layout Subsection
Diffie-Hellman plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Diffie-Hellman"

\end_inset


\end_layout

\begin_layout Standard
The TKM Diffie-Hellman plugin instructs the TKM to perform the DH protocol.
 On creation, the plugin calls the 
\family typewriter
ike_dh_create
\family default
 RPC with a new context ID acquired from the ID manager.
 This initiates the initial steps of the Diffie-Hellman protocol in the
 TKM.
 The plugin completes the DH exchange by calling the 
\family typewriter
ike_dh_generate_key
\family default
 function as soon it receives the public value when it's 
\family typewriter
set_other_public_value
\family default
 function is called as illustrated by figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Child-SA-establishment"

\end_inset

.
 No secret values leave the TCB at any time but the DH context stored in
 the TKM can be referenced later for key derivation by using the correct
 DH context ID.
\end_layout

\begin_layout Subsection
Keymat plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Keymat"

\end_inset


\end_layout

\begin_layout Standard
The charon-tkm code uses the new keymat registration facility developed
 during this project to register a special TKM keymat variant, which acts
 as proxy for the remote keying material stored in the TKM.
 The keymat is constructed together with an IKE SA and stays active for
 the lifetime of the SA.
 Upon construction, the TKM keymat plugin acquires an ISA context ID (
\family typewriter
TKM_CTX_ISA
\family default
) from the ID manager.
 It then behaves like the standard IKEv2 keymat, except that it does not
 store or receive any critical data.
 Calls to 
\family typewriter
derive_ike_keys
\family default
 and 
\family typewriter
derive_child_keys
\family default
 are dispatched into the TCB by using context IDs.
 The keys used to protect the IKE SA are returned to the keymat because
 they are not classified as critical (see section TODO).
\end_layout

\begin_layout Standard
The keymat plugin uses the piggybacking mechanism described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

 to forward information to other plugins or to extract required information
 from other sources.
 For example the 
\family typewriter
derive_child_keys
\family default
 function does nothing more than using the encryption key chunks to store
 information needed in the kernel IPsec plugin explained in the next section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:pluginKernel-IPsec"

\end_inset

.
 The actual child key derivation is postponed until the registered kernel
 plugin's 
\family typewriter
add_sa
\family default
 function is called by the task which takes care of child creation, see
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Child-SA-establishment"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Child-SA-establishment"

\end_inset

 labels (
\emph on
SI
\emph default
) and (
\emph on
IS
\emph default
).
\end_layout

\begin_layout Subsection
Kernel IPsec plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:pluginKernel-IPsec"

\end_inset


\end_layout

\begin_layout Standard
After keying material for a new child SA has been derived in the TKM, the
 child SA state must be established by using a kernel IPsec plugin.
 In the case of the TKM where no child keying material leaves the TCB and
 child SA policy handling is completely done by the TKM, the kernel plugin
 can be kept very simple.
 It only provides a custom 
\family typewriter
add_sa
\family default
 function used to instruct the TKM to derive child keys and install a new
 ESA (ESP SA) state inside the TCB's encrypter component.
 This is of course only possible if all preconditions for this operation
 are met.
\end_layout

\begin_layout Subsection
Private key plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Private-key"

\end_inset


\end_layout

\begin_layout Standard
The TKM private key plugin instructs the TKM to create and return the AUTH
 octet signature for a given ISA context.
 Since the code flow of the signature creation process involves two different
 plugins, namely the keymat and the private key plugin, information must
 be passed between these plugins.
 The AUTH octet chunk returned by the keymat's 
\family typewriter
get_auth_octets
\family default
 function is piggybacked in this case.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

 for an explanation of the piggybacking mechanism.
 The TKM keymat stores the associated ISA context ID and the initial message
 in the chunk and returns it to the caller, which is a pubkey authenticator
 in this case (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

).
 The public key authenticator then calls the sign operation of the private
 key plugin.
 The private key code extracts the stored data and calls the
\family typewriter
 ike_isa_sign
\family default
 operation to create the AUTH octet signature.
 The signature is then returned to the caller.
\end_layout

\begin_layout Standard
In its current implementation, the TKM private key plugin is hardcoded to
 a specific keypair (alice@strongswan.org used for strongSwan integration
 testing).
 The reason for this limitation lies in the way the code is searching for
 a matching private key to authenticate a connection.
 It uses the key fingerprint (which is encoded from the key's modulus and
 public exponent values) of a public key contained in the user certificate
 configured for a connection to find the corresponding private key.
 Since no real private key exists in the TKM-case because the private key
 never leaves the TCB, the TKM private key plugin must imitate a key fingerprint
 to be found.
\end_layout

\begin_layout Standard
The TKM private key handling must be rewritten at a later stage using a
 TKM specific credential set which provides an own implementation of a private
 key enumeration function (
\family typewriter
create_private_enumerator
\family default
 of 
\family typewriter
credential_set_t
\family default
).
 This way a configured private key could be fetched and installed in the
 credential manager on demand.
\end_layout

\begin_layout Subsection
Public key plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Public-key"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

 shows how the AUTH octet signature received from a peer is verified.
 Since the verification is done in the TKM, a dummy public key plugin must
 be provided which fakes the verification process in the untrusted part.
\end_layout

\begin_layout Standard
To make sure charon always uses the TKM public key plugin when processing
 public keys, it is registered first during daemon startup.
\end_layout

\begin_layout Subsection
Bus listener plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:plugin-Bus-listener"

\end_inset


\end_layout

\begin_layout Standard
To inform charon about the authorization result from the TKM, a mechanism
 called authorization hooks is used.
 The TKM bus listener plugin registers itself as listener for IKE messages
 and is consulted in the final step of the authorization round whether the
 peer has been correctly authorized.
\end_layout

\begin_layout Standard
The message hook is needed to extract the authorization payload from the
 incoming IKE_AUTH message from the peer and to store it in the keymat of
 the corresponding IKE SA this exchange is currently performed.
 This is done by calling the custom TKM keymat function 
\family typewriter
set_auth_payload
\family default
.
 Later this payload is used in the authorize hook of the bus listener hook
 to instruct the TKM to perform the authentication process in the TCB.
\end_layout

\begin_layout Standard
The authorize hook retrieves the keymat by using the associated IKE SA object
 received as function argument.
 It then allocates a new certificate chain context ID and calls the internal
 
\family typewriter
build_cert_chain
\family default
 function to construct the certificate trust chain of the received peer
 certificate.
 The peer's user certificate stored in the authentication configuration
 of the associated IKE SA is set as user certificate for this CC context
 in the TKM by calling the 
\family typewriter
ike_cc_set_user_certificate
\family default
 function.
 This is the certificate for which trust must be established.
 For all intermediate certificates, the 
\family typewriter
build_cert_chain
\family default
 function calls the TKM 
\family typewriter
ike_cc_add_certificate
\family default
 RPC.
 The TKM verifies the trust chain as explained in TODO.
 At the end the CA certificate of the chain in question is passed on to
 the TKM.
 This certificate must be bitwise identical to the one the TKM trusts (currently
 the TKM only trusts one CA certificate).
 If the trust chain could not be verified, the authorize hook returns failure
 and the authentication of the IKE SA does not succeed.
\end_layout

\begin_layout Standard
The the trust chain verification is successful, the authorize hook retrieves
 the authentication payload stored by the message hook from the keymat and
 passes it to the TKM by using the 
\family typewriter
ike_isa_auth
\family default
 RPC.
 The TKM uses the given certificate context which contains the now trusted
 peer public key to verify the signature.
\end_layout

\begin_layout Subsection
ESP SA event service (EES)
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-EES-Service"

\end_inset


\end_layout

\begin_layout Standard
The ESP SA event service provides the EES interface specified in TODO to
 clients.
 The service is written in Ada but linked into and started alongside the
 charon-tkm daemon.
 It uses the tkm-rpc library outlined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

 to implement its RPC interface.
\end_layout

\begin_layout Standard
The EES component accepts ESA acquire and expire events from clients and
 dispatches them into charon by using callbacks written in C.
 The callbacks use the strongSwan hydra kernel interface to initiate an
 acquire or expire event.
 The ESP SA service is used by the xfrm-proxy component to relay messages
 from the kernel's XFRM subsystem to charon.
 This is needed since charon, in this separation secnario, is no longer
 allowed to talk to the kernels IPsec SAD database directly for obvious
 reasons.
\end_layout

\begin_layout Subsection
Exception handler (EH)
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-Exception-handler-(EH)"

\end_inset


\end_layout

\begin_layout Standard
The charon TKM code provides a special exception handler which provides
 the functionality to log exception messages from within Ada code into the
 daemon's logfile.
 This mechanism is implemented using the Exceptions_Actions framework of
 the GNAT Ada runtime.
 An Ada procedure with the correct signature can be registered as handler
 for any exception occurring in the runtime.
 This also includes internal exceptions which are normally not seen by user
 code.
\end_layout

\begin_layout Standard
The registered exception handler calls the imported C function 
\family typewriter
Charon_Terminate
\family default
 which logs the exception message into the daemon's logfile and instructs
 it to terminate.
 
\end_layout

\begin_layout Section
TKM
\begin_inset CommandInset label
LatexCommand label
name "sec:TKM"

\end_inset


\end_layout

\begin_layout Standard
The TKM component implements a minimal trusted key manager as depicted in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Split-of-IKE"

\end_inset

 on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "fig:Split-of-IKE"

\end_inset

.
 It provides the critical functionality extracted from the strongSwan code
 base as explained in section TODO.
 The TKM is written in the Ada programming language and uses the tkm-rpc
 library described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

 to provide the IKE interface (TODO) via remote procedure calls.
 
\end_layout

\begin_layout Standard
The dispatching of incoming calls is done by providing a custom IKE server
 implementation (
\family typewriter
Tkmrpc.Servers.Ike
\family default
).
 From there the calls are forwarded to the appropriate subsystems explained
 in the following sections.
\end_layout

\begin_layout Subsection
Client communication
\end_layout

\begin_layout Standard
Exchanges between charon-tkm and the TKM daemon are transfered using a Unix
 domain socket.
 The TKM implementation instantiates the 
\family typewriter
Process_Stream
\family default
 generic described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Process-stream-generic"

\end_inset

 with the automatically generated IKE dispatcher and a logging procedure
 as exception handler.
 The procedure is used in conjunction with an Anet stream receiver to perform
 the request and response processing.
\end_layout

\begin_layout Subsection
Nonce generation
\end_layout

\begin_layout Standard
Nonces are used to guarantee freshness in the cryptographic operations used
 to derive keying material.
 Hence nonce values must be random and must not be predictable.
 The nonce handling is implemented in the 
\family typewriter
Tkm.Servers.Ike.Nonce
\family default
 package.
\end_layout

\begin_layout Standard
Currently, 
\family typewriter
/dev/urandom
\family default
 is used as random source inside the TKM.
 The quality of randomness provided by this source is considered strong
 enough for the current initial iteration.
 The design is such that the implementation could be easily replaced by
 a stronger random source at a later time.
\end_layout

\begin_layout Standard
The TKM guarantees that nonces are consumed once and can not be reused,
 as specified by requirement TODO.
 This is done using the auto-generated nonce FSM explained in section TODO.
 Each nonce is an instantiation of such a FSM.
 If the client requests to create a new context with a nonce ID which is
 already created, an assertion exception is raised and an error status is
 returned to the requester.
\end_layout

\begin_layout Subsection
Diffie-Hellman
\end_layout

\begin_layout Standard
Keying material used to protect a child SA is derived from the shared secret
 computed by a Diffie-Hellman exchange.
 This keying material is considered the most sensitive and must therefore
 reside in the TCB only.
 From this requirement follows that the TKM must implement the Diffie-Hellman
 protocol to perform the exchange on behalf of clients like the untrusted
 charon-tkm daemon.
\end_layout

\begin_layout Standard
Currently the TKM provides a Diffie-Hellman implementation for the 3072-bit
 and 4096-bit MODP Diffie-Hellman groups explained in RFC 3526 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3526"

\end_inset

 using the The GNU Multiple Precision Arithmetic Library
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://gmplib.org/
\end_layout

\end_inset


\end_layout

\end_inset

, for which an Ada binding exists
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://mtn-host.prjek.net/projects/libgmpada/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
An active DH exchange is stored in a DH FSM introduced in section TODO.
 The FSM pre- and postconditions assure that only valid states and transitions
 are allowed during an exchange.
 If the protocol specified by the DH FSM is violated, an assertion exception
 is raised and the requester is informed about the violation.
 DH contexts can only be consumed if they are in 'generated' state as shown
 by the state machine diagram TODO.
\end_layout

\begin_layout Subsection
Key derivation
\end_layout

\begin_layout Standard
The TKM implements the procedures needed to derive IKE and child keys as
 described by the following subsections.
 
\end_layout

\begin_layout Subsubsection
IKE SA keys
\begin_inset CommandInset label
LatexCommand label
name "sub:IKE-SA-keys"

\end_inset


\end_layout

\begin_layout Standard
The IKE SA (ISA) key derivation functionality in the TKM implements the
 mechanism described in RFC 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.14.
 To derive keys for an IKE SA, the derivation function first retrieves the
 associated DH and nonce contexts which must be in the correct state, otherwise
 an exception is raised.
 It then instantiates a pseudo-random function (PRF
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PRF
\end_layout

\end_inset

) needed to generate the SKEYSEED value as shown by formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:skeyseed"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
SKEYSEED=prf(Ni|Nr,shared\, secret)\label{eq:skeyseed}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The TKM provides a PRF which uses a hash-based message authentication code
 (HMAC
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
HMAC
\end_layout

\end_inset

) as base.
 The HMAC functionality is implemented as a flexible Ada generic which can
 be instantiated using different hash functions.
 The TKM currently does not implement it's own hash functions but instead
 re-uses the ones provided by GNAT.
 The HMAC generic is instantiated as shown by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-hmac-sha512"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

package Tkm.Crypto.Hmac_Sha512 is new Tkm.Crypto.Hmac
\end_layout

\begin_layout Plain Layout

  (Hash_Block_Size => 128,
\end_layout

\begin_layout Plain Layout

   Hash_Length     => 64,
\end_layout

\begin_layout Plain Layout

   Hash_Ctx_Type   => GNAT.SHA512.Context,
\end_layout

\begin_layout Plain Layout

   Initial_Ctx     => GNAT.SHA512.Initial_Context,
\end_layout

\begin_layout Plain Layout

   Update          => GNAT.SHA512.Update,
\end_layout

\begin_layout Plain Layout

   Digest          => GNAT.SHA512.Digest); 
\begin_inset Caption

\begin_layout Plain Layout
TKM HMAC SHA-512
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-hmac-sha512"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To derive the IKE SA keys, the 
\begin_inset Formula $prf+$
\end_inset

 function as specified in RFC 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.13 is required.
 This functionality is again provided by an Ada generic, which can be instantiat
ed using different PRF contexts matching the required signature.
 The 
\begin_inset Formula $prf+$
\end_inset

 function outputs a pseudorandom stream used for IKE SA encryption and integrity
 keys.
 The keys are returned to the untrusted caller as they are not considered
 critical itself.
 This is true under the assumption that the PRF function used to generate
 the keys is strong enough to make it impossible to reverse the process
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The TKM currently uses PRF-HMAC-SHA512 as PRF for the 
\begin_inset Formula $prf+$
\end_inset

 function
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
An authentication context is created alongside the ISA context after the
 IKE SA keying material has been successfully derived.
 This AE context must first be authenticated properly until child SA keys
 can be derived (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Child SA keys
\end_layout

\begin_layout Standard
The process of deriving keying material for a child SA is described in RFC
 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.17.
 The TKM only allows the derivation of child keys if the associated authenticati
on context (AE) is in the 'authenticated' state:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

pragma Precondition (Tkmrpc.Contexts.ae.Has_State
\end_layout

\begin_layout Plain Layout

   (Id    => Tkmrpc.Contexts.isa.get_ae_id (Id => Isa_Id),
\end_layout

\begin_layout Plain Layout

    State => Tkmrpc.Contexts.ae.authenticated)); 
\begin_inset Caption

\begin_layout Plain Layout
Create_Esa precondition
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-create-esa-precondition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The actual keying material for the child SA is derived using the 
\begin_inset Formula $prf+$
\end_inset

 function described in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-SA-keys"

\end_inset

.
 Currently the TKM only supports PRF_HMAC_SHA512 as base for the 
\begin_inset Formula $prf+$
\end_inset

, so the untrusted charon-tkm counterpart and the remote peer involved in
 the connection must be configured accordingly.
 The keys derived are pushed into the kernel's SA database (SAD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) using functionality provided by the xfrm-ada project described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

.
\end_layout

\begin_layout Standard
The TKM supports different configurations for ESA creation only differing
 in the way related nonce and DH contexts are consumed.
 The first child SA of a connection does not depend on nonce or DH contexts
 at all, because it is derived in conjunction with its IKE SA.
 Then there is the configuration where no PFS
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PFS
\end_layout

\end_inset

 is desired, so no new DH context must be created beforehand.
 TODO: cleanup, elaborate more
\end_layout

\begin_layout Subsection
Private key
\end_layout

\begin_layout Standard
The TKM only supports authentication schemes based on asymmetric cryptography.
 To create a signature using such a scheme, a private key is needed.
 The key to use can be specified on the command line using the 
\family typewriter
-k
\family default
 option.
 The TKM expects the key to be a RSA PCKS#1 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

 private key in DER
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.itu.int/ITU-T/x.690
\end_layout

\end_inset


\end_layout

\end_inset

 encoding and is loaded into the 
\family typewriter
Tkm.Private_Key
\family default
 package where it can be retrieved using a getter function.
 The functionality to load and parse the private key is provided by the
 x509-ada project described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:x509-Ada"

\end_inset

.
\end_layout

\begin_layout Subsection
CA certificate
\end_layout

\begin_layout Standard
To establish assurance in a user certificate provided by a remote peer,
 the trust chain of this certificate must be verified (see the following
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

).
 Hence the TKM needs a trust anchor which is embodied in a certificate authority
 (CA
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CA
\end_layout

\end_inset

).
 Currently the TKM only trusts one CA certificate which can be specified
 on the command line using the 
\family typewriter
-c
\family default
 option.
 The CA certificate in X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 format is loaded into the 
\family typewriter
Tkm.Ca_Cert
\family default
 package using the x509-ada (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:x509-Ada"

\end_inset

) project.
 The 
\family typewriter
Load
\family default
 procedure of the package checks the validity of the CA certificate and
 raises an exception if it is not valid.
\end_layout

\begin_layout Subsection
Authentication
\end_layout

\begin_layout Standard
As dictated by the requirement described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:req-Authentication"

\end_inset

, the authentication process must be performed by the TKM to assure the
 correctness of the process.
 The following sections outline the implemented mechanisms in detail.
\end_layout

\begin_layout Subsubsection
Signature generation
\begin_inset CommandInset label
LatexCommand label
name "sub:Signature-generation"

\end_inset


\end_layout

\begin_layout Standard
The TKM implements the RSASSA-PKCS1-v1_5 signature scheme with appendix
 as specified by RFC 3447 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

, section 8.2.
 The functionality is provided as Ada generic, allowing the instantiation
 with different hashing algorithms.
 Pre-instantiated instances are provided for SHA-1 and SHA-256 hash algorithms.
 The listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-signature-generation"

\end_inset

 shows how to create a signature using the PKCS#1 private key given on the
 command line.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   use X509.Keys;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   package RSA renames Crypto.Rsa_Pkcs1_Sha1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Signer  : RSA.Signer_Type;
\end_layout

\begin_layout Plain Layout

   Privkey : constant RSA_Private_Key_Type 
\end_layout

\begin_layout Plain Layout

      := Private_Key.Get;
\end_layout

\begin_layout Plain Layout

   Chunk   : Tkmrpc.Types.Byte_Sequence (1 ..
 5)
\end_layout

\begin_layout Plain Layout

      := (others => 10);
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   RSA.Init 
\end_layout

\begin_layout Plain Layout

    (Ctx   => Signer,
\end_layout

\begin_layout Plain Layout

     N     => Get_Modulus (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     E     => Get_Pub_Exponent (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     D     => Get_Priv_Exponent (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     P     => Get_Prime_P (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Q     => Get_Prime_Q (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Exp1  => Get_Exponent1 (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Exp2  => Get_Exponent2 (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Coeff => Get_Coefficient (Key => Privkey));
\end_layout

\begin_layout Plain Layout

   declare
\end_layout

\begin_layout Plain Layout

      Sig : constant Tkmrpc.Types.Byte_Sequence
\end_layout

\begin_layout Plain Layout

         := RSA.Generate (Ctx  => Signer,
\end_layout

\begin_layout Plain Layout

                          Data => Octets);
\end_layout

\begin_layout Plain Layout

   begin
\end_layout

\begin_layout Plain Layout

      --  Do something with the signature
\end_layout

\begin_layout Plain Layout

   end;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Signature generation
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-signature-generation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
On Line 4 a RSA signer is instantiated.
 Line 5 retrieves the private key stored in the 
\family typewriter
Tkm.Private_Key
\family default
 package and uses the parameters of this key to initialize the RSA signer
 on line 10.
 Finally, on line 21 the signature over the given data chunk is created
 using the 
\family typewriter
Generate
\family default
 procedure of the RSA package.
\end_layout

\begin_layout Standard
The same code is used to create a signature over the local AUTH octet chunk
 during the IKE_AUTH exchange, as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-IKE_AUTH"

\end_inset

.
 The charon IKEv2 daemon currently only supports AUTH octet signatures based
 on the SHA-1 hash algorithm, this must be improved in a future iteration
 so that other hash algorithms are possible.
\end_layout

\begin_layout Subsubsection
Signature verification
\begin_inset CommandInset label
LatexCommand label
name "sub:Signature-verification"

\end_inset


\end_layout

\begin_layout Standard
Similar to the signature generation outlined in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-generation"

\end_inset

, the TKM provides an Ada generic to verify RSASSA-PKCS1-v1_5 signatures
 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

.
 To perform a verification, a 
\family typewriter
RSA.Verifier_Type
\family default
 must be initialized using a public key extracted from a trusted certificate.
 The process of trust chain verification is explained in detail in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

.
\end_layout

\begin_layout Standard
During the IKE_AUTH exchange, the identity of a remote peer must be asserted.
 This is done by verifying the remote AUTH octet signature.
 If the signature validates, the authentication context (AE) of the IKE
 SA in question is set into the 'authenticated' state, meaning that it is
 now possible to establish child SAs (ESA) under this IKE SA (ISA).
\end_layout

\begin_layout Subsubsection
Certificate chain validation
\begin_inset CommandInset label
LatexCommand label
name "sub:Certificate-chain-validation"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-validation-overview"

\end_inset

 provides an overview of the steps performed to establish trust in the user
 certificate provided by a peer during the IKE_AUTH exchange.
 The chosen example involves three certificates: The user certificate 
\emph on
A
\emph default
, the intermediate CA certificate 
\emph on
B
\emph default
 and the trusted 
\emph on
CA
\emph default
.
 The goal of the process is to link the user's X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 certificate 
\emph on
A
\emph default
 to the 
\emph on
CA
\emph default
 trusted by the TKM.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-overview.svg
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain validation overview
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-validation-overview"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The user certificate depicted as certificate 
\emph on
A
\emph default
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-validation-overview"

\end_inset

 must be validated using the intermediate CA certificate 
\emph on
B
\emph default
 and the intermediate certificate 
\emph on
B
\emph default
 must be validated using the trusted 
\emph on
CA
\emph default
 certificate.
 Validation in the context of a certificate trust chain means to perform
 the following steps:
\end_layout

\begin_layout Enumerate
Checking the validity period of the certificate: The current time (
\family typewriter
Now
\family default
) must be within this period as illustrated by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-certificate-validity-check"

\end_inset

.
\end_layout

\begin_layout Enumerate
Verify the signature stored in the certificate by using the public key of
 the subsequent certificate (the issuer certificate).
\end_layout

\begin_layout Enumerate
TODO: additional checks? Issuer etc
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

function Is_Valid (V : Validity_Type) return Boolean
\end_layout

\begin_layout Plain Layout

is
\end_layout

\begin_layout Plain Layout

   use Ada.Calendar;
\end_layout

\begin_layout Plain Layout

   Now : constant Time := Clock;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   return V.Not_Before < Now and then Now < V.Not_After;
\end_layout

\begin_layout Plain Layout

end Is_Valid;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Certificate validity check
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-certificate-validity-check"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To initiate the trust chain validation process in the TKM, a new CC context
 must be instantiated by calling the 
\family typewriter
Cc_Set_User_Certificate
\family default
 RPC as illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-set-user"

\end_inset

.
 This call stores the user certificate in the CC for which trust must be
 established.
 Before storing the user certificate in the context, the validity is checked.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-set-user.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain set user certificate
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-set-user"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Intermediate CAs and the final CA are added to the CC context by calling
 the 
\family typewriter
Cc_Add_Certificate
\family default
 remote procedure call as shown by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-add-certs"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-add-cert.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain add certificates
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-add-certs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The TKM checks the validity of the intermediate CA (certificate 
\emph on
B
\emph default
 in this example) and performs a signature verification of the signature
 stored in the user certificate 
\emph on
A
\emph default
 using the public key of 
\emph on
B
\emph default
.
 The signature is checked using a RSA verifier as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

.
 If the signature verifies, the intermediate certificate 
\emph on
B
\emph default
 is stored in the context along with the user certificate 
\emph on
A
\emph default
.
 The 
\family typewriter
Cc_Add_Certificate
\family default
 procedure must be called multiple times for all intermediate CAs in the
 trust chain and also for the final root CA.
 The ordering of certificates delivered to the TKM is performed by the charon-tk
m bus listener plugin described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:plugin-Bus-listener"

\end_inset

.
 If the ordering is incorrect, the verification of the chain fails and the
 IKE SA can not be authenticated.
\end_layout

\begin_layout Standard
The next step is to link the intermediate certificate 
\emph on
B
\emph default
 with certificate 
\emph on
CA
\emph default
, which is also handed to the trusted part by charon-tkm using 
\family typewriter
Cc_Add_Certificate
\family default
.
 The signature contained in certificate 
\emph on
B
\emph default
 must be validated using the public key stored in the 
\emph on
CA
\emph default
 certificate received.
 If the verification is successful, the last step is to check that the top-level
 certificate matches the trusted root 
\emph on
CA
\emph default
, this is done by calling the 
\family typewriter
Cc_Check_Ca
\family default
 RPC as shown by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-check-ca"

\end_inset

.
 The last certificate added by the 
\family typewriter
Cc_Add_Certificate
\family default
 must be bit-wise identical to the CA trusted by the TKM.
 If this check succeeds, the CC context is set into the 'checked' state
 and the context can be used to verify signatures as explained in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-check-ca.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain check CA
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-check-ca"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Kernel SPD/SAD management
\end_layout

\begin_layout Standard
Since the Linux kernel stores sensitive keying material in its security-associat
ion database, the untrusted part is not allowed to access these databases.
 This must be assured by security mechanisms which are outside of the scope
 of this document.
 As a result, the TKM must manage the kernel's security-policy (SPD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SPD
\end_layout

\end_inset

) and security-association (SAD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) databases itself.
\end_layout

\begin_layout Standard
The xfrm-ada project (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

), which has been developed during this TKM project, is used to install
 security policies on TKM startup and also to manage SA states.
\end_layout

\begin_layout Section
xfrm-proxy
\begin_inset CommandInset label
LatexCommand label
name "sec:xfrm-proxy"

\end_inset


\end_layout

\begin_layout Standard
The xfrm-proxy component uses the xfrm-ada library (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

) developed in this project to communicate with charon's EES service (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

).
 See figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:XFRM-proxy-architecture"

\end_inset

 for an overview of the proxy architecture.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/xfrm-proxy-arch.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
XFRM proxy architecture
\begin_inset CommandInset label
LatexCommand label
name "fig:XFRM-proxy-architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the kernel stores critical IPsec policies and SA states, the charon
 daemon is no longer allowed to communicate with the kernel XFRM subsystem.
 
\end_layout

\begin_layout Standard
To make rekeying work in such a scenario, kernel XFRM acquire and expire
 messages must be delivered to charon by other means.
 The xfrm-proxy component subscribes to the kernel's XFRM subsystem acquire
 and expire multicast groups to receive events and delivers them to charon
 using the EES service.
 Charon then normally starts create or rekeying jobs for the policy or SA
 in question.
\end_layout

\begin_layout Section
Additional components
\begin_inset CommandInset label
LatexCommand label
name "sec:Additional-components"

\end_inset


\end_layout

\begin_layout Standard
Certain functionality which was needed for the implementation of the TKM
 has been realized in self-contained software projects or as extension to
 existing libraries.
\end_layout

\begin_layout Subsection
Anet
\begin_inset CommandInset label
LatexCommand label
name "sub:Anet"

\end_inset


\end_layout

\begin_layout Standard
Anet is a networking library for the Ada programming language.
 It is used by the trusted key manager and xfrm-proxy to open or connect
 to unix sockets and communicate with charon-tkm.
\end_layout

\begin_layout Standard
Anet has been released as open-source software under the GMGPL
\begin_inset Foot
status open

\begin_layout Plain Layout
GNAT Modified General Public License
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
GMGPL
\end_layout

\end_inset

 license and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=anet.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
xfrm-ada
\begin_inset CommandInset label
LatexCommand label
name "sub:xfrm-ada"

\end_inset


\end_layout

\begin_layout Standard
This project is an Ada binding to Linux's XFRM
\begin_inset Index idx
status open

\begin_layout Plain Layout
XFRM
\end_layout

\end_inset

 kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.kernel.org/
\end_layout

\end_inset


\end_layout

\end_inset

 interface.
 It provides the functionality required to add and delete XFRM policies
 and states.
\end_layout

\begin_layout Standard
The XFRM framework is used to implement the IPsec
\begin_inset Index idx
status open

\begin_layout Plain Layout
IPsec
\end_layout

\end_inset

 protocol suite in the Linux kernel.
 The XFRM states operate on the Security Association Database (SAD
\begin_inset Index idx
status open

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) and the XFRM policies operate on the Security Policy Database (SPD
\begin_inset Index idx
status open

\begin_layout Plain Layout
SPD
\end_layout

\end_inset

).
 Among other features, it provides ESP
\begin_inset Index idx
status open

\begin_layout Plain Layout
ESP
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4303"

\end_inset

 payload encryption with the key material provided by an userspace application.
\end_layout

\begin_layout Standard
The TKM uses the XFRM interface via the xfrm-ada library, to manage the
 SPD and SAD and provides the keys for ESP encryption to the kernel.
\end_layout

\begin_layout Standard
xfrm-ada has been released as open-source software under the GMGPL license
 and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=xfrm-ada.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
x509-Ada
\begin_inset CommandInset label
LatexCommand label
name "sub:x509-Ada"

\end_inset


\end_layout

\begin_layout Standard
This project is an Ada PKIX X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 library.
 It provides functionality to process ASN.1/DER-encoded TODO: REF X.680/X.690
 certificates and private keys.
\end_layout

\begin_layout Standard
x509-Ada has been released as open-source software under the GMGPL license
 and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=x509-ada.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Limitations
\begin_inset CommandInset label
LatexCommand label
name "sec:Limitations"

\end_inset


\end_layout

\begin_layout Standard
This section describes the limitations of the current realisation of the
 design outlined in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Design"

\end_inset

.
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
We have shown that...
\end_layout

\begin_layout Section
Achievements
\end_layout

\begin_layout Section
Future work
\end_layout

\begin_layout Standard
Integration into platform such as Linux containers, SELinux, Qubes OS or
 an SK
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "ike-separation"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
