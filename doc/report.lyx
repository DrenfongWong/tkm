#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\usepackage{tabu,longtable}
\usepackage{booktabs}
\usepackage{ifthen}

\definecolor{newyellow}{rgb}{1,1,0.8}
\definecolor{colKeys}{rgb}{0,0,1}
\definecolor{colIdentifier}{rgb}{0,0,0}
\definecolor{colComments}{rgb}{1,0,0}
\definecolor{colString}{rgb}{0,0.5,0}

\newenvironment{typedefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}r>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Size & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{vartypedefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}r>{\tt}r>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Data & \sf\bf Size & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{constantdefinition}[1]
{\begin{longtabu} to \textwidth {>{\tt}l>{\tt}l>{\it}X}
\caption{#1} \\
\toprule\sf\bf Name & \sf\bf Hexvalue & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{contextstates}[1]
{\begin{longtabu} to \textwidth{>{\tt}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{contexttransitions}[1]
{\tabulinesep=4pt
\begin{longtabu} to \textwidth{>{\tt}lp{2.5cm}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Source  & \sf\bf Target & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{exchangeparameters}[1]
{\begin{longtabu} to \textwidth{>{\tt}l>{\tt}l>{\it}X}
\caption{#1} \\
\toprule
\sf\bf Name & \sf\bf Type & \sf\bf Description \\
\midrule
}{\bottomrule
\end{longtabu}}
\newenvironment{messages}{\bigskip
\begin{tabu} to \textwidth{l>{\tt}c>{\tt}ccc>{\it}X}}
{\end{tabu}\bigskip}
\newcommand{\msg}[4]{\ifthenelse{\equal{#1}{}}{}{#1\quad }
& \texttt{#2}
& \ifthenelse{\equal{#3}{}}{}{$\rightarrow$}
& \texttt{#3}
& \ifthenelse{\equal{#3}{}}{}{\ :\quad}
& \it{#4}\\}
\newcommand{\hex}[1]{\textrm{0x#1}}
\newcommand{\subscript}[1]{\ensuremath{_{\textrm{#1}}}}
\end_preamble
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "IKE Separation"
\pdf_author "Reto Buerki, Adrian-Ken Rüegsegger"
\pdf_subject "Extraction of security critical components into a Trusted Computing Base (TCB)"
\pdf_keywords "Separation, TCB, IPsec, IKE, IKEv2, Security, Ada"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks true
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\listings_params "backgroundcolor={\color{newyellow}},basicstyle={\ttfamily\small},breakautoindent=true,breaklines=true,captionpos=b,commentstyle={\color{colComments}},extendedchars=true,frame=single,identifierstyle={\color{colIdentifier}},keywordstyle={\color{colKeys}},language=Ada,numbers=left,numberstyle={\tiny},showspaces=false,showstringspaces=false,stringstyle={\color{colString}},tabsize=4"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
IKEv2 Separation:
\begin_inset Newline newline
\end_inset

Extraction of security critical components into a Trusted Computing Base
 (TCB)
\end_layout

\begin_layout Author
Reto Bürki, Adrian-Ken Rüegsegger
\end_layout

\begin_layout Standard
\align center
University of Applied Sciences Rapperswil (HSR), Switzerland
\end_layout

\begin_layout Abstract
The IPsec protocol relies on the correct operation of the IKE key exchange
 to meet its security goals.
 The implementation of the IKEv2 protocol is a non-trivial task and results
 in a large and complex code base.
 This makes it hard to gain a high degree of confidence in the correct operation
 of the code.
\end_layout

\begin_layout Abstract
The security and robustness of the IKEv2 implementation strongSwan has been
 augmented, by identifying and separating security critical from non-critical
 components and separating them into a minimal TCB.
 The TCB has been implemented using the Ada programming language.
\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList table

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstlistoflistings
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
This paper is organized as follows: The following overview section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Overview"

\end_inset

 provides an introduction into the concept and terms needed to understand
 the scope of this work.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Related-work"

\end_inset

 describes existing projects in the same field and section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

 explains the threat model the separation of the IKEv2 protocol is trying
 to solve.
\end_layout

\begin_layout Standard
The chapter/section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

 evaluates the ...
 TODO
\end_layout

\begin_layout Standard
Maybe omit the subsection and write all here as text?
\end_layout

\begin_layout Section
Overview
\begin_inset CommandInset label
LatexCommand label
name "sub:Overview"

\end_inset


\end_layout

\begin_layout Standard
This section provides an overview about the terminology used in this project
 and explains the basic key concepts.
\end_layout

\begin_layout Subsection
Trusted Computing Base
\begin_inset CommandInset label
LatexCommand label
name "sub:Trusted-Computing-Base"

\end_inset


\end_layout

\begin_layout Standard
In a system with a high demand for security or integrity, functions relevant
 to guarantee this demand must be isolated from the rest of the system in
 a Trusted Computing Base (TCB)
\begin_inset Index idx
status open

\begin_layout Plain Layout
TCB
\end_layout

\end_inset

.
 To be trusted, this code must be as minimal as possible to allow (formal)
 verification of code correctness.
 The TCB of a computer system is the set of all hardware, firmware, and/or
 software components that are critical to its security, in the sense that
 bugs or vulnerabilities occurring inside the TCB might jeopardize the security
 properties of the entire system
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/Trusted_computing_base
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is much easier to design a system from scratch with separation properties
 in mind than separating an existing project or protocol later.
 But this is obviously not always possible, like in this case.
 In order to isolate functionality in a TCB, critical sections of existing
 protocols must be identified and the system must be separated into a critical
 (TCB) and non-critical (untrusted) part.
 Communication mechanisms between the sections must be established, which
 itself must be robust and well defined.
 If an attacker is able to compromise the untrusted-part of the system,
 the security and integrity functions guaranteed by the TCB must still be
 in place.
\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Trusted-Computing-Base"

\end_inset

 depicts an example system involving a TCB.
 Components colored in red specify trusted components inside the TCB.
 The TCB normally consists of multiple such components which implement different
, separated functionality.
 One or more untrusted components colored in black exchange data with the
 TCB over a well-defined interface.
 This coloring scheme is used throughout this document to label untrusted
 and untrusted components.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trusted-untrusted.svg
	width 50text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Trusted Computing Base
\begin_inset CommandInset label
LatexCommand label
name "fig:Trusted-Computing-Base"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
strongSwan
\begin_inset Index idx
status open

\begin_layout Plain Layout
strongSwan
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sub:strongSwan"

\end_inset


\end_layout

\begin_layout Standard
The strongSwan project is an OpenSource IPsec-based VPN solution for Unix-like
 operating systems.
 It provides the charon daemon, which is a feature-rich implementation of
 the Internet key exchange protocol version 2 (IKEv2
\begin_inset Index idx
status open

\begin_layout Plain Layout
IKEv2
\end_layout

\end_inset

) as specified in 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
 The software is implemented using the C programming language with an object
 oriented (OO) approach.
 This allows to emulate modern programming paradigms while still using a
 standard C compiler and tool set
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://wiki.strongswan.org/projects/strongswan/wiki/ObjectOrientedC
\end_layout

\end_inset


\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
The strongSwan architecture is very flexible and easy to extend with new
 features.
 Almost every part of the daemon works as a plugin and new functionality
 can be added by simply writing a new plugin.
 This architecture proved very helpful in this present project, as very
 few changes were required in the upstream strongSwan code to implement
 the Trusted Key Manager (TKM, see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Trusted-Key-Manager"

\end_inset

) architecture.
\end_layout

\begin_layout Subsection
Ada
\begin_inset CommandInset label
LatexCommand label
name "sub:Ada"

\end_inset


\end_layout

\begin_layout Standard
Ada
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada
\end_layout

\end_inset

 is a structured, strongly typed programming language.
 The language has initially been designed by Jean Ichbiah from Honeywell
 Bull in the 1970s.
 Ada has a very similar structure to Pascal
\begin_inset Index idx
status open

\begin_layout Plain Layout
Pascal
\end_layout

\end_inset

 and is often used for systems with a demand for security and integritiy
 or which have a huge code base.
\end_layout

\begin_layout Standard
The development of Ada was initiated by the US Department of Defense (DoD
\begin_inset Index idx
status open

\begin_layout Plain Layout
DoD
\end_layout

\end_inset

) in order to consolidate and supersede the hundreds of programming languages
 used in their countless projects.
 The new language should comply with all identified DoD requirements (dubbed
 
\begin_inset Quotes eld
\end_inset

Steelman Language Requirements
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Steelman78"

\end_inset

), which focused strongly on security and safety.
 
\end_layout

\begin_layout Standard
Ada was the first standardized high-level programming language 
\begin_inset CommandInset citation
LatexCommand cite
key "Ada83"

\end_inset

.
 The current version is Ada 2005
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada 2005
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "DBLP:books/sp/Ada2006"

\end_inset

 which supports all modern programming pa\SpecialChar \-
ra\SpecialChar \-
digms.
 The next major version of the language is planned to be complete in 2012
 and will naturally be called Ada 2012
\begin_inset Index idx
status open

\begin_layout Plain Layout
Ada 2012
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Ada compilers, before used in practice, have to pass a standardized test
 suite which guarantees the compliance of the compiler with the Ada standard.
 Since Ada provides many features which aid in the development of safety
 and security critical applications, it is nowadays mostly used in such
 areas where these aspects are important.
 The primary industries making use of Ada are namely avionics, railway systems,
 banking, military and space technology.
\end_layout

\begin_layout Standard
The language is named after Lady Ada Lovelace (1815-1852), the daughter
 of Lord Byron
\begin_inset Foot
status open

\begin_layout Plain Layout
Ada Lovelace - http://en.wikipedia.org/wiki/Ada_Lovelace
\end_layout

\end_inset

 who is considered to be the first computer programmer.
\end_layout

\begin_layout Subsection
Trusted Key Manager
\begin_inset CommandInset label
LatexCommand label
name "sub:Trusted-Key-Manager"

\end_inset


\end_layout

\begin_layout Standard
The Trusted Key Manager
\begin_inset Index idx
status open

\begin_layout Plain Layout
Trusted Key Manager
\end_layout

\end_inset

 is a minimal TCB developed during this project which implements the identified
 security-critical functions of the IKEv2 protocol using the Ada programming
 language.
 It uses the tkm-rpc
\begin_inset Index idx
status open

\begin_layout Plain Layout
tkm-rpc
\end_layout

\end_inset

 library to communicate with the strongSwan charon daemon.
 The tkm-rpc library is also written in Ada, see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

.
\end_layout

\begin_layout Section
Related work
\begin_inset CommandInset label
LatexCommand label
name "sub:Related-work"

\end_inset


\end_layout

\begin_layout Standard
The concept of separating larger systems into smaller, trusted parts dates
 back to John Rushby in 1981 
\begin_inset CommandInset citation
LatexCommand cite
key "Rushby:1981:DVS:1067627.806586"

\end_inset

.
 The most prominent implementations of the concept exist in the form of
 microkernels (µ-kernels), which provide the foundation to separate functionalit
y into smaller, separated parts by providing compartments for subjects running
 in userspace.
 Examples of such systems are Fiasco
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://os.inf.tu-dresden.de/fiasco/
\end_layout

\end_inset


\end_layout

\end_inset

, L4Ka::Pistachio
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.l4ka.org/65.php
\end_layout

\end_inset


\end_layout

\end_inset

 and Coyotos
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.coyotos.org/
\end_layout

\end_inset


\end_layout

\end_inset

.
 Type-1 (bare-metal) hypervisors like Xen are intentionally excluded from
 the list because Xen requires a complete Linux kernel (dom0) with direct
 access to hardware to work.
 The fact that the dom0 kernel must be accounted as part of the trusted
 system makes it unsuitable for in-depth review and therefore unusable as
 a TCB.
\end_layout

\begin_layout Standard
Even though the concept proposed by Rushby seems to offer many advantages
 related to security and integrity, it has not been widely realized.
 Common operating systems like Windows, Linux and *BSD variants use a monolithic
 kernel, which itself must be trusted as a whole, even though the compromise
 of a device driver can corrupt the complete system.
\end_layout

\begin_layout Standard
One reason seems to be the tremendous effort needed to adapt existing software
 to a separation concept.
 In order to move critical parts into a TCB, the existing code must be studied
 and sensitive parts re-implemented using the corresponding APIs and methods
 of the underlying separation platform.
 Of course, the complete system could be rewritten for the dedicated secure
 environment, but often this is not possible and especially not desired
 for code deemed as untrusted.
 The dedicated goal is to only re-implement sensitive parts while leaving
 the untrusted part mostly untouched.
\end_layout

\begin_layout Standard
Research has been done in the formal analysis of the IKEv1 and IKEv2 protocols
 
\begin_inset CommandInset citation
LatexCommand cite
key "Cremers:2011:KEI:2041225.2041249,DBLP:conf/sp/Meadows99"

\end_inset

, pointing out weaknesses in both standards.
 The separation of the sensitive part from the bulk of the IKE protocol
 seems to be a valuable effort to minimize the working surface of attacks.
 Nevertheless, the IKEv2 separation protocol described in this paper must
 still undergo the same formal verification as the original protocols to
 formally show the delivered security improvements compared to its un-separated
 ancestor.
\end_layout

\begin_layout Section
Threat model
\begin_inset CommandInset label
LatexCommand label
name "sub:Threat-model"

\end_inset


\end_layout

\begin_layout Standard
It is assumed that the stringSwan charon IKEv2 daemon, which is considered
 an untrusted software component in the designed architecture, is under
 complete control of the attacker.
 This means the attacker has complete access to all data available to the
 IKEv2 daemon and can execute arbitrary code with the privileges of charon.
 As a result of this assumption, charon is not allowed to have access to
 any data classified as critical.
 Also intermediate values which are needed to create critical values MUST
 be protected from access by untrusted components.
\end_layout

\begin_layout Chapter
Analysis of strongSwan
\end_layout

\begin_layout Standard
This section describes the current operation of the strongSwan charon IKEv2
 daemon.
 A deep understanding of these mechanisms is a prerequisite for the separation
 of the daemon in a trusted and untrusted part to achieve the requirements
 specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Section
IKEv2 protocol analysis
\begin_inset CommandInset label
LatexCommand label
name "sub:IKEv2-protocol-analysis"

\end_inset


\end_layout

\begin_layout Standard
The following section provides a detailed analysis of the IKEv2 message
 exchanges (as specified by 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

), focusing on the security relevance of the transmitted data.
 All communication using IKE consists of a request / response pair.
 
\end_layout

\begin_layout Standard
In the following descriptions, the payloads contained in the message are
 indicated by names as listed in table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:IKEv2-payloads"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notation
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Payload
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AUTH
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Authentication
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CERT
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Certificate
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CERTREQ
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Certificate Request
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
CP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Configuration
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Delete
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
EAP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Extensible Authentication
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
HDR
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IKE header (not a payload)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IDi 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identification - Initiator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
IDr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Identification - Responder
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
KE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key Exchange
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ni, Nr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nonce
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Notify
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SA
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Security Association
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Encrypted and Authenticated
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TSi
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Traffic Selector - Initiator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TSr
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Traffic Selector - Responder
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
V
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vendor ID
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKEv2 payloads
\begin_inset CommandInset label
LatexCommand label
name "tab:IKEv2-payloads"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Every IKE message contains a Message 
\begin_inset Formula $ID$
\end_inset

 as part of its fixed header (
\begin_inset Formula $HDR$
\end_inset

).
 This Message 
\begin_inset Formula $ID$
\end_inset

 is used to match up requests and responses, and to identify retransmissions
 of messages 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
 The fixed header does not contain information identified as critical, therefore
 the header is omitted from the discussion in the following sections.
 
\end_layout

\begin_layout Standard
A value is considered 'critical' if the untrusted part may not know it at
 all (i.e.
 is not allowed to be present in the untrusted parts memory region).
 Other payloads (such as 
\begin_inset Formula $AUTH$
\end_inset

) are calculated from critical values inside the TKM and then handed to
 the untrusted part.
\end_layout

\begin_layout Subsection
IKE_SA_INIT
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-IKE_SA_INIT"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE_SA_INIT
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first pair of messages (IKE_SA_INIT) negotiate cryptographic algorithms,
 exchange nonces, and do a Diffie-Hellman exchange 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{1}{A}{B}{HDR, SAi1, KEi, Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{2}{B}{A}{HDR, SAr1, KEr, Nr, [CERTREQ]}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SAi1
\emph default
 payload states the cryptographic algorithms the initiator supports for
 the IKE SA.
 This payload is not considered critical because the TKM only supports a
 subset of cryptographic algorithms, which are strong enough and believed
 to be secure.
 A misconfiguration of allowed proposals would only result in a non-functional
 configuration.
\end_layout

\begin_layout Standard
Child keys are derived from the shared secret value resulting from the Diffie-He
llman exchange after the IKE_SA_INIT messages.
 Therefore the TKM must implement the DH protocol in the TCB and provides
 the public 
\emph on
KE
\emph default
 payload to the untrusted part.
\end_layout

\begin_layout Standard
The nonce
\begin_inset Index idx
status open

\begin_layout Plain Layout
Nonce
\end_layout

\end_inset

 
\emph on
Ni
\emph default
 is used as input to cryptographic functions and provides freshness to the
 key derivation technique used to obtain keys for the child SA, and to ensure
 creation of strong pseudorandom bits from the Diffie-Hellman key.
 Therefore, the nonce 
\emph on
Ni
\emph default
 used in the initial exchange must be randomly chosen, must be at least
 128 bits in size, and must be at least half the key size of the negotiated
 pseudorandom function (PRF).
 These constraints are enforced again by the TKM.
\end_layout

\begin_layout Standard
Obviously, values created by the responder can not be controlled by the
 TKM so these values are taken as is.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="1" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
KEi, Ni
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical IKE_SA_INIT payloads
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
IKE_AUTH
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-IKE_AUTH"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
IKE_AUTH
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After the completion of the IKE_SA_INIT exchange, each party is able to
 compute SKEYSEED, from which all keys are derived for that IKE SA.
 The messages that follow are encrypted and integrity protected in their
 entirety, with the exception of the message headers.
 The keys used for the encryption and integrity protection are derived from
 SKEYSEED and are known as SK_e (encryption) and SK_a (authentication, a.k.a.
 integrity protection).
 A separate SK_e and SK_a is computed for each direction.
 The notation SK { ...
 } indicates that these payloads are encrypted and integrity protected using
 that direction's SK_e and SK_a (
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 1.2).
\end_layout

\begin_layout Standard
The DH protocol is implemented in the TKM so the SK_e and SK_a keys must
 be provided to the untrusted part.
 The generated IKE keys 
\emph on
SK
\emph default
 are not considered critical because an attacker taking over the untrusted
 part is already able to extract all information protected by these keys
 (see the threat model section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{3}{A}{B}{HDR, SK 
\backslash
{IDi, [CERT,] [CERTREQ,] [IDr,] AUTH, SAi2, TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{4}{B}{A}{HDR, SK 
\backslash
{IDr, [CERT,] AUTH, SAr2, TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The initiator asserts its identity with the 
\emph on
IDi
\emph default
 payload.
 This value is not sensitive so it's directly configured using the standard
 strongSwan configuration mechanism.
 Nevertheless, the TKM must enforce correct identities to assure that only
 trusted ones are allowed.
 This is done during the authentication process.
\end_layout

\begin_layout Standard
The Authentication payload 
\emph on
AUTH
\emph default
 contains data used for authentication purposes and is created by the TKM
 since it is created using data identified as sensitive.
 Only certificate-based authentication is supported (no PSK) and only the
 TKM can know the private key to generate the AUTH signature.
 The AUTH payload is handed to the untrusted part because the TKM assures
 that the PRF used to generate AUTH (see TODO) is strong enough.
\end_layout

\begin_layout Standard

\emph on
SAi2
\emph default
 is not considered critical and can be configured directly in the untrusted
 part.
 The TKM enforces the correct algorithms before deriving child keys.
 The same is true for the 
\emph on
TS
\emph default
 payloads.
 TODO CERT.
 The 
\emph on
CERTREQ
\emph default
 used to TODO payload can be used but makes no difference because the TKM
 currently trusts only one CA.
\end_layout

\begin_layout Standard
Payloads created by the responder can again not be controlled.
 The TKM enforces the selected algorithms before deriving child keys by
 consulting the policy.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK, AUTH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Enforced by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID, CERT, CERTREQ, SAi, TS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical IKE_AUTH payloads
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
CREATE_CHILD_SA
\begin_inset CommandInset label
LatexCommand label
name "sub:proto-CREATE_CHILD_SA"

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
CREATE_CHILD_SA
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SK
\emph default
 used to protect the CREATE_CHILD_SA exchange is the same as described in
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_AUTH"

\end_inset

.
 The 
\emph on
SK
\emph default
 is created by the TKM but handed to the untrusted part to protect the IKE
 exchanges from outside attackers.
 Attackers which have taken over the untrusted part are already able to
 extract all information protected by these keys.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{5}{A}{B}{HDR, SK 
\backslash
{SA, Ni, [KEi], TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{6}{B}{A}{HDR, SK 
\backslash
{SA, Nr, [KEr], TSi, TSr
\backslash
}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
SA
\emph default
 is again not considered critical and can be configured directly in the
 untrusted part.
 The TKM enforces the correct algorithms before deriving new child keys.
 The same is true for the 
\emph on
TS
\emph default
 payloads.
\end_layout

\begin_layout Standard
Depending on the PFS
\begin_inset Index idx
status open

\begin_layout Plain Layout
PFS
\end_layout

\end_inset

 configuration of the connection, the CREATE_CHILD_SA request may optionally
 contain a 
\emph on
KE
\emph default
 payload for an additional Diffie-Hellman exchange to enable stronger guarantees
 of forward secrecy for the child SA.
 The keying material for the child SA is a function of SK_d created during
 the establishment of the IKE SA, the nonces exchanged during the CREATE_CHILD_S
A exchange, and the Diffie-Hellman value (if 
\emph on
KE
\emph default
 payloads are included in the CREATE_CHILD_SA exchange) (
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 1.3).
\end_layout

\begin_layout Standard
Payloads created by the responder can not be controlled but the algorithms
 selected from 
\emph on
SA
\emph default
 and the traffic selectors selected from 
\emph on
TS
\emph default
 must be checked by the TKM.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Created by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SK, Ni, [KEi]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
Enforced by TKM
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SAi, TS
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Critical CREATE_CHILD_SA payloads
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Code analysis
\begin_inset CommandInset label
LatexCommand label
name "sub:Code-analysis"

\end_inset


\end_layout

\begin_layout Standard
This section illustrates the charon source code, which processes the IKEv2
 message and other security relevant data as described by section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKEv2-protocol-analysis"

\end_inset

.
 Graphs are used to illustrate the code flow which implement a certain functiona
lity and possibilities to interfere with the current design are explored.
 
\end_layout

\begin_layout Subsection
IKE_SA_INIT
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-IKE_SA_INIT"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

 shows the code involved in the IKE SA establishment.
 The exchange involves an initiator and a responder which are displayed
 in separate blocks in the graph.
 During IKE_SA_INIT two messages are exchanged which are indicated between
 the initiator and responder code blocks.
 Round labels, e.g.
 the label 
\emph on
(CD
\emph default
) are references to subgraphs which illustrate a continuative process in
 detail.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-sa-init.svg
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
IKE SA establishment
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-establishment"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
IKE exchanges are implemented as task entities in charon and life in the
 
\family typewriter
libcharon/sa/ikev2/tasks
\family default
 directory.
 The IKE SA establishment process is implemented in the 
\family typewriter
ike_init.c
\family default
 file in this directory.
 The tasks are implemented as FSM
\begin_inset Foot
status open

\begin_layout Plain Layout
Finite-state machine
\end_layout

\end_inset


\begin_inset Index idx
status open

\begin_layout Plain Layout
FSM
\end_layout

\end_inset

 which change state depending on internal or external events like received
 messages.
 The 
\family typewriter
NEED_MORE
\family default
 transition indicates that the state machine is expecting more data to proceed.
 This state separates the sending path from the receiving path inside the
 
\family typewriter
build_i/process_i
\family default
 and 
\family typewriter
process_r/build_r
\family default
 blocks of figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

.
 The tasks access required functionality by using requesting plugins from
 different factories.
 Examples of such plugins are RNGs
\begin_inset Foot
status open

\begin_layout Plain Layout
Random number generator
\end_layout

\end_inset

 or plugins which perform the DH exchange.
\end_layout

\begin_layout Standard
The initiator creates the payloads of the initial message in the 
\family typewriter
build_i
\family default
 code block during which the initial steps of the Diffie-Hellman protocol
 are performed.
 The task calls the 
\family typewriter
create_dh
\family default
 function of the 
\family typewriter
keymat
\family default
 object which internally requests a new DH plugin instance from the crypto
 factory and returns this instance to the calling task (
\emph on
CD
\emph default
).
 A 
\family typewriter
keymat
\family default
 object stores the complete IKE SA key material and is used to derive IKE
 and child SA keys.
 A 
\family typewriter
keymat
\family default
 object is always associated with an IKE SA inside the IKE SA manager.
\end_layout

\begin_layout Standard
After constructing all payloads, the initiator sends the IKE_SA_INIT message
 to the peer and waits for a response (error handling if no peer answers
 is omitted in this discussion).
 The responder processes the request in the 
\family typewriter
process_r
\family default
 code block and performs the DH protocol on his side.
 Since it already received the DH public value from the initiator, it is
 able to complete the DH exchange without waiting for further data.
 It then uses the SKEYSEED from the DH exchange to derive the IKE SA keying
 material (
\emph on
DK
\emph default
) and creates an IKE_SA_INIT response containing its DH public value to
 allow the initiator to complete the initial exchange on his side.
\end_layout

\begin_layout Standard
The initiator then also derives IKE SA keying material used to protect the
 following IKE_AUTH or CHILD_CREATE_SA exchanges (
\emph on
DK
\emph default
).
 This completes phase 1.
\end_layout

\begin_layout Subsection
IKE_AUTH
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-IKE_AUTH"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA authentication
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-authentication"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-authentication"

\end_inset

 shows the code involved during the authentication of an IKE SA.
 This exchange is more complex than the IKE_SA_INIT exchange, that's the
 reason why the graph contains seven subgraphs, including the one depicted
 in the separate figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-Certificate-trustchain"

\end_inset

 which illustrates the trustchain verification code flow.
 The subgraphs cross-reference themselves which is again indicated by round
 labels.
\end_layout

\begin_layout Standard
The initiator begins the exchange by building it's own AUTH payload used
 to prove his identity to the responder.
 This is done by creating a so called 'authenticator' (see the 
\emph on
CB
\emph default
 label) which is again implemented as a plugin.
 After that, the authenticator's 
\family typewriter
build
\family default
 function is called which is illustrated by the 
\emph on
BA
\emph default
-subgraph shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

.
 To construct the signed AUTH octets the authenticator plugin requests a
 private key (
\emph on
GP
\emph default
) matching a specific certificate configured for this connection.
 The returned private key is used to sign the AUTH octets requested from
 the keymat object (
\emph on
A8
\emph default
) of the associated IKE SA and is again implemented in a plugin.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth-ba-pa.svg
	width 90text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE public key authenticators
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-public-key-auth"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
It then sends a message containing the constructed payloads to the responder
 and waits for a response message (error handling omitted).
\end_layout

\begin_layout Standard
The responder creates a 'verifier' plugin to check the AUTH payload extracted
 from the initiator's message.
 The creation of a verifier plugin is depicted in the 
\emph on
CV
\emph default
 graph.
 It then processes the AUTH octets of the initiator by calling the verifier's
 
\family typewriter
process
\family default
 function (
\emph on
PA
\emph default
).
 The authenticator requests the AUTH octets from the IKE SA keymat (
\emph on
A8
\emph default
) and retrieves the associated public key needed to verfiy the signature
 from the credential manager.
 To use the public key, it's chain of trust must be verified.
 
\end_layout

\begin_layout Standard
The trustchain verification process is shown in (
\emph on
PU
\emph default
) of figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-Certificate-trustchain"

\end_inset

.
 The credential manager iterates over all certificates linked with the public
 key until it reaches a trusted CA certificate.
 TODO: explain more
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/ike-auth-pu.svg
	width 100text%

\end_inset


\begin_inset Caption

\begin_layout Plain Layout
IKE Certificate trustchain verification
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-Certificate-trustchain"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To create the response message, the responder performs the same steps as
 the initiator to create it's AUTH payload (
\emph on
CB
\emph default
, 
\emph on
BA
\emph default
).
 The initiator verifies the AUTH payload of the responder using the same
 steps as described for the responder (
\emph on
CV
\emph default
, 
\emph on
PA
\emph default
).
\end_layout

\begin_layout Standard
After the IKE SA is established, both peers normally install the first child
 SA.
 This step is omitted and explained in detail in the next section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-CHILD_CREATE_SA"

\end_inset

.
\end_layout

\begin_layout Subsection
CHILD_CREATE_SA
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-CHILD_CREATE_SA"

\end_inset


\end_layout

\begin_layout Standard
The CHILD_CREATE_SA exchange is implemented as task in the 
\family typewriter
child_create.c
\family default
 file.
 The initiator starts by collecting the traffic selectors and proposals
 from the configuration (not visible in the graph) and allocates a SPI by
 calling the 
\family typewriter
allocate_spi
\family default
 function.
 This function dispatches into the registered kernel plugin to acquire a
 free SPI from the OS kernel.
 If the connection has PFS
\begin_inset Foot
status open

\begin_layout Plain Layout
Perfect forward secrecy
\end_layout

\end_inset

 enabled, the initiator starts a new DH exchange and builds all required
 payloads.
 After sending the message, the task changes it's state to NEED_MORE and
 waits for an answer.
\end_layout

\begin_layout Standard
The responder processes the received CHILD_CREATE_SA message and extracts
 the contained payloads.
 It conducts the DH exchange and then directly installs the derived child
 SA keying material in the kernel.
 The complete process of deriving keys for the new child SA is depicted
 in 
\emph on
(SI
\emph default
).
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/child-create-sa.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Child SA establishment
\begin_inset CommandInset label
LatexCommand label
name "fig:Child-SA-establishment"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
First the child SA data structure associated with the task is set into the
 CHILD_INSTALLING state.
 The derive_child_keys function of the keymat is called to derive keying
 material for the child SA (
\emph on
DC
\emph default
).
 The kernel plugin's add_policy (
\emph on
IP
\emph default
) and add_sa (
\emph on
IS
\emph default
) functions are used to install the new policy and state into the kernel's
 SPD and SAD databases.
 If no errors occured, the state of the child SA is set to CHILD_INSTALLED
 and it it attached to the associated IKE SA object.
\end_layout

\begin_layout Standard
The responder then builds the payloads of the response message and sends
 it back to the initiator.
 The initiator processes the message and after extracting the payloads,
 it calls the select_and_install function to derive child keying material
 and install the new policy and state in the kernel.
\end_layout

\begin_layout Subsection
Source of randomness
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Source-of-randomness"

\end_inset


\end_layout

\begin_layout Standard
Randomness is provided by requesting a random number generator plugin instance
 (
\family typewriter
rng_t
\family default
) from the crypto factory of libstrongswan.
 This process is shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Nonce-generation"

\end_inset

 using the example of creating new nonces.
 As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

, nonces are used to guarantee freshness in the key derivation process and
 must be created using a good random source (TODO: explain good?).
\end_layout

\begin_layout Standard
Depending on the requested quality (RNG_WEAK or RNG_STRONG) a suitable RNG
 plugin providing the needed quality is created and returned to the caller
 by the crypto factory.
\end_layout

\begin_layout Standard
\align left
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/nonce-generation.svg
	width 80text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nonce generation
\begin_inset CommandInset label
LatexCommand label
name "fig:Nonce-generation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Payload encryption
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Payload-encryption"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-payload-enc"

\end_inset

 schematically shows the code involved in the encryption of payloads in
 the IKE message exchanges.
 If a new connection is initiated by calling the initiate function of the
 IKE SA, all tasks (see previous sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-IKE_SA_INIT"

\end_inset

 to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-CHILD_CREATE_SA"

\end_inset

) required to establish an IKE SA and the associated child SA are created
 and run by the task manager.
 The tasks then callback to the IKE SA 
\family typewriter
generate_message
\family default
 function to create the message sent to the peer in their exchange.
\end_layout

\begin_layout Standard
The 
\family typewriter
generate_message
\family default
 function calls the 
\family typewriter
generate
\family default
 function of the message which in turn checks if the message is required
 to be encrypted.
 If encryption is enabled, an encrypted payload is created by accessing
 the key material of the IKE SA's 
\family typewriter
keymat
\family default
 object.
 The actual encryption is done by a crypter plugin which in turn uses an
 RNG plugin to retrieve random bytes needed for the IV
\begin_inset Foot
status open

\begin_layout Plain Layout
Initialization vector
\end_layout

\end_inset

.
 TODO: explain AEAD
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/payload-encryption.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA payload encryption
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-payload-enc"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Payload decryption
\begin_inset CommandInset label
LatexCommand label
name "sub:flow-Payload-decryption"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-payload-dec"

\end_inset

 shows the process of payload decryption which reverses the process of payload
 encryption explained in the previous chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-Payload-encryption"

\end_inset

.
 An incoming message is processed by calling the task managers 
\family typewriter
process_message
\family default
 function.
 This function parses the message by calling the message 
\family typewriter
parse_body
\family default
 function with the keymat object from the IKE SA as function argument.
\end_layout

\begin_layout Standard
The 
\family typewriter
parse_body
\family default
 function calls 
\family typewriter
decrypt_payloads
\family default
 which determines if the payloads are encrypted or not.
 If they are, it decrypts them by using an encryption payload object which
 uses the keymat's keying material to decrypt and verify the payloads.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/payload-decryption.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA payload decryption
\begin_inset CommandInset label
LatexCommand label
name "fig:IKE-SA-payload-dec"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Design
\begin_inset CommandInset label
LatexCommand label
name "chap:Design"

\end_inset


\end_layout

\begin_layout Standard
The main concept is to separate the security relevant services from all
 other IKEv2 services and split the IKEv2 key management daemon into two
 components: a trusted and an untrusted part.
 The trusted part performs the critical services, stores all relevant keying
 material and exposes the necessary services to the untrusted component
 via a well defined and minimal interface.
 The split of the components must guarantee the fullfilment of the security
 requirements defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Requirements"

\end_inset

.
\end_layout

\begin_layout Section
Split of IKE
\end_layout

\begin_layout Standard
The charon software design is based on a plugin architecture.
 Almost every functional part of the daemon is implemented as a plugin.
 This provides the flexibility to extend or exchange specific parts of the
 system.
 As outlined in the code analysis section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Code-analysis"

\end_inset

, most security critical operations and values are already encapsulated
 in plugins.
 The changes needed to allow complete separation of the critical parts from
 the charon daemon are limited.
 Therefore, the architecture depicted in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Split-of-IKE"

\end_inset

 is proposed.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/design-overview.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Split of IKE into trusted and untrusted parts
\begin_inset CommandInset label
LatexCommand label
name "fig:Split-of-IKE"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
By implementing custom plugins which act as proxy between the trusted and
 untrusted parts of the component, it is possible to move the key material
 and related operations into the TCB.
 This ensures that the untrusted part has no direct access to security relevant
 data.
 The critical parts extracted from charon are implemented by the trusted
 key manager which is part of the TCB.
 
\end_layout

\begin_layout Standard
By using a well-defined interface, the internal functionality of the TCB’s
 key manager is completely hidden from the charon plugins.
 The plugins reference the data (and their associated state) needed for
 processing via context identifiers.
 They have no direct access to the objects referenced by the identifiers
 but can instruct the key manager to perform certain, allowed operations
 with the specified context(s).
 Only uncritical results of operations are returned to the caller plugin
 (e.g.
 the public value of a DH exchange).
 This architecture allows the trusted part to be minimal while the bulk
 of the charon code can be used as is, in the untrusted part to handle the
 vast majority of IKEv2 processing.
\end_layout

\begin_layout Standard
TODO: make context/ID handling a sep.
 section? explain upper limit of ID
\end_layout

\begin_layout Section
Requirements
\begin_inset CommandInset label
LatexCommand label
name "sec:Requirements"

\end_inset


\end_layout

\begin_layout Standard
This section outlines the identified requirements of the separated system
 in detail.
 The following section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Security-requirements"

\end_inset

 specifies the security requirements, while section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Functional-requirements"

\end_inset

 covers the functional requirements.
 Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Additional-requirements"

\end_inset

 describes additional requirements.
\end_layout

\begin_layout Subsection
Security requirements
\begin_inset CommandInset label
LatexCommand label
name "sub:Security-requirements"

\end_inset


\end_layout

\begin_layout Standard
The security requirements identified in this section specify the properties
 the TCB must enforce even in the event of a complete compromise of the
 untrusted part of the system (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Threat-model"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Separation of key material
\begin_inset CommandInset label
LatexCommand label
name "sub:Separation-of-key"

\end_inset


\end_layout

\begin_layout Standard
The untrusted part of the IKEv2 component must not have access to generated
 key material that is used for authentication of peers, encryption and integrity
 protection of user data (i.e.
 child SA keys).
 This also includes critical intermediate values, which may result from
 the key generation and key derivation process.
 
\end_layout

\begin_layout Standard
Excluded from the critical material are the keys used to protect the IKE
 SA.
 See section TODO for details.
\end_layout

\begin_layout Subsubsection
Cryptographic operations
\end_layout

\begin_layout Standard
All relevant cryptographic operations must be performed by the trusted computing
 base (TCB) to assure the correctness of the resulting values.
 Since key material is needed to perform crypto operations, this is also
 a consequence of the requirement specified in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Separation-of-key"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Authentication
\begin_inset CommandInset label
LatexCommand label
name "sub:Authentication"

\end_inset


\end_layout

\begin_layout Standard
The IKEv2 component must only allow IPSec SAs to be established for peers
 that have successfully been authenticated.
 The authentication must be performed by the TCB to assure the correctness
 of the process.
\end_layout

\begin_layout Standard
The authentication state in the TCB must always be unambiguously associated
 with the corresponding SA.
\end_layout

\begin_layout Subsubsection
Integrity
\end_layout

\begin_layout Standard
The security of the IKEv2 component must solely depend on the correct operation
 of the trusted part.
 The security operation of the system must not be violated by a misbehaving
 untrusted part.
\end_layout

\begin_layout Subsection
Functional requirements
\begin_inset CommandInset label
LatexCommand label
name "sub:Functional-requirements"

\end_inset


\end_layout

\begin_layout Standard
Functional requirements define what a system is trying to accomplish.
 This section ...
\end_layout

\begin_layout Subsubsection
Separation
\end_layout

\begin_layout Standard
The IKEv2 component must be separated into a trusted and untrusted part,
 to minimize the size and complexity of the TCB.
 The trusted part must enforce all security requirements specified in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Security-requirements"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Communication
\end_layout

\begin_layout Standard
The communication protocol between the trusted and untrusted parts must
 be simple, robust and well-defined to allow a verifiable implementation.
 
\end_layout

\begin_layout Subsection
Additional requirements
\begin_inset CommandInset label
LatexCommand label
name "sub:Additional-requirements"

\end_inset


\end_layout

\begin_layout Section
Critical components
\end_layout

\begin_layout Standard
This section maps the identified security requirements defined in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Security-requirements"

\end_inset

 to the concrete architecture of strongSwan outlined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Code-analysis"

\end_inset

 and describes functionality and data which must be moved to the TCB.
\end_layout

\begin_layout Subsection
Key agreement (DH)
\end_layout

\begin_layout Standard
No key material must be present in the untrusted part of the system ...
 outline which values are especially important (Xa etc).
\end_layout

\begin_layout Subsection
Nonce generation
\end_layout

\begin_layout Standard
Nonces play an important role and guarantee freshness.
 TODO: explain.
 The TCB must guarantee the freshness of the local nonce.
\end_layout

\begin_layout Subsection
Handling of key material (creation/storage)
\begin_inset CommandInset label
LatexCommand label
name "sub:Handling-of-key"

\end_inset


\end_layout

\begin_layout Standard
also intermediate values.
 Howto store them? Wipe and lock memory, limitations (does not work well
 -> use better mechanisms)
\end_layout

\begin_layout Paragraph
IKE keys: not critical, explain why
\end_layout

\begin_layout Subsection
Random numbers
\end_layout

\begin_layout Subsection
Cryptographic operations
\end_layout

\begin_layout Standard
sections about the ops, also signature verification
\end_layout

\begin_layout Subsection
Enforcement of policy
\end_layout

\begin_layout Standard
Only configured policy allowed, crypto ops must be strong enough -> at the
 moment no problem.
 we implement only a subset.
\end_layout

\begin_layout Section
Assumptions
\end_layout

\begin_layout Standard
IKE and TKM can only exchange messages via the well defined interface and
 are otherwise completely isolated from each other.
 In a real system this is very difficult to achieve since there are many
 possibilities for side channels, which have been demonstrated to work,
 see for example 
\begin_inset CommandInset citation
LatexCommand cite
key "cryptoeprint:2010:594"

\end_inset

,
\begin_inset CommandInset citation
LatexCommand cite
key "Zhang:2012:CSC:2382196.2382230"

\end_inset

 or 
\begin_inset CommandInset citation
LatexCommand cite
key "Aciicmez:2007:PSB:1229285.1266999"

\end_inset

.
 TODO: explain why this is out of scope and how this could be solved (e.g.
 SK, special algos for crypto).
\end_layout

\begin_layout Chapter
TKM interface
\end_layout

\begin_layout Standard
This chapter specifies the interface between the trusted and the untrusted
 parts of the system.
 In a first step an overview of the communication between IKE and TKM is
 given by describing how the main operations of IKE are achieved through
 the usage of the services provided by the interface.
 After the abstract illustration of the protocol, the data types and constants
 are specified.
 These are the building blocks of the message exchanges which are described
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exchanges"

\end_inset

.
\end_layout

\begin_layout Standard
TODO: Are state machines really part of the interface or are they part of
 how the TKM server-side of the interface is implemented?
\end_layout

\begin_layout Section
Protocol overview
\end_layout

\begin_layout Standard
This section gives an overview of the main IKE operations: creation and
 rekeying of IKE and Child SAs.
 The description presents the success case and specifies which parameters
 are passed back and forth between IKE and the TKM using the exchanges specified
 in the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-Exchanges"

\end_inset

.
\end_layout

\begin_layout Standard
In the illustrated negotiation of SAs with the peer IKE is assuming the
 role of the initiator of the exchanges.
 The responder case varies only slightly and is thus not presented here.
 Where necessary the exchanges provide a parameter called 
\shape italic

\begin_inset Quotes eld
\end_inset

initiator
\begin_inset Quotes erd
\end_inset


\shape default
 which is used to specify whether IKE is the initiator or responder of an
 IKEv2 message exchange with the remote peer.
\end_layout

\begin_layout Standard
Note that child SA and ESP
\begin_inset Index idx
status open

\begin_layout Plain Layout
ESP
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Encapsulating Security Payload is part of the IPsec protocol suite and provides
 authenticity, integrity and confidentiality of data packets.
\end_layout

\end_inset

 SA are used interchangeably.
\end_layout

\begin_layout Subsection
Creation of an IKE SA
\end_layout

\begin_layout Standard
In a first step the client gets a nonce and a Diffie Hellman public value
 from the TKM using the 
\family typewriter
nc_create
\family default
 and 
\family typewriter
dh_create
\family default
 operations:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates an IKE SA exchange with the remote peer, which
 is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

.
 Upon receipt of the peer's response the Diffie Hellman shared secret can
 be calculated.
 Thus IKE issues the 
\family typewriter
dh_generate_key
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM performs the calculation and stores the DH key for future consumption.
 No data other than the status code of the operation is passed back to IKE.
\end_layout

\begin_layout Standard
Using the previously created nonce and Diffie Hellman value plus the nonce
 (
\shape italic
Nr
\shape default
) received from the remote peer, a new IKE SA is created:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_create}{IKE}{TKM}{isa
\backslash
_id, ae
\backslash
_id, ia
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, init, spi
\backslash
subscript{local}, spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{sk
\backslash
_ai, sk
\backslash
_ar, sk
\backslash
_ei, sk
\backslash
_er}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The returned encryption and integrity protection keys can now be used by
 the IKE daemon to send encrypted and integrity protected IKEv2 messages
 to the remote peer.
 For a consideration of why these keys can be handed out by TKM to the untrusted
 side, please refer to section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Handling-of-key"

\end_inset

.
\end_layout

\begin_layout Standard
To authenticate itself to the remote peer the IKE daemon requests signed
 local authentication data from TKM using the 
\family typewriter
isa_sign
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_sign}{IKE}{TKM}{isa
\backslash
_id, lc
\backslash
_id, init
\backslash
_message}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{AUTH
\backslash
subscript{local}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In possesion of the necessary data and keys, the IKE_AUTH protocol step,
 described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_AUTH"

\end_inset

, is performed with the remote peer.
\end_layout

\begin_layout Standard
Upon reception of the peer's response the IKE daemon starts to validate
 the certificate chain of the remote peer certificate 
\shape italic
CERT
\shape default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_set
\backslash
_user
\backslash
_certificate}{IKE}{TKM}{cc
\backslash
_id, ri
\backslash
_id, autha
\backslash
_id, CERT}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Each certificate in the chain is added by issuing the 
\family typewriter
cc_add_certificate
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_add
\backslash
_certificate}{IKE}{TKM}{cc
\backslash
_id, autha
\backslash
_id, CERT}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Once the root of the certificate chain is reached it must be asserted that
 the CA is trusted.
 This is done using the 
\family typewriter
cc_check_ca
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{cc
\backslash
_check
\backslash
_ca}{IKE}{TKM}{cc
\backslash
_id, ca
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After successful verification of the remote certificate, IKE can authenticate
 the peer:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_auth}{IKE}{TKM}{isa
\backslash
_id, cc
\backslash
_id, init
\backslash
_message, AUTH
\backslash
subscript{remote}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As a final step the first child SA can be created issuing the 
\family typewriter
esa_create_first
\family default
 exchange:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_create
\backslash
_first}{IKE}{TKM}{esa
\backslash
_id, isa
\backslash
_id, sp
\backslash
_id, ea
\backslash
_id, esp
\backslash
_spi
\backslash
subscript{local}, esp
\backslash
_spi
\backslash
subscript{remote}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With this exchange processed successfully by TKM, IKE has established an
 IKE and one ESP SA which can be used to encrypt application data according
 to the associated security policy identified by 
\shape italic
sp_id
\shape default
.
\end_layout

\begin_layout Subsection
Creation of a Child SA
\begin_inset CommandInset label
LatexCommand label
name "sub:Child-SA-creation"

\end_inset


\end_layout

\begin_layout Standard
Creating a child SA is quite similar to creating an IKE SA.
 All steps related to peer authentication can be omitted since the remote
 identity has already been authenticated.
\end_layout

\begin_layout Standard
To create a new child SA with perfect forward secrecy (PFS) a fresh nonce
 and Diffie Hellman value must be created:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates a CREATE_CHILD_SA exchange with the remote
 peer (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-CREATE_CHILD_SA"

\end_inset

).
 Upon receipt of the peer's response the Diffie Hellman shared secret is
 calculated by issuing the 
\family typewriter
dh_generate_key
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM performs the calculation and stores the DH key for future consumption.
 Only the status code of the operation is passed back to IKE.
\end_layout

\begin_layout Standard
Finally the child SA can be created using the 
\family typewriter
esa_create
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_create}{IKE}{TKM}{esa
\backslash
_id, isa
\backslash
_id, sp
\backslash
_id, ea
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, initiator, esp
\backslash
_spi
\backslash
subscript{local}, esp
\backslash
_spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this final step the IKE daemon has successfully established a new
 child SA.
\end_layout

\begin_layout Subsection
Rekeying of an IKE SA
\end_layout

\begin_layout Standard
An IKE SA is rekeyed by replacing it with a new IKE SA.
 For this purpose a fresh nonce and a DH public value is needed:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{nc
\backslash
_create}{IKE}{TKM}{nc
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{Ni}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_create}{IKE}{TKM}{dh
\backslash
_id, dh
\backslash
_group}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{KEi}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The IKE daemon then initiates a CREATE_CHILD_SA exchange to rekey the existing
 IKE SA with the peer.
 Upon receipt of the peers response the Diffie Hellman shared secret can
 be calculated:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{dh
\backslash
_generate
\backslash
_key}{IKE}{TKM}{dh
\backslash
_id, KEr}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Rekeying of the IKE SA, identified by 
\shape italic
parent_isa_id
\shape default
, is performed using the 
\family typewriter
isa_create_child
\family default
 operation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_create
\backslash
_child}{IKE}{TKM}{isa
\backslash
_id, parent
\backslash
_isa
\backslash
_id, ia
\backslash
_id, dh
\backslash
_id, nc
\backslash
_id, Nr, initiator, spi
\backslash
subscript{local}, spi
\backslash
subscript{rem}}
\end_layout

\begin_layout Plain Layout


\backslash
msg{}{TKM}{IKE}{sk
\backslash
_ai, sk
\backslash
_ar, sk
\backslash
_ei, sk
\backslash
_er}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
TKM returns the new encryption and integrity keys of the new IKE SA, which
 from this point on is used to exchange IKEv2 messages with the remote peer.
\end_layout

\begin_layout Standard
To effectively complete the rekeying operation, the superseded IKE SA must
 be reset:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{isa
\backslash
_reset}{IKE}{TKM}{isa
\backslash
_id
\backslash
subscript{old}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that 
\shape italic
isa_id
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
subscript{old}
\end_layout

\end_inset


\shape default
 is the same as the 
\shape italic
parent_isa_id
\shape default
 used in the 
\family typewriter
isa_create_child
\family default
 operation.
\end_layout

\begin_layout Subsection
Rekeying of a Child SA
\end_layout

\begin_layout Standard
A child SA is rekeyed by replacing it with a new child SA.
 In order to achieve this, the steps described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Child-SA-creation"

\end_inset

 must be performed.
 After the new child SA has been established the new SA must be selected,
 making it the for ESP encryption:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_select}{IKE}{TKM}{esa
\backslash
_id}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only thing left to do is to reset the old, rekeyed child SA:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{messages}
\end_layout

\begin_layout Plain Layout


\backslash
msg{esa
\backslash
_reset}{IKE}{TKM}{esa
\backslash
_id
\backslash
subscript{old}}
\end_layout

\begin_layout Plain Layout


\backslash
end{messages}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Data types and constants
\end_layout

\begin_layout Standard
This section presents the data types and constants that are used in the
 specification of the TKM interface.
 They are referenced in the description of the interface exchanges, which
 follows in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Exchanges"

\end_inset

.
\end_layout

\begin_layout Subsection
Integer types
\begin_inset CommandInset label
LatexCommand label
name "sub:Integer-types"

\end_inset


\end_layout

\begin_layout Standard
These types are numeric integers.
 Their 
\family typewriter
size
\family default
 is specified in bytes, which is also the amount of memory an object of
 such a type consumes.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-integer.tex"

\end_inset


\end_layout

\begin_layout Subsection
Variable octet types
\end_layout

\begin_layout Standard
These types are octet sequences of variable size.
 
\family typewriter
Data
\family default
 is the maximum number of data bytes that can be stored in the octet sequence,
 while 
\family typewriter
size
\family default
 is the number of bytes an object of this type occupies in memory.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-varoctets.tex"

\end_inset


\end_layout

\begin_layout Subsection
Constants
\end_layout

\begin_layout Standard
The TKM interface specifies various numeric constants, which can be referenced
 by the IKE daemon or the TKM.
 All constants are typed which restricts their range of valid values.
 All constants are given in hexadecimal form.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/types-constants.tex"

\end_inset


\end_layout

\begin_layout Section
Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sec:Exchanges"

\end_inset


\end_layout

\begin_layout Standard
This section describes all exchanges of the different TKM interfaces.
 The interface is comprised of two service-specific parts: IKE and ESP Event
 Service (EES).
\end_layout

\begin_layout Standard
Communication is seen as an exchange of request and response message pairs
 between a client and a server.
 In the concrete implementation, which is presented in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:charon-tkm"

\end_inset

, the untrusted charon daemon takes the role of the client while TKM is
 the server of the IKE interface.
 Contrary charon acts as a server of the EES interface, described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

, while the xfrm-proxy (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:xfrm-proxy"

\end_inset

) implements the client side.
\end_layout

\begin_layout Standard
Exchanges are allocated an identifier (
\family typewriter
operation_type
\family default
 defined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Integer-types"

\end_inset

) which is unique on a per-interface basis.
\end_layout

\begin_layout Standard
Requests contain an identifier (
\family typewriter
req_id
\family default
)
\shape italic
 
\shape default
which is chosen by the client of an exchange.
 The server must set the 
\family typewriter
req_id
\family default
 of the corresponding response to be identical.
 This enables the client to match responses to their requests and handle
 multiple pending exchanges with possible 
\shape italic
out-of-order
\shape default
 arrival of responses.
\end_layout

\begin_layout Standard
The basic layout of a request and response object is show in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Request-and-response"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/request-response-structure.svg

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Request and response structure
\begin_inset CommandInset label
LatexCommand label
name "fig:Request-and-response"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
IKE Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sub:IKE-Exchanges"

\end_inset


\end_layout

\begin_layout Standard
All the following exchanges are used by IKE to communicate with the TKM
 and perform operations related to IKE or ESP SA establishment.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-nc_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-nc_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_generate_key.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-dh_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_set_user_certificate.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_add_certificate.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_check_ca.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-cc_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-ae_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_sign.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_auth.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_create_child.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-isa_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create_first.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_create_no_pfs.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_select.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-esa_reset.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_version.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_limits.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-IKE-tkm_reset.tex"

\end_inset


\end_layout

\begin_layout Subsection
ESP SA Event Service (EES) Exchanges
\begin_inset CommandInset label
LatexCommand label
name "sub:ESP-SA-Event"

\end_inset


\end_layout

\begin_layout Standard
The exchanges specified in this section are used by the xfrm-proxy to communicat
e with IKE.
 EES is used to send notifications about ESP SA events such as acquire or
 expire.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-EES-esa_acquire.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/interface-EES-esa_expire.tex"

\end_inset


\end_layout

\begin_layout Section
State machines
\begin_inset CommandInset label
LatexCommand label
name "sec:State-machines"

\end_inset


\end_layout

\begin_layout Standard
Contexts are used to describe stateful entities within the TKM.
 They are finite state machines (FSM
\begin_inset Index idx
status open

\begin_layout Plain Layout
FSM
\end_layout

\end_inset

) which have a set of states and transitions between those states.
 The FSM is in a specific state at any given time and can only change its
 state by performing a transition.
 A transition prescribes the source state the FSM has to be in, the actions
 to execute and the new target state once the transition has completed.
\end_layout

\begin_layout Standard
The state machine transitions to a known failure state if an error occurs.
 To recover from such an error the FSM has to be reinitialized by explicitly
 performing a reset operation.
\end_layout

\begin_layout Standard
The state of the overall TKM system can be interpreted as the sum of the
 states of all FSMs and their associated data at any given time.
\end_layout

\begin_layout Subsection
Graph notation
\end_layout

\begin_layout Standard
Each state machine is depicted by a diagram.
 Transitions are drawn as directed arrows from the source to the target
 state with a label identifying the name of the transition.
\end_layout

\begin_layout Standard

\shape italic
Reset
\shape default
 and 
\shape italic
error
\shape default
 transitions are treated differently in order to create less cluttered graphs.
 These two transitions can be triggered from any state so their labels are
 omitted and their arrows have different styles.
 Reset transitions are shown using blue lines and error transitions are
 marked with red dashed lines.
\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-nc.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-nc.svg
	width 57text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Nonce context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-dh.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-dh.svg
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Diffie Hellman context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-cc.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-cc.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Certificate chain context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-ae.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-ae.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Authenticated endpoint context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-isa.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-isa.svg
	width 72text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
IKE SA context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset include
LatexCommand input
filename "tex/contexts-esa.tex"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fsm-esa.svg
	width 85text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
ESP SA context state machine
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Implementation
\end_layout

\begin_layout Standard
This chapter describes the implementation of the design outlined in the
 previous chapter.
 The first section briefly presents how the interface is described in XML,
 how that specification is transformed into various formats and what parts
 of the system are generated based on that specification.
 The next section then describes the remote procedure call library (RPC
\begin_inset Index idx
status open

\begin_layout Plain Layout
RPC
\end_layout

\end_inset

) which is used by the various components for communication.
\end_layout

\begin_layout Standard
Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:charon-tkm"

\end_inset

 gives an in-depth characterization of the changes to the strongSwan project,
 the newly implemented plugins and how the integration of Ada code into
 the existing project is realized.
 Following that the trusted key manager TKM implementation is presented.
\end_layout

\begin_layout Standard
The new component xfrm-proxy which provides ESP SA events to charon-tkm
 is described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:xfrm-proxy"

\end_inset

.
 Additional libraries that are used by either TKM or xfrm-proxy are illustrated
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Additional-components"

\end_inset

.
 Finally limitations of the current implementation with regards to the design
 are listed in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Limitations"

\end_inset

.
\end_layout

\begin_layout Section
XML-Specification
\end_layout

\begin_layout Standard
The specification of the interface which is the basis of the communication
 of system components is done in XML.
 Extensible stylesheet language transformations (XSLT
\begin_inset Index idx
status open

\begin_layout Plain Layout
XSLT
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
XSLT is a language standardized by the W3C (World Wide Web Consortium) for
 transforming XML documents
\end_layout

\end_inset

) are used to generate many different representations of the XML document.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/xsl-transformations.svg
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
XSL Transformation of XML specification
\begin_inset CommandInset label
LatexCommand label
name "fig:XSL-Transformation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
By automatically generating code and documentation from one single XML document
 assures that the generated documents are always in sync and there is no
 mismatch between the implementation and the specification.
 The cost of interface change and extension is lowered considerably since
 the generation process is automated and no manual steps are necessary.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:XSL-Transformation"

\end_inset

 shows the process of applying the XSL transformations to the specification
 and the various generated outputs.
\end_layout

\begin_layout Standard
An interesting example of such a transformation is the generation of the
 Ada context state machine code.
 Leveraging the newly added contract feature of Ada 2012, the transitions
 of a context state machine are translated into pre- and postconditions.
 Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-spec"

\end_inset

 shows the specification of the 
\family typewriter
nc_create
\family default
 transition.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=XML"
inline false
status open

\begin_layout Plain Layout

<transition name="create">
\end_layout

\begin_layout Plain Layout

	<descr>Create new nonce.</descr>
\end_layout

\begin_layout Plain Layout

	<source_states>
\end_layout

\begin_layout Plain Layout

		<state name="clean"/>
\end_layout

\begin_layout Plain Layout

	</source_states>
\end_layout

\begin_layout Plain Layout

	<target>
\end_layout

\begin_layout Plain Layout

		<state name="created"/>
\end_layout

\begin_layout Plain Layout

		<field name="nonce"> nonce </field>
\end_layout

\begin_layout Plain Layout

	</target>
\end_layout

\begin_layout Plain Layout

</transition> 
\begin_inset Caption

\begin_layout Plain Layout
Specification of nonce create transition
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-spec"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset

The generated Ada code is shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:nc_create-ada"

\end_inset

.
 The preconditions state that the nonce context with the given id must be
 in the 
\begin_inset Quotes eld
\end_inset

clean
\begin_inset Quotes erd
\end_inset

 state.
 This corresponds to the source state element of the XML specification.
 Transitioning to the target state 
\begin_inset Quotes eld
\end_inset

created
\begin_inset Quotes erd
\end_inset

 is assured by the postcondition.
 If a violation of a pre- or postcondition occurs a 
\begin_inset Quotes eld
\end_inset

System.Assertions.Assert_Failure
\begin_inset Quotes erd
\end_inset

 exception is raised by the Ada runtime.
 This assures that only transitions conforming to the specification are
 possible.
 Confidence that the code implements the specification can be raised further
 by applying the GNATprove
\begin_inset Index idx
status open

\begin_layout Plain Layout
GNATprove
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
GNATprove is a formal verification tool for Ada 2012 contracts.
 It can prove that subprograms respect their preconditions and postconditions.
\end_layout

\end_inset

 tool 
\begin_inset CommandInset citation
LatexCommand cite
key "gnatprove"

\end_inset

 to the source.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

procedure create (Id : Types.nc_id_type;
\end_layout

\begin_layout Plain Layout

				  nonce : Types.nonce_type)
\end_layout

\begin_layout Plain Layout

with
\end_layout

\begin_layout Plain Layout

  Pre  => Is_Valid (Id) and then
\end_layout

\begin_layout Plain Layout

		 (Has_State (Id, clean)),
\end_layout

\begin_layout Plain Layout

  Post => Has_State (Id, created) and
\end_layout

\begin_layout Plain Layout

		  Has_nonce (Id, nonce);
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Generated Ada nonce create procedure
\begin_inset CommandInset label
LatexCommand label
name "lis:nc_create-ada"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Another example of generated output are the state machine diagrams show
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:State-machines"

\end_inset

.
\end_layout

\begin_layout Standard
The following list enumerates the main XSLT output that is generated from
 the specification:
\end_layout

\begin_layout Description
Types Ada and C type definitions
\end_layout

\begin_layout Description
Constants Ada and C constant definitions
\end_layout

\begin_layout Description
RPC Ada RPC library with exported C functions, includes request/response
 marshaling and server-side exchange id to service procedure dispatching
\end_layout

\begin_layout Description
Contexts Ada context state machines including Ada 2012 contracts
\end_layout

\begin_layout Description
Documentation Types, constants and exchange description as well as state
 machine diagrams
\end_layout

\begin_layout Section
RPC: tkm-rpc library
\begin_inset CommandInset label
LatexCommand label
name "sub:tkm-rpc-library"

\end_inset


\end_layout

\begin_layout Standard
What is tkm-rpc? How is it used by the components? How are the code files
 generated? example code on usage.
 Finite statemachines with pre/postcons.
 exception on violation
\end_layout

\begin_layout Standard
explain the stream dispatcher generic.
\end_layout

\begin_layout Section
charon-tkm
\begin_inset CommandInset label
LatexCommand label
name "sec:charon-tkm"

\end_inset


\end_layout

\begin_layout Standard
The untrusted IKEv2 component used in conjunction with the trusted key manager
 infrastructure is implemented as a separate charon 'instance' in it's own
 directory below the strongSwan top-level source directory (
\family typewriter
src/charon-tkm
\family default
).
 This has the advantage that the TKM code is contained and does not mix
 with other strongSwan files.
 The charon-tkm binary startup code works like the already existing charon-nm
 instance, a special charon daemon variant to be used with the GNOME NetworkMana
ger project
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://projects.gnome.org/NetworkManager/
\end_layout

\end_inset


\end_layout

\end_inset

.
 The only difference is the registration of custom TKM plugins as final
 step in the startup phase.
 The charon-tkm daemon does not rely on the dynamic plugin loading mechanism
 for it's core plugins, they are statically registered before entering the
 main processing loop.
\end_layout

\begin_layout Standard
Since the charon-tkm code uses the tkm-rpc library written in Ada, the daemon
 has to be built using an Ada-aware toolchain.
 This integration of Ada code into the strongSwan codebase is explained
 in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Ada-integration"

\end_inset

.
 Apart from the library, the ESP SA event service and the special exception
 handler component are directly written in Ada inside the charon-tkm project
 itself.
 These subsystems are outlined in sections 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Exception-handler-(EH)"

\end_inset

.
\end_layout

\begin_layout Subsection
Ada integration
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-Ada-integration"

\end_inset


\end_layout

\begin_layout Standard
As explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

, the tkm-rpc library is written in pure-Ada and uses the export feature
 of Ada (
\family typewriter
pragma
\family default
 Export) to make procedures available to the charon-tkm C code.
 To call Ada code from C requires an initialized Ada runtime (ZFP case ignored),
 that's why the special 
\family typewriter
adainit
\family default
 and 
\family typewriter
adafinal
\family default
 procedures must be called before and after Ada code is used.
 Setup and teardown of the Ada runtime is handled by the tkm-rpc library
 (tkmlib_init/tkmlib_final) but still imposes the requirement that the charon-tk
m code must be compiled with an Ada-aware toolchain to correctly compile,
 bind and link the daemon binary.
 TODO: explain why in detail.
\end_layout

\begin_layout Standard
strongSwan uses the GNU build system, also known as the Autotools
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://en.wikipedia.org/wiki/GNU_build_system
\end_layout

\end_inset


\end_layout

\end_inset

, to configure, compile and install the project.
 Ada projects using the GNAT Ada compiler normally use gnatmake or gprbuild
\begin_inset Foot
status open

\begin_layout Plain Layout
GNAT's Project Manager
\end_layout

\end_inset

 to build projects.
 Luckily these concepts are easily mixed by calling the respective GNAT
 project manager from inside a Makefile.
 The charon-tkm project provides a Makefile.am file which describes how to
 build the charon-tkm binary with gprbuild.
 The project uses the more advanced gprbuild manager because it provides
 improved support for mixed language projects (C and Ada in this case).
\end_layout

\begin_layout Subsection
Initialization
\end_layout

\begin_layout Standard
Before entering the main loop, the charon-tkm daemon calls the 
\family typewriter
tkm_init
\family default
 function implemented in 
\family typewriter
tkm.c
\family default
.
 This function initializes the tkm-rpc library explained above and also
 starts the exception handler (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Exception-handler-(EH)"

\end_inset

) used to catch Ada exceptions.
\end_layout

\begin_layout Standard
It then calls the 
\family typewriter
ike_init
\family default
 function to connect to the IKE interface of the TKM.
 After that the ESP SA event service is started which accepts ESA acquire
 and expire events from clients (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

).
 If no error occurred (which would result in the termination of the daemon),
 the initialization code instructs the TKM inside the TCB to reset itself
 to a pristine state by calling the 
\family typewriter
ike_tkm
\family default
_reset function.
 
\end_layout

\begin_layout Standard
Since the TKM supports a static number of contexts (see TODO), the upper
 limit of context IDs is requested from the TKM.
 This limit configuration is then passed on to the TKM ID manager which
 is initialized as final step along with the TKM chunk map.
\end_layout

\begin_layout Subsection
ID manager
\begin_inset CommandInset label
LatexCommand label
name "sub:ID-manager"

\end_inset


\end_layout

\begin_layout Standard
The TKM ID manager handles the management of the different context ID kinds.
 It's interface is very simple.
 The 
\family typewriter
acquire_id
\family default
 function can be used to acquire (reserve) a new ID for a given context
 (e.g.
 
\family typewriter
TKM_CTX_DH
\family default
 for a new DH context ID).
 The 
\family typewriter
release_id
\family default
 function releases an already reserved ID.
 If no ID can be acquired because no one is available, the 
\family typewriter
acquire_id
\family default
 function indicates this error by returning zero.
 The first valid ID of a given context always starts at one.
\end_layout

\begin_layout Subsection
Chunk map
\begin_inset CommandInset label
LatexCommand label
name "sub:Chunk-map"

\end_inset


\end_layout

\begin_layout Standard
The TKM code uses two main techniques to pass on information from one plugin
 to another for cases where the strongSwan interface is not prepared to
 handle the use case.
 These two techniques allowed to implement the required TKM functionality
 without being to invasive to the upstream strongSwan codebase.
 This is especially true for use cases which are only relevant for the TKM
 project with no benefit for the project as a whole.
\end_layout

\begin_layout Standard
One of these mechanisms uses a chunk map, the other is explained in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

.
 The chunk map can be used to store mappings of context IDs to chunks (which
 are chunks of binary data such as nonces or cryptographic keys).
 This is required to preserve context ID information over plugin borders.
 If for example the nonce plugin allocates a new nonce in a new context,
 this relation has to be stored because the strongSwan interfaces have no
 knowledge of context IDs, such IDs are only used inside the TKM code.
 Therefore, the nonce plugin would store the chunk to context ID relation
 in the chunk map.
 Another plugin which receives the nonce chunk (which is random enough to
 be unique) is able to retrieve the associated context ID by consulting
 the chunk map.
\end_layout

\begin_layout Subsection
Piggybacking
\begin_inset CommandInset label
LatexCommand label
name "sub:Piggybacking"

\end_inset


\end_layout

\begin_layout Standard
Another method of passing TKM specific information over plugin borders uses
 a piggybacking technique to store informational structs inside chunk (chunk_t)
 objects.
 strongSwan often treats such chunks as opaque values while passing them
 between plugins.
 This allows to store information like context IDs in it for other plugins
 which need this information to initiate an action with the TKM.
\end_layout

\begin_layout Standard
Listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:isa_info_t-struct"

\end_inset

 shows the 
\family typewriter
isa_info_t
\family default
 informational structure used to transfer ISA information from the keymat
 of a parent SA to the keymat of the new IKE SA while rekeying.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

struct isa_info_t {
\end_layout

\begin_layout Plain Layout

	/** 	 
\end_layout

\begin_layout Plain Layout

     * Parent isa context id.
 	 
\end_layout

\begin_layout Plain Layout

     */
\end_layout

\begin_layout Plain Layout

     isa_id_type parent_isa_id;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	/**
\end_layout

\begin_layout Plain Layout

	 * Authenticated endpoint context id.
\end_layout

\begin_layout Plain Layout

	 */
\end_layout

\begin_layout Plain Layout

     ae_id_type ae_id;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
isa_info_t struct
\begin_inset CommandInset label
LatexCommand label
name "lis:isa_info_t-struct"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For this purpose the skd data chunk returned by the 
\family typewriter
get_skd
\family default
 function is used.
 This is possible since the sk_d chunk is treated as an opaque value and
 handed to the 
\family typewriter
derive_ike_keys
\family default
 procedure of the new keymat as-is without  any processing.
 The information is stored in the skd chunk as shown by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Piggybacking"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=C"
inline false
status open

\begin_layout Plain Layout

isa_info_t *isa_info;
\end_layout

\begin_layout Plain Layout

INIT(isa_info,
\end_layout

\begin_layout Plain Layout

     .parent_isa_id = this->isa_ctx_id,
\end_layout

\begin_layout Plain Layout

     .ae_id = this->ae_ctx_id,
\end_layout

\begin_layout Plain Layout

);  
\end_layout

\begin_layout Plain Layout

*skd = chunk_create((u_char *)isa_info, sizeof(isa_info_t)); 
\begin_inset Caption

\begin_layout Plain Layout
Piggybacking
\begin_inset CommandInset label
LatexCommand label
name "lis:Piggybacking"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Nonce generation plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:Nonce-generation-plugin"

\end_inset


\end_layout

\begin_layout Standard
Nonce generation plugins are a new feature of strongSwan introduced during
 this project.
 A nonce generation plugin is responsible to create new nonces needed in
 the IKE_SA_INIT and CHILD_CREATE_SA exchanges (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-IKE_SA_INIT"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:proto-CREATE_CHILD_SA"

\end_inset

).
 In case of the TKM, the nonce generation plugin requests a new nonce from
 the TKM by calling the 
\family typewriter
ike_nc_create
\family default
 RPC and then registers the nonce in the chunk map to store the nonce to
 context ID mapping.
 This mapping is used by other plugins which need to pass on a nonce context
 to the TKM for key derivation purposes.
\end_layout

\begin_layout Subsection
Diffie-Hellman plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:Diffie-Hellman-plugin"

\end_inset


\end_layout

\begin_layout Standard
The TKM Diffie-Hellman plugin instructs the TKM to perform the DH protocol.
 On creation, the plugin calls the 
\family typewriter
ike_dh_create
\family default
 RPC with a new context ID acquired from the ID manager.
 This initiates the initial steps of the Diffie-Hellman protocol in the
 TKM.
 The plugin completes the DH exchange by calling the 
\family typewriter
ike_dh_generate_key
\family default
 function as soon it receives the public value when it's 
\family typewriter
set_other_public_value
\family default
 function is called as illustrated by figures 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-SA-establishment"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Child-SA-establishment"

\end_inset

.
 No secret values leave the TCB at any time but the DH context stored in
 the TKM can be referenced later for key derivation by using the correct
 DH context ID.
\end_layout

\begin_layout Subsection
Private key plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:Private-key-plugin"

\end_inset


\end_layout

\begin_layout Standard
The TKM private key plugin instructs the TKM to create and return the AUTH
 octet signature for a given ISA context.
 Since the code flow of the signature creation process involves two different
 plugins, namely the keymat and the private key plugin, information must
 be passed between these plugins.
 The AUTH octet chunk returned by the keymat's 
\family typewriter
get_auth_octets
\family default
 function is piggybacked in this case.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

 for an explanation of the piggybacking mechanism.
 The TKM keymat stores the associated ISA context ID and the initial message
 in the chunk and returns it to the caller, which is a pubkey authenticator
 in this case (see figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

).
 The public key authenticator then calls the sign operation of the private
 key plugin.
 The private key code extracts the stored data and calls the
\family typewriter
 ike_isa_sign
\family default
 operation to create the AUTH octet signature.
 The signature is then returned to the caller.
\end_layout

\begin_layout Standard
In its current implementation, the TKM private key plugin is hardcoded to
 a specific keypair (alice@strongswan.org used for strongSwan integration
 testing).
 The reason for this limitation lies in the way the code is searching for
 a matching private key to authenticate a connection.
 It uses the key fingerprint (which is encoded from the key's modulus and
 public exponent values) of a public key contained in the user certificate
 configured for a connection to find the corresponding private key.
 Since no real private key exists in the TKM-case because the private key
 never leaves the TCB, the TKM private key plugin must imitate a key fingerprint
 to be found.
\end_layout

\begin_layout Standard
The TKM private key handling must be rewritten at a later stage using a
 TKM specific credential set which provides an own implementation of a private
 key enumeration function (
\family typewriter
create_private_enumerator
\family default
 of 
\family typewriter
credential_set_t
\family default
).
 This way a configured private key could be fetched and installed in the
 credential manager on demand.
\end_layout

\begin_layout Subsection
Public key plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:Public-key-plugin"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:IKE-public-key-auth"

\end_inset

 shows how the AUTH octet signature received from a peer is verified.
 Since the verification is done in the TKM, a dummy public key plugin must
 be provided which fakes the verification process in the untrusted part.
\end_layout

\begin_layout Standard
To make sure charon always uses the TKM public key plugin when processing
 public keys, it is registered first during daemon startup.
\end_layout

\begin_layout Subsection
Keymat plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:Keymat-plugin"

\end_inset


\end_layout

\begin_layout Standard
The charon-tkm code uses the new keymat registration facility developed
 during this project to register a special TKM keymat variant, which acts
 as proxy for the remote keying material stored in the TKM.
 The keymat is constructed together with an IKE SA and stays active for
 the lifetime of the SA.
 Upon construction, the TKM keymat plugin acquires an ISA context ID (
\family typewriter
TKM_CTX_ISA
\family default
) from the ID manager.
 It then behaves like the standard IKEv2 keymat, except that it does not
 store or receive any critical data.
 Calls to 
\family typewriter
derive_ike_keys
\family default
 and 
\family typewriter
derive_child_keys
\family default
 are dispatched into the TCB by using context IDs.
 The keys used to protect the IKE SA are returned to the keymat because
 they are not classified as critical (see section TODO).
\end_layout

\begin_layout Standard
The keymat plugin uses the piggybacking mechanism described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Piggybacking"

\end_inset

 to forward information to other plugins or to extract required information
 from other sources.
 For example the 
\family typewriter
derive_child_keys
\family default
 function does nothing more than using the encryption key chunks to store
 information needed in the kernel IPsec plugin explained in the next section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Kernel-IPsec-interface-plugin"

\end_inset

.
 The actual child key derivation is postponed until the registered kernel
 plugin's 
\family typewriter
add_sa
\family default
 function is called by the task which takes care of child creation, see
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Child-SA-establishment"

\end_inset

 
\begin_inset CommandInset ref
LatexCommand vpageref
reference "fig:Child-SA-establishment"

\end_inset

 labels (
\emph on
SI
\emph default
) and (
\emph on
IS
\emph default
).
\end_layout

\begin_layout Subsection
Kernel IPsec interface plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:Kernel-IPsec-interface-plugin"

\end_inset


\end_layout

\begin_layout Standard
After keying material for a new child SA has been derived in the TKM, the
 child SA state must be established by using a kernel IPsec plugin.
 In the case of the TKM where no child keying material leaves the TCB and
 child SA policy handling is completely done by the TKM, the kernel plugin
 can be kept very simple.
 It only provides a custom 
\family typewriter
add_sa
\family default
 function used to instruct the TKM to derive child keys and install a new
 ESA (ESP SA) state inside the TCB's encrypter component.
 This is of course only possible if all preconditions for this operation
 are met.
\end_layout

\begin_layout Subsection
Bus listener plugin
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-Bus-listener-plugin"

\end_inset


\end_layout

\begin_layout Standard
To inform charon about the authorization result from the TKM, a mechanism
 called authorization hooks is used.
 The TKM bus listener plugin registers itself as listener for IKE messages
 and is consulted in the final step of the authorization round whether the
 peer has been correctly authorized.
\end_layout

\begin_layout Standard
The message hook is needed to extract the authorization payload from the
 incoming IKE_AUTH message from the peer and to store it in the keymat of
 the corresponding IKE SA this exchange is currently performed.
 This is done by calling the custom TKM keymat function 
\family typewriter
set_auth_payload
\family default
.
 Later this payload is used in the authorize hook of the bus listener hook
 to instruct the TKM to perform the authentication process in the TCB.
\end_layout

\begin_layout Standard
The authorize hook retrieves the keymat by using the associated IKE SA object
 received as function argument.
 It then allocates a new certificate chain context ID and calls the internal
 
\family typewriter
build_cert_chain
\family default
 function to construct the certificate trust chain of the received peer
 certificate.
 The peer's user certificate stored in the authentication configuration
 of the associated IKE SA is set as user certificate for this CC context
 in the TKM by calling the 
\family typewriter
ike_cc_set_user_certificate
\family default
 function.
 This is the certificate for which trust must be established.
 For all intermediate certificates, the 
\family typewriter
build_cert_chain
\family default
 function calls the TKM 
\family typewriter
ike_cc_add_certificate
\family default
 RPC.
 The TKM verifies the trust chain as explained in TODO.
 At the end the CA certificate of the chain in question is passed on to
 the TKM.
 This certificate must be bitwise identical to the one the TKM trusts (currently
 the TKM only trusts one CA certificate).
 If the trust chain could not be verified, the authorize hook returns failure
 and the authentication of the IKE SA does not succeed.
\end_layout

\begin_layout Standard
The the trust chain verification is successful, the authorize hook retrieves
 the authentication payload stored by the message hook from the keymat and
 passes it to the TKM by using the 
\family typewriter
ike_isa_auth
\family default
 RPC.
 The TKM uses the given certificate context which contains the now trusted
 peer public key to verify the signature.
\end_layout

\begin_layout Subsection
ESP SA event service (EES)
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-EES-Service"

\end_inset


\end_layout

\begin_layout Standard
The ESP SA event service provides the EES interface specified in TODO to
 clients.
 The service is written in Ada but linked into and started alongside the
 charon-tkm daemon.
 It uses the tkm-rpc library outlined in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:tkm-rpc-library"

\end_inset

 to implement its RPC interface.
\end_layout

\begin_layout Standard
The EES component accepts ESA acquire and expire events from clients and
 dispatches them into charon by using callbacks written in C.
 The callbacks use the strongSwan hydra kernel interface to initiate an
 acquire or expire event.
 The ESP SA service is used by the xfrm-proxy component to relay messages
 from the kernel's XFRM subsystem to charon.
 This is needed since charon, in this separation secnario, is no longer
 allowed to talk to the kernels IPsec SAD database directly for obvious
 reasons.
\end_layout

\begin_layout Subsection
Exception handler (EH)
\begin_inset CommandInset label
LatexCommand label
name "sub:charon-Exception-handler-(EH)"

\end_inset


\end_layout

\begin_layout Standard
The charon TKM code provides a special exception handler which provides
 the functionality to log exception messages from within Ada code into the
 daemon's logfile.
 This mechanism is implemented using the Exceptions_Actions framework of
 the GNAT Ada runtime.
 An Ada procedure with the correct signature can be registered as handler
 for any exception occurring in the runtime.
 This also includes internal exceptions which are normally not seen by user
 code.
\end_layout

\begin_layout Standard
The registered exception handler calls the imported C function 
\family typewriter
Charon_Terminate
\family default
 which logs the exception message into the daemon's logfile and instructs
 it to terminate.
 
\end_layout

\begin_layout Section
TKM
\end_layout

\begin_layout Standard
The TKM component implements a minimal trusted key manager as depicted in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Split-of-IKE"

\end_inset

 on page 
\begin_inset CommandInset ref
LatexCommand pageref
reference "fig:Split-of-IKE"

\end_inset

.
 It provides the critical functionality extracted from the strongSwan code
 base as explained in section TODO.
 The TKM is written in the Ada programming language and uses the tkm-rpc
 library described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

 to provide the IKE interface (TODO) via remote procedure calls.
 
\end_layout

\begin_layout Standard
The dispatching of incoming calls is done by providing a custom IKE server
 implementation (
\family typewriter
Tkmrpc.Servers.Ike
\family default
).
 From there the calls are forwarded to the appropriate subsystems explained
 in the following sections.
\end_layout

\begin_layout Subsection
Nonce generation
\end_layout

\begin_layout Standard
Nonces are used to guarantee freshness in the cryptographic operations used
 to derive keying material.
 Hence nonce values must be random and must not be predictable.
 The nonce handling is implemented in the 
\family typewriter
Tkm.Servers.Ike.Nonce
\family default
 package.
\end_layout

\begin_layout Standard
Currently, 
\family typewriter
/dev/urandom
\family default
 is used as random source inside the TKM.
 The quality of randomness provided by this source is considered strong
 enough for the current initial iteration.
 The design is such that the implementation could be easily replaced by
 a stronger random source at a later time.
\end_layout

\begin_layout Standard
The TKM guarantees that nonces are consumed once and can not be reused,
 as specified by requirement TODO.
 This is done using the auto-generated nonce FSM explained in section TODO.
 Each nonce is an instantiation of such a FSM.
 If the client requests to create a new context with a nonce ID which is
 already created, an assertion exception is raised and an error status is
 returned to the requester.
\end_layout

\begin_layout Subsection
Diffie-Hellman
\end_layout

\begin_layout Standard
Keying material used to protect a child SA is derived from the shared secret
 computed by a Diffie-Hellman exchange.
 This keying material is considered the most sensitive and must therefore
 reside in the TCB only.
 From this requirement follows that the TKM must implement the Diffie-Hellman
 protocol to perform the exchange on behalf of clients like the untrusted
 charon-tkm daemon.
\end_layout

\begin_layout Standard
Currently the TKM provides a Diffie-Hellman implementation for the 3072-bit
 and 4096-bit MODP Diffie-Hellman groups explained in RFC 3526 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3526"

\end_inset

 using the The GNU Multiple Precision Arithmetic Library
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://gmplib.org/
\end_layout

\end_inset


\end_layout

\end_inset

, for which an Ada binding exists
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://mtn-host.prjek.net/projects/libgmpada/
\end_layout

\end_inset


\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
An active DH exchange is stored in a DH FSM introduced in section TODO.
 The FSM pre- and postconditions assure that only valid states and transitions
 are allowed during an exchange.
 If the protocol specified by the DH FSM is violated, an assertion exception
 is raised and the requester is informed about the violation.
 DH contexts can only be consumed if they are in 'generated' state as shown
 by the state machine diagram TODO.
\end_layout

\begin_layout Subsection
Key derivation
\end_layout

\begin_layout Standard
The TKM implements the procedures needed to derive IKE and child keys as
 described by the following subsections.
 
\end_layout

\begin_layout Subsubsection
IKE SA keys
\begin_inset CommandInset label
LatexCommand label
name "sub:IKE-SA-keys"

\end_inset


\end_layout

\begin_layout Standard
The IKE SA (ISA) key derivation functionality in the TKM implements the
 mechanism described in RFC 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.14.
 To derive keys for an IKE SA, the derivation function first retrieves the
 associated DH and nonce contexts which must be in the correct state, otherwise
 an exception is raised.
 It then instantiates a pseudo-random function (PRF
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PRF
\end_layout

\end_inset

) needed to generate the SKEYSEED value as shown by formula 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:skeyseed"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
SKEYSEED=prf(Ni|Nr,shared\, secret)\label{eq:skeyseed}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The TKM provides a PRF which uses a hash-based message authentication code
 (HMAC
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
HMAC
\end_layout

\end_inset

) as base.
 The HMAC functionality is implemented as a flexible Ada generic which can
 be instantiated using different hash functions.
 The TKM currently does not implement it's own hash functions but instead
 re-uses the ones provided by GNAT.
 The HMAC generic is instantiated as shown by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-hmac-sha512"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

package Tkm.Crypto.Hmac_Sha512 is new Tkm.Crypto.Hmac
\end_layout

\begin_layout Plain Layout

  (Hash_Block_Size => 128,
\end_layout

\begin_layout Plain Layout

   Hash_Length     => 64,
\end_layout

\begin_layout Plain Layout

   Hash_Ctx_Type   => GNAT.SHA512.Context,
\end_layout

\begin_layout Plain Layout

   Initial_Ctx     => GNAT.SHA512.Initial_Context,
\end_layout

\begin_layout Plain Layout

   Update          => GNAT.SHA512.Update,
\end_layout

\begin_layout Plain Layout

   Digest          => GNAT.SHA512.Digest); 
\begin_inset Caption

\begin_layout Plain Layout
TKM HMAC SHA-512
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-hmac-sha512"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To derive the IKE SA keys, the 
\begin_inset Formula $prf+$
\end_inset

 function as specified in RFC 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.13 is required.
 This functionality is again provided by an Ada generic, which can be instantiat
ed using different PRF contexts matching the required signature.
 The 
\begin_inset Formula $prf+$
\end_inset

 function outputs a pseudorandom stream used for IKE SA encryption and integrity
 keys.
 The keys are returned to the untrusted caller as they are not considered
 critical itself.
 This is true under the assumption that the PRF function used to generate
 the keys is strong enough to make it impossible to reverse the process
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The TKM currently uses PRF-HMAC-SHA512 as PRF for the 
\begin_inset Formula $prf+$
\end_inset

 function
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
An authentication context is created alongside the ISA context after the
 IKE SA keying material has been successfully derived.
 This AE context must first be authenticated properly until child SA keys
 can be derived (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

).
\end_layout

\begin_layout Subsubsection
Child SA keys
\end_layout

\begin_layout Standard
The process of deriving keying material for a child SA is described in RFC
 5996 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5996"

\end_inset

, section 2.17.
 The TKM only allows the derivation of child keys if the associated authenticati
on context (AE) is in the 'authenticated' state:
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

pragma Precondition (Tkmrpc.Contexts.ae.Has_State
\end_layout

\begin_layout Plain Layout

   (Id    => Tkmrpc.Contexts.isa.get_ae_id (Id => Isa_Id),
\end_layout

\begin_layout Plain Layout

    State => Tkmrpc.Contexts.ae.authenticated)); 
\begin_inset Caption

\begin_layout Plain Layout
Create_Esa precondition
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-create-esa-precondition"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The actual keying material for the child SA is derived using the 
\begin_inset Formula $prf+$
\end_inset

 function described in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:IKE-SA-keys"

\end_inset

.
 Currently the TKM only supports PRF_HMAC_SHA512 as base for the 
\begin_inset Formula $prf+$
\end_inset

, so the untrusted charon-tkm counterpart and the remote peer involved in
 the connection must be configured accordingly.
 The keys derived are pushed into the kernel's SA database (SAD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) using functionality provided by the xfrm-ada project described in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

.
\end_layout

\begin_layout Standard
The TKM supports different configurations for ESA creation only differing
 in the way related nonce and DH contexts are consumed.
 The first child SA of a connection does not depend on nonce or DH contexts
 at all, because it is derived in conjunction with its IKE SA.
 Then there is the configuration where no PFS
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
PFS
\end_layout

\end_inset

 is desired, so no new DH context must be created beforehand.
 TODO: cleanup, elaborate more
\end_layout

\begin_layout Subsection
Private key
\end_layout

\begin_layout Standard
The TKM only supports authentication schemes based on asymmetric cryptography.
 To create a signature using such a scheme, a private key is needed.
 The key to use can be specified on the command line using the 
\family typewriter
-k
\family default
 option.
 The TKM expects the key to be a RSA PCKS#1 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

 private key in DER
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://www.itu.int/ITU-T/x.690
\end_layout

\end_inset


\end_layout

\end_inset

 encoding and is loaded into the 
\family typewriter
Tkm.Private_Key
\family default
 package where it can be retrieved using a getter function.
 The functionality to load and parse the private key is provided by the
 x509-ada project described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:x509-Ada"

\end_inset

.
\end_layout

\begin_layout Subsection
CA certificate
\end_layout

\begin_layout Standard
To establish assurance in a user certificate provided by a remote peer,
 the trust chain of this certificate must be verified (see the following
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

).
 Hence the TKM needs a trust anchor which is embodied in a certificate authority
 (CA
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
CA
\end_layout

\end_inset

).
 Currently the TKM only trusts one CA certificate which can be specified
 on the command line using the 
\family typewriter
-c
\family default
 option.
 The CA certificate in X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 format is loaded into the 
\family typewriter
Tkm.Ca_Cert
\family default
 package using the x509-ada (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:x509-Ada"

\end_inset

) project.
 The 
\family typewriter
Load
\family default
 procedure of the package checks the validity of the CA certificate and
 raises an exception if it is not valid.
\end_layout

\begin_layout Subsection
Authentication
\end_layout

\begin_layout Standard
As dictated by the requirement described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Authentication"

\end_inset

, the authentication process must be performed by the TKM to assure the
 correctness of the process.
 The following sections outline the implemented mechanisms in detail.
\end_layout

\begin_layout Subsubsection
Signature generation
\begin_inset CommandInset label
LatexCommand label
name "sub:Signature-generation"

\end_inset


\end_layout

\begin_layout Standard
The TKM implements the RSASSA-PKCS1-v1_5 signature scheme with appendix
 as specified by RFC 3447 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

, section 8.2.
 The functionality is provided as Ada generic, allowing the instantiation
 with different hashing algorithms.
 Already instantiated instances are provided for SHA-1 and SHA-256 hash
 algorithms.
 The listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-signature-generation"

\end_inset

 shows how to create a signature using the PKCS#1 private key given on the
 command line.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

declare
\end_layout

\begin_layout Plain Layout

   use X509.Keys;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   package RSA renames Crypto.Rsa_Pkcs1_Sha1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   Signer  : RSA.Signer_Type;
\end_layout

\begin_layout Plain Layout

   Privkey : constant RSA_Private_Key_Type 
\end_layout

\begin_layout Plain Layout

      := Private_Key.Get;
\end_layout

\begin_layout Plain Layout

   Chunk   : Tkmrpc.Types.Byte_Sequence (1 ..
 5)
\end_layout

\begin_layout Plain Layout

      := (others => 10);
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   RSA.Init 
\end_layout

\begin_layout Plain Layout

    (Ctx   => Signer,
\end_layout

\begin_layout Plain Layout

     N     => Get_Modulus (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     E     => Get_Pub_Exponent (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     D     => Get_Priv_Exponent (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     P     => Get_Prime_P (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Q     => Get_Prime_Q (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Exp1  => Get_Exponent1 (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Exp2  => Get_Exponent2 (Key => Privkey),
\end_layout

\begin_layout Plain Layout

     Coeff => Get_Coefficient (Key => Privkey));
\end_layout

\begin_layout Plain Layout

   declare
\end_layout

\begin_layout Plain Layout

      Sig : constant Tkmrpc.Types.Byte_Sequence
\end_layout

\begin_layout Plain Layout

         := RSA.Generate (Ctx  => Signer,
\end_layout

\begin_layout Plain Layout

                          Data => Octets);
\end_layout

\begin_layout Plain Layout

   begin
\end_layout

\begin_layout Plain Layout

      --  Do something with the signature
\end_layout

\begin_layout Plain Layout

   end;
\end_layout

\begin_layout Plain Layout

end;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Signature generation
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-signature-generation"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
On Line 4 a RSA signer is instantiated.
 Line 5 retrieves the private key stored in the 
\family typewriter
Tkm.Private_Key
\family default
 package and uses the parameters of this key to initialize the RSA signer
 on line 10.
 Finally, on line 21 the signature over the given data chunk is created
 using the 
\family typewriter
Generate
\family default
 procedure of the RSA package.
\end_layout

\begin_layout Standard
The same code is used to create a signature over the local AUTH octet chunk
 during the IKE_AUTH exchange, as described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:flow-IKE_AUTH"

\end_inset

.
 The charon IKEv2 daemon currently only supports AUTH octet signatures based
 on the SHA-1 hash algorithm, this must be improved in a future iteration
 so that other hash algorithms are possible.
\end_layout

\begin_layout Subsubsection
Signature verification
\begin_inset CommandInset label
LatexCommand label
name "sub:Signature-verification"

\end_inset


\end_layout

\begin_layout Standard
Similar to the signature generation outlined in the previous section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-generation"

\end_inset

, the TKM provides an Ada generic to verify RSASSA-PKCS1-v1_5 signatures
 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc3447"

\end_inset

.
 To perform a verification, a 
\family typewriter
RSA.Verifier_Type
\family default
 must be initialized using a public key extracted from a trusted certificate.
 The process of trust chain verification is explained in detail in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Certificate-chain-validation"

\end_inset

.
\end_layout

\begin_layout Standard
During the IKE_AUTH exchange, the identity of a remote peer must be asserted.
 This is done by verifying the remote AUTH octet signature.
 If the signature validates, the authentication context (AE) of the IKE
 SA in question is set into the 'authenticated' state, meaning that it is
 now possible to establish child SAs (ESA) under this IKE SA (ISA).
\end_layout

\begin_layout Subsubsection
Certificate chain validation
\begin_inset CommandInset label
LatexCommand label
name "sub:Certificate-chain-validation"

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-validation-overview"

\end_inset

 provides an overview of the steps performed to establish trust in the user
 certificate provided by a peer during the IKE_AUTH exchange.
 The chosen example involves three certificates: The user certificate 
\emph on
A
\emph default
, the intermediate CA certificate 
\emph on
B
\emph default
 and the trusted 
\emph on
CA
\emph default
.
 The goal of the process is to link the user's X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 certificate 
\emph on
A
\emph default
 to the 
\emph on
CA
\emph default
 trusted by the TKM.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-overview.svg
	width 70text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain validation overview
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-validation-overview"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The user certificate depicted as certificate 
\emph on
A
\emph default
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-validation-overview"

\end_inset

 must be validated using the intermediate CA certificate 
\emph on
B
\emph default
 and the intermediate certificate 
\emph on
B
\emph default
 must be validated using the trusted 
\emph on
CA
\emph default
 certificate.
 Validation in the context of a certificate trust chain means to perform
 the following steps:
\end_layout

\begin_layout Enumerate
Checking the validity period of the certificate: The current time (
\family typewriter
Now
\family default
) must be within this period as illustrated by listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:tkm-certificate-validity-check"

\end_inset

.
\end_layout

\begin_layout Enumerate
Verify the signature stored in the certificate by using the public key of
 the subsequent certificate (the issuer certificate).
\end_layout

\begin_layout Enumerate
TODO: additional checks? Issuer etc
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "float,language=Ada"
inline false
status open

\begin_layout Plain Layout

function Is_Valid (V : Validity_Type) return Boolean
\end_layout

\begin_layout Plain Layout

is
\end_layout

\begin_layout Plain Layout

   use Ada.Calendar;
\end_layout

\begin_layout Plain Layout

   Now : constant Time := Clock;
\end_layout

\begin_layout Plain Layout

begin
\end_layout

\begin_layout Plain Layout

   return V.Not_Before < Now and then Now < V.Not_After;
\end_layout

\begin_layout Plain Layout

end Is_Valid;
\end_layout

\begin_layout Plain Layout

\begin_inset Caption

\begin_layout Plain Layout
Certificate validity check
\begin_inset CommandInset label
LatexCommand label
name "lis:tkm-certificate-validity-check"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
To initiate the trust chain validation process in the TKM, a new CC context
 must be instantiated by calling the 
\family typewriter
Cc_Set_User_Certificate
\family default
 RPC as illustrated by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-set-user"

\end_inset

.
 This call stores the user certificate in the CC for which trust must be
 established.
 Before storing the user certificate in the context, the validity is checked.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-set-user.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain set user certificate
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-set-user"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Intermediate CAs and the final CA are added to the CC context by calling
 the 
\family typewriter
Cc_Add_Certificate
\family default
 remote procedure call as shown by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-add-certs"

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-add-cert.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain add certificates
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-add-certs"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The TKM checks the validity of the intermediate CA (certificate 
\emph on
B
\emph default
 in this example) and performs a signature verification of the signature
 stored in the user certificate 
\emph on
A
\emph default
 using the public key of 
\emph on
B
\emph default
.
 The signature is checked using a RSA verifier as explained in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

.
 If the signature verifies, the intermediate certificate 
\emph on
B
\emph default
 is stored in the context along with the user certificate 
\emph on
A
\emph default
.
 The 
\family typewriter
Cc_Add_Certificate
\family default
 procedure must be called multiple times for all intermediate CAs in the
 trust chain and also for the final root CA.
 The ordering of certificates delivered to the TKM is performed by the charon-tk
m bus listener plugin described in section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-Bus-listener-plugin"

\end_inset

.
 If the ordering is incorrect, the verification of the chain fails and the
 IKE SA can not be authenticated.
\end_layout

\begin_layout Standard
The next step is to link the intermediate certificate 
\emph on
B
\emph default
 with certificate 
\emph on
CA
\emph default
, which is also handed to the trusted part by charon-tkm using 
\family typewriter
Cc_Add_Certificate
\family default
.
 The signature contained in certificate 
\emph on
B
\emph default
 must be validated using the public key stored in the 
\emph on
CA
\emph default
 certificate received.
 If the verification is successful, the last step is to check that the top-level
 certificate matches the trusted root 
\emph on
CA
\emph default
, this is done by calling the 
\family typewriter
Cc_Check_Ca
\family default
 RPC as shown by figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:TKM-trustchain-check-ca"

\end_inset

.
 The last certificate added by the 
\family typewriter
Cc_Add_Certificate
\family default
 must be bit-wise identical to the CA trusted by the TKM.
 If this check succeeds, the CC context is set into the 'checked' state
 and the context can be used to verify signatures as explained in section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Signature-verification"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/trustchain-validation-check-ca.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
TKM trustchain check CA
\begin_inset CommandInset label
LatexCommand label
name "fig:TKM-trustchain-check-ca"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Kernel SPD/SAD management
\end_layout

\begin_layout Standard
Since the Linux kernel stores sensitive keying material in its security-associat
ion database, the untrusted part is not allowed to access these databases.
 This must be assured by security mechanisms which are outside of the scope
 of this document.
 As a result, the TKM must manage the kernel's security-policy (SPD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SPD
\end_layout

\end_inset

) and security-association (SAD
\begin_inset Index idx
status collapsed

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) databases itself.
\end_layout

\begin_layout Standard
The xfrm-ada project (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

), which has been developed during this TKM project, is used to install
 security policies on TKM startup and also to manage SA states.
\end_layout

\begin_layout Section
xfrm-proxy
\begin_inset CommandInset label
LatexCommand label
name "sec:xfrm-proxy"

\end_inset


\end_layout

\begin_layout Standard
The xfrm-proxy component uses the xfrm-ada library (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:xfrm-ada"

\end_inset

) developed in this project to communicate with charon's EES service (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:charon-EES-Service"

\end_inset

).
 See figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:XFRM-proxy-architecture"

\end_inset

 for an overview of the proxy architecture.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/xfrm-proxy-arch.svg
	width 60text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
XFRM proxy architecture
\begin_inset CommandInset label
LatexCommand label
name "fig:XFRM-proxy-architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Since the kernel stores critical IPsec policies and SA states, the charon
 daemon is no longer allowed to communicate with the kernel XFRM subsystem.
 
\end_layout

\begin_layout Standard
To make rekeying work in such a scenario, kernel XFRM acquire and expire
 messages must be delivered to charon by other means.
 The xfrm-proxy component subscribes to the kernel's XFRM subsystem acquire
 and expire multicast groups to receive events and delivers them to charon
 using the EES service.
 Charon then normally starts create or rekeying jobs for the policy or SA
 in question.
\end_layout

\begin_layout Section
Additional components
\begin_inset CommandInset label
LatexCommand label
name "sec:Additional-components"

\end_inset


\end_layout

\begin_layout Standard
Certain functionality which was needed for the implementation of TKM has
 been realized in self-contained software projects or as extension to existing
 libraries.
\end_layout

\begin_layout Subsection
Anet
\begin_inset CommandInset label
LatexCommand label
name "sub:Anet"

\end_inset


\end_layout

\begin_layout Standard
Anet is a networking library for the Ada programming language.
 It is used by the trusted key manager and xfrm-proxy to open or connect
 to unix sockets and communicate with charon-tkm.
\end_layout

\begin_layout Standard
Anet has been released as an opensource project under the GMGPL license
 and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=anet.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
xfrm-ada
\begin_inset CommandInset label
LatexCommand label
name "sub:xfrm-ada"

\end_inset


\end_layout

\begin_layout Standard
This project is an Ada binding to Linux's XFRM
\begin_inset Index idx
status open

\begin_layout Plain Layout
XFRM
\end_layout

\end_inset

 kernel
\begin_inset Index idx
status open

\begin_layout Plain Layout
kernel
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.kernel.org/
\end_layout

\end_inset


\end_layout

\end_inset

 interface.
 It provides functionality to add and delete XFRM policies and states.
\end_layout

\begin_layout Standard
The xfrm framework is used to implement the IPsec
\begin_inset Index idx
status open

\begin_layout Plain Layout
IPsec
\end_layout

\end_inset

 protocol suite in the Linux kernel.
 The XFRM states operate on the Security Association Database (SAD
\begin_inset Index idx
status open

\begin_layout Plain Layout
SAD
\end_layout

\end_inset

) and the XFRM policies operate on the Security Policy Database (SPD
\begin_inset Index idx
status open

\begin_layout Plain Layout
SPD
\end_layout

\end_inset

).
 Among other features, it provides ESP
\begin_inset Index idx
status open

\begin_layout Plain Layout
ESP
\end_layout

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc4303"

\end_inset

 payload encryption with the key material provided by an userspace application.
\end_layout

\begin_layout Standard
The TKM uses the XFRM interface via the xfrm-ada library, to manage the
 SPD and SAD and provide the keys for ESP encryption to the kernel.
\end_layout

\begin_layout Standard
xfrm-ada has been released as an opensource project under the GMGPL license
 and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=xfrm-ada.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
x509-Ada
\begin_inset CommandInset label
LatexCommand label
name "sub:x509-Ada"

\end_inset


\end_layout

\begin_layout Standard
This project is an Ada PKIX X.509 
\begin_inset CommandInset citation
LatexCommand cite
key "rfc5280"

\end_inset

 library.
 It provides functionality to process ASN.1/DER-encoded TODO: REF X.680 certificat
es and private keys.
\end_layout

\begin_layout Standard
x509-Ada has been released as an opensource project under the GMGPL license
 and is available at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://git.codelabs.ch/?p=x509-ada.git
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Limitations
\begin_inset CommandInset label
LatexCommand label
name "sec:Limitations"

\end_inset


\end_layout

\begin_layout Standard
This section describes the limitations of the current realisation of the
 design outlined in chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Design"

\end_inset

.
\end_layout

\begin_layout Chapter
Conclusion
\end_layout

\begin_layout Standard
We have shown that...
\end_layout

\begin_layout Section
Achievements
\end_layout

\begin_layout Section
Future work
\end_layout

\begin_layout Standard
Integration into platform such as Linux containers, SELinux, Qubes OS or
 an SK
\end_layout

\begin_layout Standard
\begin_inset CommandInset index_print
LatexCommand printindex
type "idx"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "ike-separation"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
